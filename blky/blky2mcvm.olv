model	"Blockly.XML to Moscovium.ASM translator"
{
	macro	prog_name="Blockly.XML to Moscovium.ASM translator";
	macro	prog_vers="1.08";
// ================================
//
//	Moscovium series Blockly.XML to Moscovium.ASM translator
//		(c) 2024	1YEN Toru
//
//
//		2024/10/19	ver.1.08
//			corresponding to dual core cpu
//			corresponding to S-JIS encoding XML
//			add: translator option @var_iram@
//			del: translator option @var_top@
//			add: mcoc_task, mcoc_sytm_delay_cyc, mcvm_mem_addr
//
//		2024/09/21	ver.1.06
//			determine RAM top address from @rom_siz@ translator option
//			add: translator option @var_top@ (must be ramtop or iramtop)
//
//		2024/09/07	ver.1.04
//			add: mcoc_string_compare_left, mcoc_string_ctoa, mcoc_string_find,
//				mcoc_string_get_char, mcoc_string_label, mcoc_string_pointer,
//				mcoc_string_set
//
//		2024/08/31	ver.1.02
//			fix: do_blk_mcoc_uart_avail
//			fix: do_value, do_blk_mcoc_text_print, do_blk_controls_for
//			fix: do_blk_text: replace "&lt;" as "<"
//			change: reference to temporary string variable _tmp_str
//			change: automatic jump label name "_auto_*"
//			change: conditional branch for float; bmi/bpl to blt/bge
//			add: translator option @sim@ / @rom_siz@
//			add: custom blocks for Moscovium series CPU
//
//		2024/07/27	ver.1.00
//			need: run time library to assemble
//				https://github.com/1YEN-Toru/MCOC115-VD/blob/main/
//					asm/incl/blky2mcvm.incl
//
// ================================


	// constants
	var		opt_int=0;					// opt: int
	var		opt_float=1;				// opt: float
	var		opt_mc=1;					// opt: Mc
	var		opt_nh=2;					// opt: Nh
	macro	str_and="AND";				// str: "and"
	tolower		str_and;
	macro	str_or="OR";				// str: "or"
	tolower		str_or;
	macro	str_not="NOT";				// str: "not"
	tolower		str_not;
	macro	str_whl="WHILE";			// str: "while"
	tolower		str_whl;


	// variables
	var		labid;						// label id
	var		in_var_set;					// in variables_set block
	var		defp_1st=true;				// encounter 1st define procedure
	var		tsk_def_cpu2=false;			// tsk: task CPU2 defined
	var		opt_cpu_mod=0;				// opt: CPU mode Mc (0,1) / Nh (2)
	var		opt_sim_mod=false;			// opt: simulation mode
	var		opt_mul_need=false;			// opt: need MULC16 / or not
	var		opt_div_need=false;			// opt: need DIVC32 / or not
	var		opt_fpu_need=false;			// opt: need FPU / or not
	var		opt_iram_need=false;		// opt: need I-RAM / or not
	var		opt_opr_typ=opt_int;		// opt: operation type (int / float)
	var		opt_cstr_siz=64;			// opt: string buffer size
	var		opt_rom_siz=4*1024;			// opt: instruction ROM size
	macro	vlst_vars;					// list of variables
	macro	vlst_cstr;					// list of string variables
	macro	dir,mynam,ext;
	pathsplit	$(pathname), dir,mynam,ext;


	// input file name
	var		rtn;
	macro	fnam;
	macro	fnam_in;
	macro	fnam_out;
	macro	fnam_tmp;
	gui		openfile, rtn, "Input File","",fnam_in;
	if (rtn=guiCancel)
	{
		// cancelled; select default source
		pathsplit	$(pathname), dir,fnam,ext;
		mlet	fnam_in=$(dir)$/$(fnam)".txt";
		ifnacc	$(fnam_in)
		{
			// cancelled; default source not found
			leave	stop_error;
		}
	}
	pathsplit	$(fnam_in), dir,fnam,ext;
	mlet	fnam_out=$(dir)$/$(fnam)".asm";
	mlet	fnam_tmp=$(dir)$/$(fnam)".tmp";


	// procedures
	procedure	fget_sjis
	{
		// If cod is within the range of the first byte of S-JIS code,
		//	read the second byte.
		if (0x81<=cod & cod<0xa0 | 0xe0<=cod & cod<0xfd)
		{
			var		cod2;

			fgetb	fin,cod2;
			cod=@((cod<<8) + cod2);
		}
	}
	procedure	fget_xml
	{
		// get string between "<" ~ ">"
		//	If the first character is not "<", extract up to the next "<".
		var		cmp;
		var		cod;
		macro	chr;

		ftell	fin,fpos;
		progress	"Translating...",100*fpos/fsiz;

		// read
		fgetb	fin,cod;
		fget_sjis;
		num2chr		chr=cod;
		strcmp	cmp="<",$(chr);
		if (cmp=0)
		{
			// "<" ~ ">"
			repeat
			{
				strcat	fget_xml, $(chr);
				fgetb	fin,cod;
				fget_sjis;
				if (cod<0)
				{
					// ERROR:
					fget_xml=cod;
					break;
				}
				num2chr		chr=cod;
				strcmp	cmp=">",$(chr);
			} until (cmp=0);
			strcat	fget_xml, $(chr);
		}
		else
		{
			// to the next "<"
			var		fpos;

			repeat
			{
				strcat	fget_xml, $(chr);
				ftell	fin,fpos;
				fgetb	fin,cod;
				fget_sjis;
				if (cod<0)
				{
					// ERROR:
					fget_xml=cod;
					break;
				}
				if (cod=0x0a)
				{
					mlet	chr=$,;
				}
				else
				{
					num2chr		chr=cod;
				}
				strcmp	cmp="<",$(chr);
			} until (cmp=0);
			fseek	fin,fpos;
			// ignore newline and indentation
			psub	"^"$," *$","",fget_xml;
			// replace newline with "\n"
			gsub	$,,"\n",fget_xml;
		}
		// remove unnecessary items
		pgsub	"\\"$",$",fget_xml;
		// tag
		pindex	cmp=$(fget_xml),"^<[^>]*>$";
		if (cmp>0)
		{
			pgsub	" [xyhw]="$""[^"$""]*"$","",fget_xml;
			pgsub	" id="$""[^"$""]*"$","",fget_xml;
			pgsub	" varid="$""[^"$""]*"$","",fget_xml;
			pgsub	" inline="$""[^"$""]*"$","",fget_xml;
			pgsub	" pinned="$""[^"$""]*"$","",fget_xml;
			pgsub	" deletable="$""[^"$""]*"$","",fget_xml;
			// change parameters to be space-separated
			repeat
			{
				psub	" ([A-z]+)=("$""[^"$""]*)"," \1 \2",fget_xml;
			} until (status=0);
		}
		// except tag
		pindex	cmp=$(fget_xml),"^<";
		if (cmp<=0)
		{
			gsub	"&#9;","\t",fget_xml;
			gsub	"&#10;","\n",fget_xml;
			gsub	"&gt;",">",fget_xml;
//			gsub	"&lt;","<",fget_xml;	// do not convert
			gsub	"&amp;","&",fget_xml;
		}
		// exit when a read error occurs
		if (fget_xml)
		{
			// error injection
			mlet	fget_xml="<error>";
		}
		// If empty string, read the next one
		//	(the above error processing should be done first)
		strcmp	cmp=$(fget_xml),"";
		if (cmp=0)
		{
			fget_xml;
		}
if (false)
{
	macro	tmp=$(fget_xml);
	pgsub	"#","##",tmp;
	fprint	fout,"##fget_xml:"$(tmp)$,;
}
	}
	procedure	analyze_xml		$$xstr
	{
		// analyze XML
		nvar	ax_idx;
		nvar	ax_num;
		nvar	ax_cmp;

		// XML?
		pindex	ax_cmp=$(fget_xml),"^<";
		if (ax_cmp<=0)
		{
			analyze_xml=0;
			return;
		}

		// analyze
		psub	"<([^>]*)>","\1",xstr;
		field	ax_num=xstr;
		nmacro	_xml_;
		mlet	_xml_=$(xstr1);
		ax_idx=2;
		static : while (ax_idx<ax_num)
		{
			nmacro	_xml_$(xstr#(ax_idx));
			mlet	_xml_$(xstr#(ax_idx))=$(xstr#(ax_idx + 1));
			psub	$""([^"$""]*)"$","\1",_xml_$(xstr#(ax_idx));

			// continue
			ax_idx=ax_idx + 2;
		}
		analyze_xml=ax_num;
	}
	procedure	skip_one	$$sxml
	{
		// skip the block sxml (return if it finds <next>.)
		var		cmp;

		while (true)
		{
			fget_xml;
			pindex	cmp=$(fget_xml),"</"$(sxml)"[ >";
			if (cmp<=0)
			{
				pindex	cmp=$(fget_xml),"^<next[ >]";
			}
			if (cmp>0)
			{
				break;
			}

			static : analyze_xml	$(fget_xml);
			if (analyze_xml=0)
			{
				continue;
			}
			strcmp	cmp=$(_xml_),"/",left;
			if (cmp=0)
			{
				continue;
			}

			skip_one	$(_xml_);
			pindex	cmp=$(fget_xml),"^<next[ >]";
			if (cmp>0)
			{
				break;
			}
		}
	}
	procedure	is_cstr		$$vnam
	{
		// return true if variable vnam was C-string variable
		pindex	is_cstr=$(vlst_cstr),"@"$(vnam)"@";
		is_cstr=!( is_cstr=false );
	}
	procedure	register_cstr	$$vnam
	{
		// register C-string variable vnam
		is_cstr		$(vnam);
		if (!is_cstr)
		{
			mlet	vlst_cstr=$(vlst_cstr)"@"$(vnam)"@";
			gsub	"@@","@",vlst_cstr;
		}
	}
	procedure	is_vars		$$vnam
	{
		// return true if variable vnam was registered
		pindex	is_vars=$(vlst_vars),"@"$(vnam)"@";
	}
	procedure	register_vars	$$vnam
	{
		// register variable vnam
		is_vars		$(vnam);
		if (!is_vars)
		{
			mlet	vlst_vars=$(vlst_vars)"@"$(vnam)"@";
			gsub	"@@","@",vlst_vars;
		}
	}
	procedure	asm_ld_var_adr	$$reg,$$vnam
	{
		// load address of variable vnam to general register reg
		//	outputs the assembler source list and returns
		//	R6: starting address of the variable area

		// assembler
		fprint	fout,"ldwi	"$(reg)","$(vnam)$,;
		fprint	fout,"add	"$(reg)",r6"$,;
	}
	procedure	asm_ld_var	$$reg,$$vnam,$$treg
	{
		// load the value of the variable vnam into general register reg
		//	outputs the assembler source list and returns
		//	uses general register treg for the pointer to the variable
		//	if treg is omitted, uses treg = reg
		nmacro	treg=$(reg);

		// assembler
		fprint	fout,"// "$(reg)"="$(vnam)$,;
		asm_ld_var_adr	$(treg),$(vnam);
		fprint	fout,"ld$(z)	"$(reg)",["$(treg)"]"$,;
	}
	procedure	define_cstr
	{
		// outputs assembler source list to allocate
		//	and initialize C-string variable area
		var		idx;
		var		num;

		// assembler
		fprint	fout,""$,;
		fprint	fout,"// initialize string variables"$,;
		fprint	fout,"_rtlb_vlst_cstr:"$,;

		psub	"^@","",vlst_cstr;
		field	num=vlst_cstr,"@";
		idx=1;
		while (idx<num)
		{
			// assembler
			fprint	fout,"// "$(vlst_cstr#(idx))"=&(_cstr_"
					$(vlst_cstr#(idx))"="$"$"")"$,;
			asm_ld_var_adr	"r7",$(vlst_cstr#(idx));
			asm_ld_var_adr	"r0","_cstr_"$(vlst_cstr#(idx));
			fprint	fout,"st$(z)	[r7],r0"$,;
			fprint	fout,"ldbiu	r7,0"$,;
			fprint	fout,"stb	[r0],r7"$,;

			// continue
			idx=idx + 1;
		}

		// assembler
		fprint	fout,"// end of initialize string variables"$,;
		fprint	fout,"rtn$(z)"$,;
	}
	procedure	translator_options
	{
		// interpret the compile options in <comment>(cmnt)
		//	translator option: <comment>.*@<options>@.*</comment>
		//	<options>: <option>[,<option>[,...]]
		//	<option>: Mc / Nh / sim / int / float / <opt_name>=<val>
		//	<opt_name>: name of option
		//	<val>: numerical value
		var		idx;
		var		cmp;
		var		num;
		macro	copt;

		// translator options
		mlet	copt=$(cmnt);
		psub	".*@([^@]+)@.*","\1",copt;
		pgsub		"[ 	]","",copt;
		tolower		copt;
		field	num=copt,",";
		idx=1;
		while (idx<=num)
		{
			strcmp	cmp=$(copt#(idx)),"Mc",ics_match;
			if (cmp)
			{
				strcmp	cmp=$(copt#(idx)),"mcvm",ics_match;
			}
			if (cmp)
			{
				strcmp	cmp=$(copt#(idx)),"Moscovium",ics_match;
			}
			if (cmp=0)
			{
				if (opt_cpu_mod=opt_nh)
				{
					// ERROR:
					errmsg	"translator_options: re-defined CPU mode ("
							$(copt#(idx))")";
					leave	stop_error;
				}
				opt_cpu_mod=opt_mc;
			}
			strcmp	cmp=$(copt#(idx)),"Nh",ics_match;
			if (cmp)
			{
				strcmp	cmp=$(copt#(idx)),"niho",ics_match;
			}
			if (cmp)
			{
				strcmp	cmp=$(copt#(idx)),"Nihonium",ics_match;
			}
			if (cmp=0)
			{
				if (opt_cpu_mod=opt_mc)
				{
					// ERROR:
					errmsg	"translator_options: re-defined CPU mode ("
							$(copt#(idx))")";
					leave	stop_error;
				}
				opt_cpu_mod=opt_nh;
			}
			strcmp	cmp=$(copt#(idx)),"sim";
			if (cmp=0)
			{
				opt_sim_mod=true;
			}
			strcmp	cmp=$(copt#(idx)),"int";
			if (cmp=0)
			{
				opt_opr_typ=opt_int;
			}
			strcmp	cmp=$(copt#(idx)),"float";
			if (cmp=0)
			{
				opt_opr_typ=opt_float;
				opt_fpu_need=true;
			}
			strcmp	cmp=$(copt#(idx)),"var_iram";
			if (cmp=0)
			{
				opt_iram_need=true;
			}
			index	cmp=$(copt#(idx)),"=";
			if (cmp>0)
			{
				macro	vnam;
				macro	nval;

				mlet	vnam=$(copt#(idx));
				psub	"=.*","",vnam;
				mlet	nval=$(copt#(idx));
				psub	".*=","",nval;
				static : nvar	opt_$(vnam);
				opt_$(vnam)=$(nval);
			}

			// continue
			idx=idx + 1;
		}

		// assembler
		fprint	fout,"// translator options: ("$(copt)")"$,;
	}
	procedure	do_comment
	{
		var		cmp;
		macro	cmnt;

		while (true)
		{
			fget_xml;
			macro	cxml=$(fget_xml);
			pindex	cmp=$(cxml),"^</comment[ >]";
			if (cmp>0)
			{
				break;
			}

			pindex	cmp=$(cxml),"^<[^/]";
			if (cmp>0)
			{
				static : analyze_xml	$(cxml);
				macro	dxml=$(_xml_);
				do_$(dxml);
			}
			else
			{
				mlet	cmnt=$(cmnt)$(cxml);
			}
		}

		// translator option
		pindex	cmp=$(cmnt),"@[^@]*@";
		if (cmp>0)
		{
			translator_options;
			psub	"@([^@]+)@","",cmnt;
		}

		// comment
		mlet	cmnt="// "$(cmnt);
		repeat
		{
			psub	"\\n[	 ]+$","",cmnt;
		} until (status=0);
		gsub	"&lt;","<",cmnt;
		gsub	"\t","	",cmnt;
		gsub	"\n",$,"// ",cmnt;
		gsub	"// 	","//	",cmnt;
		gsub	"// "$,,"//"$,,cmnt;
		psub	"// $","//",cmnt;
		gsub	"#","##",cmnt;

		// assembler
		strcmp	cmp=$(cmnt),"//";
		if (cmp)
		{
			fprint	fout,$(cmnt)$,;
		}
	}
	procedure	do_shadow
	{
		// empty, ignore shadow
	}
	procedure	do_field
	{
		var		cmp;
		var		is_txt;

		// text field?
		strcmp	cmp=$(_xml_name),"TEXT",ics_match;
		is_txt=( cmp=0 );

		while (true)
		{
			fget_xml;
			macro	cxml=$(fget_xml);
			pindex	cmp=$(cxml),"^</field[ >]";
			if (cmp>0)
			{
				break;
			}

			pindex	cmp=$(cxml),"^<";
			if (cmp<=0)
			{
				mlet	do_field=$(cxml);
			}
			pindex	cmp=$(cxml),"^<[^/]";
			if (cmp>0)
			{
				static : analyze_xml	$(cxml);
				macro	dxml=$(_xml_);
				do_$(dxml);
				mlet	do_field=$(do_$(dxml));
			}
		}
		if (is_txt)
		{
			gsub	$","\x22",do_field;
			mlet	do_field=$"$(do_field)$";
		}
	}
	procedure	do_value
	{
		var		cmp;
		var		val_done=true;

		strcmp	cmp=$(_xml_name),"text",ics_match;
		if (cmp=0)
		{
			val_done=false;
		}
		while (true)
		{
			fget_xml;
			macro	cxml=$(fget_xml);
			pindex	cmp=$(cxml),"^</value[ >]";
			if (cmp>0)
			{
				break;
			}

			pindex	cmp=$(cxml),"^<[^/]";
			if (cmp>0)
			{
				static : analyze_xml	$(cxml);
				macro	dxml=$(_xml_);
				do_$(dxml);
				strcmp	cmp=$(dxml),"block";
				if (cmp)
				{
					val_done=false;
				}
				mlet	do_value=$(do_$(dxml));
			}
		}
		strcmp	cmp=$(do_value),$",left;
		if (!val_done & cmp=0)
		{
// this code has never been activated.(?)
			// assembler
			labid=labid + 1;
			macro	slabid;
			num2str		slabid=labid,"%04x";
			macro	cstr=$(do_value);
			psub	"^"$""([^"$""]*)"$""$","\1",cstr;
			gsub	"&lt;","<",cstr;
			fprint	fout,"// r1="$(do_value)$,;
			fprint	fout,"ldwi	r1,lab__auto_"$(slabid)"_text"$,;
			fprint	fout,"bra	_auto_"$(slabid)_pool$,;
			fprint	fout,"_auto_"$(slabid)"_text:"$,;
			fprint	fout,"dats	"$"$(cstr)"\0"$"$,;
			fprint	fout,"_auto_"$(slabid)"_pool:"$,;
		}
		else
		{
			pindex	cmp=$(do_value),"^[0-9.+-]";
			if (cmp>0)
			{
				index	cmp=$(do_value)," ";
				cmp=( cmp=0 );
			}
			if (!val_done & cmp>0)
			{
				// assembler
				fprint	fout,"// r0="$(do_value)$,;
				if (opt_opr_typ=opt_int)
				{
					fprint	fout,"ld$(z)i	r0,"$(do_value)$,;
				}
				else
				{
					fprint	fout,"fld$(z)i	r0,"$(do_value)$,;
				}
			}
		}
	}
	procedure	do_mutation
	{
		var		cmp;

		while (true)
		{
			fget_xml;
			macro	cxml=$(fget_xml);
			pindex	cmp=$(cxml),"^</mutation[ >]";
			if (cmp>0)
			{
				break;
			}

			pindex	cmp=$(cxml),"^<[^/]";
			if (cmp>0)
			{
				static : analyze_xml	$(cxml);
				macro	dxml=$(_xml_);
				nmacro	_xml_name;
				macro	dnam=$(_xml_name);
				strcmp	cmp=$(dxml),"arg";
				if (cmp=0)
				{
					strcat	do_mutation,$(dnam)" ";
					continue;
				}
				do_$(dxml);
			}
		}
	}
	procedure	do_variable
	{
		fget_xml;
		register_vars	$(fget_xml);
	}
	procedure	do_variables
	{
		var		cmp;

		while (true)
		{
			fget_xml;
			macro	cxml=$(fget_xml);
			pindex	cmp=$(cxml),"^</variables[ >]";
			if (cmp>0)
			{
				break;
			}

			pindex	cmp=$(cxml),"^<[^/]";
			if (cmp>0)
			{
				static : analyze_xml	$(cxml);
				macro	dxml=$(_xml_);
				do_$(dxml);
			}
		}
	}
	procedure	do_blk_variables_set
	{
		var		cmp;
		macro	vnam;
		macro	nval;

		in_var_set=true;
		while (true)
		{
			fget_xml;
			macro	cxml=$(fget_xml);
			pindex	cmp=$(cxml),"^</block[ >]";
			if (cmp<=0)
			{
				pindex	cmp=$(cxml),"^<next[ >]";
			}
			if (cmp>0)
			{
				break;
			}

			pindex	cmp=$(cxml),"^<[^/]";
			if (cmp>0)
			{
				static : analyze_xml	$(cxml);
				macro	dxml=$(_xml_);
				do_$(dxml);
				strcmp	cmp=$(dxml),"field";
				if (cmp=0)
				{
					mlet	vnam=$(do_$(dxml));
					is_cstr		$(vnam);
					if (is_cstr)
					{
						// string variable

						// assembler
						asm_ld_var	"r0",$(vnam);
						fprint	fout,"push$(z)	r0"$,;
					}
				}
				strcmp	cmp=$(dxml),"value";
				if (cmp=0)
				{
					mlet	nval=$(do_$(dxml));
					strcmp	cmp=$(nval),$",left;
					is_cstr		$(vnam);
					if ((!is_cstr) & cmp=0)
					{
						// string variable declaration
						register_cstr	$(vnam);

						// assembler
						asm_ld_var	"r0",$(vnam);
						fprint	fout,"push$(z)	r0"$,;
					}
				}
			}
		}
		in_var_set=false;

		// target variable
		register_vars	$(vnam);
		is_cstr		$(vnam);
		if (!is_cstr)
		{
			// variable = <number>

			// assembler
			fprint	fout,"// "$(vnam)"=r0(="$(nval)")"$,;
			asm_ld_var_adr	"r7",$(vnam);
			fprint	fout,"st$(z)	[r7],r0"$,;
		}
		else
		{
			// string variable = <string>

			// assembler
			fprint	fout,"// end of "$(vnam)"="$(nval)$,;

			strcmp	cmp=$(nval),"'", left;
			if (cmp=0)
			{
				// already processed (number ==> string)

				// assembler
				fprint	fout,"pop$(z)	r0	// discard"$,;
			}
			else
			{
				strcmp	cmp=$(nval)," ++ ",left;
				if (cmp=0)
				{
					// joined
					psub	"^ \+\+ ","",nval;

					// assembler
					fprint	fout,"pop$(z)	r0	// discard"$,;
				}
				else
				{
					// not joined
					pindex	cmp=$(nval),"^"$""[^"$""]*"$""$";
					if (cmp<=0)
					{
						// not a string constant
						is_cstr		$(nval);
						if (is_cstr)
						{
							// string variable
							cmp=1;
						}
					}
					if (cmp>0)
					{
						// string constant or string variable

						// assembler
						fprint	fout,"pop$(z)	r0"$,;
						fprint	fout,"jal$(z)r7	_strcpy_r0_r1"$,;
					}
					else
					{
						// number

						// assembler
						fprint	fout,"// r1=r0(="$(nval)")"$,;
						fprint	fout,"mov	r1,r0"$,;
						fprint	fout,"// r0=strdec (r0,r1(="$(nval)"))"$,;
						fprint	fout,"pop$(z)	r0"$,;
						fprint	fout,"jal$(z)r7	_strdec_r0_r1"$,;
					}
				}
			}
		}
	}
	procedure	do_blk_variables_get
	{
		var		cmp;
		macro	vnam;

		while (true)
		{
			fget_xml;
			macro	cxml=$(fget_xml);
			pindex	cmp=$(cxml),"^</block[ >]";
			if (cmp>0)
			{
				break;
			}

			pindex	cmp=$(cxml),"^<[^/]";
			if (cmp>0)
			{
				static : analyze_xml	$(cxml);
				macro	dxml=$(_xml_);
				do_$(dxml);
				mlet	vnam=$(do_$(dxml));
			}
		}
		mlet	do_blk_variables_get=$(vnam);
		register_vars	$(vnam);

		// assembler
		is_cstr		$(vnam);
		if (is_cstr)
		{
			asm_ld_var	"r1",$(vnam);
		}
		else
		{
			asm_ld_var	"r0",$(vnam);
		}
	}
	procedure	do_blk_mcvm_cpu_asm
	{
		var		cmp;
		macro	iasm;

		while (true)
		{
			fget_xml;
			macro	cxml=$(fget_xml);
			pindex	cmp=$(cxml),"^</block[ >]";
			if (cmp<=0)
			{
				pindex	cmp=$(cxml),"^<next[ >]";
			}
			if (cmp>0)
			{
				break;
			}

			pindex	cmp=$(cxml),"^<[^/]";
			if (cmp>0)
			{
				static : analyze_xml	$(cxml);
				macro	dxml=$(_xml_);
				do_$(dxml);
				strcmp	cmp=$(dxml),"field";
				if (cmp=0)
				{
					mlet	iasm=$(do_$(dxml));
				}
			}
		}

		// assembler
		pgsub	"\\t","	",iasm;
		pgsub	"\\n",$,,iasm;
		pgsub	"#","##",iasm;
		fprint	fout,$(iasm)$,;
	}
	procedure	do_blk_mcvm_cpu_cend
	{
		var		cmp;
		macro	nval;

		while (true)
		{
			fget_xml;
			macro	cxml=$(fget_xml);
			pindex	cmp=$(cxml),"^</block[ >]";
			if (cmp<=0)
			{
				pindex	cmp=$(cxml),"^<next[ >]";
			}
			if (cmp>0)
			{
				break;
			}

			pindex	cmp=$(cxml),"^<[^/]";
			if (cmp>0)
			{
				static : analyze_xml	$(cxml);
				macro	dxml=$(_xml_);
				do_$(dxml);
				strcmp	cmp=$(dxml),"value";
				if (cmp=0)
				{
					mlet	nval=$(do_$(dxml));
				}
			}
		}
		mlet	do_blk_mcvm_cpu_cend="cend ("$(nval)")";

		// assembler
		fprint	fout,"// convert endian r0(="$(nval)")"$,;
		fprint	fout,"cend$(z)	r0"$,;
	}
	procedure	do_blk_mcvm_cpu_reg
	{
		var		cmp;
		macro	rnam;

		while (true)
		{
			fget_xml;
			macro	cxml=$(fget_xml);
			pindex	cmp=$(cxml),"^</block[ >]";
			if (cmp<=0)
			{
				pindex	cmp=$(cxml),"^<next[ >]";
			}
			if (cmp>0)
			{
				break;
			}

			pindex	cmp=$(cxml),"^<[^/]";
			if (cmp>0)
			{
				static : analyze_xml	$(cxml);
				macro	dxml=$(_xml_);
				do_$(dxml);
				strcmp	cmp=$(dxml),"field";
				if (cmp=0)
				{
					mlet	rnam=$(do_$(dxml));
				}
			}
		}
		mlet	do_blk_mcvm_cpu_reg=$(rnam);

		// assembler
		strcmp	cmp=$(rnam),"r", left;
		fprint	fout,"// r0="$(rnam)$,;
		if (cmp=0)
		{
			// general register
			fprint	fout,"mov	r0,"$(rnam)$,;
		}
		else
		{
			// control register
			fprint	fout,"movfc	r0,"$(rnam)$,;
		}
	}
	procedure	do_blk_mcvm_cpu_set
	{
		var		cmp;
		macro	rnam;
		macro	nval;

		while (true)
		{
			fget_xml;
			macro	cxml=$(fget_xml);
			pindex	cmp=$(cxml),"^</block[ >]";
			if (cmp<=0)
			{
				pindex	cmp=$(cxml),"^<next[ >]";
			}
			if (cmp>0)
			{
				break;
			}

			pindex	cmp=$(cxml),"^<[^/]";
			if (cmp>0)
			{
				static : analyze_xml	$(cxml);
				macro	dxml=$(_xml_);
				do_$(dxml);
				strcmp	cmp=$(dxml),"field";
				if (cmp=0)
				{
					mlet	rnam=$(do_$(dxml));
				}
				strcmp	cmp=$(dxml),"value";
				if (cmp=0)
				{
					mlet	nval=$(do_$(dxml));
				}
			}
		}

		// assembler
		strcmp	cmp=$(rnam),"r", left;
		fprint	fout,"// "$(rnam)"=r0(="$(nval)")"$,;
		if (cmp=0)
		{
			// general register
			fprint	fout,"mov	"$(rnam)",r0"$,;
		}
		else
		{
			// control register
			fprint	fout,"movtc	"$(rnam)",r0"$,;
		}
	}
	procedure	do_blk_mcvm_fpu_isinf
	{
		var		cmp;
		macro	nval;

		while (true)
		{
			fget_xml;
			macro	cxml=$(fget_xml);
			pindex	cmp=$(cxml),"^</block[ >]";
			if (cmp<=0)
			{
				pindex	cmp=$(cxml),"^<next[ >]";
			}
			if (cmp>0)
			{
				break;
			}

			pindex	cmp=$(cxml),"^<[^/]";
			if (cmp>0)
			{
				static : analyze_xml	$(cxml);
				macro	dxml=$(_xml_);
				do_$(dxml);
				strcmp	cmp=$(dxml),"value";
				if (cmp=0)
				{
					mlet	nval=$(do_$(dxml));
				}
			}
		}
		mlet	do_blk_mcvm_fpu_isinf="isinf ("$(nval)")";

		// assembler
		fprint	fout,"// r0=abs (r0)"$,;
		fprint	fout,"lsli	r0,1"$,;
		fprint	fout,"lsri	r0,1"$,;
		fprint	fout,"// r1=INF"$,;
		fprint	fout,"ld$(z)i	r1,_rtlb_inf$(z)"$,;
		fprint	fout,"// r0=isinf (r0(="$(nval)"))"$,;
		fprint	fout,"fcmp	r0,r1"$,;	// fcmp is better than cmp
		fprint	fout,"ldbiu	r0,true"$,;
		fprint	fout,"bcs	pcnt+2"$,;
		fprint	fout,"ldbiu	r0,false"$,;
		opt_fpu_need=true;
	}
	procedure	do_blk_mcvm_fpu_isnan
	{
		var		cmp;
		macro	nval;

		while (true)
		{
			fget_xml;
			macro	cxml=$(fget_xml);
			pindex	cmp=$(cxml),"^</block[ >]";
			if (cmp<=0)
			{
				pindex	cmp=$(cxml),"^<next[ >]";
			}
			if (cmp>0)
			{
				break;
			}

			pindex	cmp=$(cxml),"^<[^/]";
			if (cmp>0)
			{
				static : analyze_xml	$(cxml);
				macro	dxml=$(_xml_);
				do_$(dxml);
				strcmp	cmp=$(dxml),"value";
				if (cmp=0)
				{
					mlet	nval=$(do_$(dxml));
				}
			}
		}
		mlet	do_blk_mcvm_fpu_isnan="isnan ("$(nval)")";

		// assembler
		fprint	fout,"// r1=NaN"$,;
		fprint	fout,"ld$(z)i	r1,_rtlb_nan$(z)"$,;
		fprint	fout,"// r0=isnan (r0(="$(nval)"))"$,;
		fprint	fout,"fcmp	r0,r1"$,;	// fcmp is better than cmp
		fprint	fout,"ldbiu	r0,true"$,;
		fprint	fout,"bcs	pcnt+2"$,;
		fprint	fout,"ldbiu	r0,false"$,;
		opt_fpu_need=true;
	}
	procedure	do_blk_mcvm_fpu_fdown
	{
		var		cmp;
		macro	nval;

		while (true)
		{
			fget_xml;
			macro	cxml=$(fget_xml);
			pindex	cmp=$(cxml),"^</block[ >]";
			if (cmp>0)
			{
				break;
			}

			pindex	cmp=$(cxml),"^<[^/]";
			if (cmp>0)
			{
				static : analyze_xml	$(cxml);
				macro	dxml=$(_xml_);
				do_$(dxml);
				strcmp	cmp=$(dxml),"value";
				if (cmp=0)
				{
					mlet	nval=$(do_$(dxml));
				}
			}
		}

		// assembler
		fprint	fout,"// r0=fdown (r0(="$(nval)"))"$,;
		fprint	fout,"fdown	r0,r0"$,;
		opt_fpu_need=true;

		mlet	do_blk_mcvm_fpu_fdown="fdown ("$(nval)")";
	}
	procedure	do_blk_mcvm_fpu_ftoi
	{
		macro	ctyp="int";

		do_blk_cast_number;
		mlet	do_blk_mcvm_fpu_ftoi=$(do_blk_cast_number);
	}
	procedure	do_blk_mcvm_fpu_itof
	{
		macro	ctyp="float";

		do_blk_cast_number;
		mlet	do_blk_mcvm_fpu_itof=$(do_blk_cast_number);
	}
	procedure	do_blk_mcvm_sim_pass
	{
		var		cmp;

		while (true)
		{
			fget_xml;
			macro	cxml=$(fget_xml);
			pindex	cmp=$(cxml),"^</block[ >]";
			if (cmp<=0)
			{
				pindex	cmp=$(cxml),"^<next[ >]";
			}
			if (cmp>0)
			{
				break;
			}

			pindex	cmp=$(cxml),"^<[^/]";
			if (cmp>0)
			{
				static : analyze_xml	$(cxml);
				macro	dxml=$(_xml_);
				do_$(dxml);
			}
		}

		// assembler
		fprint	fout,"$(s)// simulation pass"$,;
		fprint	fout,"$(s)// ********************************"$,;
		fprint	fout,"$(s)ldwi	r0,simpass"$,;
		fprint	fout,"$(s)ldwi	r7,simfnsh"$,;
		fprint	fout,"$(s)stw	[r7],r0"$,;
		fprint	fout,"$(s)// ********************************"$,;
	}
	procedure	do_blk_mcvm_sim_fail
	{
		var		cmp;

		while (true)
		{
			fget_xml;
			macro	cxml=$(fget_xml);
			pindex	cmp=$(cxml),"^</block[ >]";
			if (cmp<=0)
			{
				pindex	cmp=$(cxml),"^<next[ >]";
			}
			if (cmp>0)
			{
				break;
			}

			pindex	cmp=$(cxml),"^<[^/]";
			if (cmp>0)
			{
				static : analyze_xml	$(cxml);
				macro	dxml=$(_xml_);
				do_$(dxml);
			}
		}

		// assembler
		fprint	fout,"$(s)// simulation fail"$,;
		fprint	fout,"$(s)// ********************************"$,;
		fprint	fout,"$(s)ldwi	r0,simfail"$,;
		fprint	fout,"$(s)ldwi	r7,simfnsh"$,;
		fprint	fout,"$(s)stw	[r7],r0"$,;
		fprint	fout,"$(s)// ********************************"$,;
	}
	procedure	do_blk_mcvm_mem_addr
	{
		var		cmp;
		macro	vnam;

		while (true)
		{
			fget_xml;
			macro	cxml=$(fget_xml);
			pindex	cmp=$(cxml),"^</block[ >]";
			if (cmp<=0)
			{
				pindex	cmp=$(cxml),"^<next[ >]";
			}
			if (cmp>0)
			{
				break;
			}

			pindex	cmp=$(cxml),"^<[^/]";
			if (cmp>0)
			{
				static : analyze_xml	$(cxml);
				macro	dxml=$(_xml_);
				nmacro	_xml_name;
				macro	dnam=$(_xml_name);
				do_$(dxml);
				strcmp	cmp=$(dxml),"field";
				if (cmp=0)
				{
					mlet	vnam=$(do_$(dxml));
				}
			}
		}

		// assembler
		is_cstr		$(vnam);
		if (is_cstr)
		{
			// string variable
			asm_ld_var	"r0",$(vnam);
			mlet	do_blk_mcvm_mem_addr=$(vnam);
		}
		else
		{
			// variable
			fprint	fout,"// r0=&"$(vnam)$,;
			asm_ld_var_adr	"r0",$(vnam);
			mlet	do_blk_mcvm_mem_addr="&"$(vnam);
		}
	}
	procedure	do_blk_mcvm_mem_read
	{
		var		cmp;
		nvar	asiz=2;
		macro	adrx;
		macro	adr;

		while (true)
		{
			fget_xml;
			macro	cxml=$(fget_xml);
			pindex	cmp=$(cxml),"^</block[ >]";
			if (cmp<=0)
			{
				pindex	cmp=$(cxml),"^<next[ >]";
			}
			if (cmp>0)
			{
				break;
			}

			pindex	cmp=$(cxml),"^<[^/]";
			if (cmp>0)
			{
				static : analyze_xml	$(cxml);
				macro	dxml=$(_xml_);
				nmacro	_xml_name;
				macro	dnam=$(_xml_name);
				do_$(dxml);
				strcmp	cmp=$(dxml),"field";
				if (cmp=0)
				{
					macro	siz=$(do_$(dxml));
					strcmp	cmp=$(siz),"B",ics_left;
					if (cmp=0)
					{
						asiz=1;
					}
					strcmp	cmp=$(siz),"W",ics_left;
					if (cmp=0)
					{
						asiz=2;
					}
					strcmp	cmp=$(siz),"L",ics_left;
					if (cmp=0)
					{
						asiz=4;
					}
				}
				strcmp	cmp=$(dxml),"value";
				if (cmp=0)
				{
					strcmp	cmp=$(dnam),"ADRX";
					if (cmp=0)
					{
						mlet	adrx=$(do_$(dxml));

						// assembler
						fprint	fout,"// tr=r0(="$(adrx)")"$,;
						fprint	fout,"movtc	tr,r0"$,;
					}
					else
					{
						mlet	adr=$(do_$(dxml));
					}
				}
			}
		}
		mlet	do_blk_mcvm_mem_read="["$(adr)"]";

		// check
		if (asiz=4 & opt_cpu_mod!=opt_nh)
		{
			// ERROR:
			errmsg	"mcvm_mem_read: need @Nh@ translator option"
					" for long access";
			leave	stop_error;
		}

		// assembler
		strcmp	cmp=$(adrx),"";
		if (cmp=0)
		{
			fprint	fout,"// r0=[r0(="$(adr)")]"$,;
			if (asiz=4)
			{
				fprint	fout,"ldl	r0,[r0]"$,;
			}
			elif (asiz=2)
			{
				fprint	fout,"ldw	r0,[r0]"$,;
			}
			else
			{
				fprint	fout,"ldb	r0,[r0]"$,;
			}
		}
		else
		{
			fprint	fout,"// r0=[tr(="$(adrx)"):r0(="$(adr)")]"$,;
			if (asiz=2)
			{
				fprint	fout,"ldwx	r0,[tr:r0]"$,;
			}
			else
			{
				fprint	fout,"ldbx	r0,[tr:r0]"$,;
			}

			mlet	do_blk_mcvm_mem_read="["$(adrx)":"$(adr)"]";
		}
	}
	procedure	do_blk_mcvm_memx_read
	{
		do_blk_mcvm_mem_read;
		mlet	do_blk_mcvm_memx_read=$(do_blk_mcvm_mem_read);
	}
	procedure	do_blk_mcvm_mem_write
	{
		var		cmp;
		nvar	asiz=2;
		macro	adrx;
		macro	adr;
		macro	dat;

		while (true)
		{
			fget_xml;
			macro	cxml=$(fget_xml);
			pindex	cmp=$(cxml),"^</block[ >]";
			if (cmp<=0)
			{
				pindex	cmp=$(cxml),"^<next[ >]";
			}
			if (cmp>0)
			{
				break;
			}

			pindex	cmp=$(cxml),"^<[^/]";
			if (cmp>0)
			{
				static : analyze_xml	$(cxml);
				macro	dxml=$(_xml_);
				nmacro	_xml_name;
				macro	dnam=$(_xml_name);
				do_$(dxml);
				strcmp	cmp=$(dxml),"field";
				if (cmp=0)
				{
					macro	siz=$(do_$(dxml));
					strcmp	cmp=$(siz),"B",ics_left;
					if (cmp=0)
					{
						asiz=1;
					}
					strcmp	cmp=$(siz),"W",ics_left;
					if (cmp=0)
					{
						asiz=2;
					}
					strcmp	cmp=$(siz),"L",ics_left;
					if (cmp=0)
					{
						asiz=4;
					}
				}
				strcmp	cmp=$(dxml),"value";
				if (cmp=0)
				{
					strcmp	cmp=$(dnam),"ADRX";
					if (cmp=0)
					{
						mlet	adrx=$(do_$(dxml));

						// assembler
						fprint	fout,"// tr=r0(="$(adrx)")"$,;
						fprint	fout,"movtc	tr,r0"$,;
					}
					strcmp	cmp=$(dnam),"ADR";
					if (cmp=0)
					{
						mlet	adr=$(do_$(dxml));

						// assembler
						fprint	fout,"push$(z)	r0"$,;
					}
					strcmp	cmp=$(dnam),"DAT";
					if (cmp=0)
					{
						mlet	dat=$(do_$(dxml));

						// assembler
						fprint	fout,"// r7(="$(adr)")"$,;
						fprint	fout,"pop$(z)	r7"$,;
					}
				}
			}
		}

		// check
		if (asiz=4 & opt_cpu_mod!=opt_nh)
		{
			// ERROR:
			errmsg	"mcvm_mem_write: need @Nh@ translator option"
					" for long access";
			leave	stop_error;
		}

		// assembler
		strcmp	cmp=$(adrx),"";
		if (cmp=0)
		{
			fprint	fout,"// [r7(="$(adr)")] = r0(="$(dat)")"$,;
			if (asiz=4)
			{
				fprint	fout,"stl	[r7],r0"$,;
			}
			elif (asiz=2)
			{
				fprint	fout,"stw	[r7],r0"$,;
			}
			else
			{
				fprint	fout,"stb	[r7],r0"$,;
			}
		}
		else
		{
			fprint	fout,"// [tr(="$(adrx)"):r7(="$(adr)")] = r0(="$(dat)")"$,;
			if (asiz=2)
			{
				fprint	fout,"stwx	[tr:r7],r0"$,;
			}
			else
			{
				fprint	fout,"stbx	[tr:r7],r0"$,;
			}
		}
	}
	procedure	do_blk_mcvm_memx_write
	{
		do_blk_mcvm_mem_write;
		mlet	do_blk_mcvm_memx_write=$(do_blk_mcvm_mem_write);
	}
	procedure	do_blk_mcoc_math_ascii
	{
		var		cmp;
		var		chr;
		macro	cstr;
		macro	shex;

		while (true)
		{
			fget_xml;
			macro	cxml=$(fget_xml);
			pindex	cmp=$(cxml),"^</block[ >]";
			if (cmp>0)
			{
				break;
			}

			pindex	cmp=$(cxml),"^<[^/]";
			if (cmp>0)
			{
				static : analyze_xml	$(cxml);
				macro	dxml=$(_xml_);
				do_$(dxml);
				strcmp	cmp=$(dxml),"field";
				if (cmp=0)
				{
					mlet	cstr=$(do_$(dxml));
				}
			}
		}

		// ascii code
		gsub	"&lt;","<",cstr;
		psub	"^(.).*","\1",cstr;
		gsub	"#","##",cstr;
		chr2num		chr=$(cstr);
		num2str		shex=chr,"%02x";
		mlet	do_blk_mcoc_math_ascii="0a"$(cstr);

		// assembler
		fprint	fout,"// r0=0a"$(cstr)"(=0x"$(shex)")"$,;
		fprint	fout,"ldbiu	r0,0x"$(shex)$,;

		val_done=true;
	}
	procedure	do_blk_mcoc_math_unary
	{
		var		cmp;
		macro	opr;
		macro	mne;
		macro	nval;

		while (true)
		{
			fget_xml;
			macro	cxml=$(fget_xml);
			pindex	cmp=$(cxml),"^</block[ >]";
			if (cmp<=0)
			{
				pindex	cmp=$(cxml),"^<next[ >]";
			}
			if (cmp>0)
			{
				break;
			}

			pindex	cmp=$(cxml),"^<[^/]";
			if (cmp>0)
			{
				static : analyze_xml	$(cxml);
				macro	dxml=$(_xml_);
				do_$(dxml);
				strcmp	cmp=$(dxml),"field";
				if (cmp=0)
				{
					mlet	opr=$(do_$(dxml));
				}
				strcmp	cmp=$(dxml),"value";
				if (cmp=0)
				{
					mlet	nval=$(do_$(dxml));
				}
			}
		}

		// operator
		mlet	mne="xxx";
		strcmp	cmp=$(opr),"-";
		if (cmp=0)
		{
			mlet	mne="neg";
		}
		strcmp	cmp=$(opr),"~";
		if (cmp=0)
		{
			mlet	mne=$(str_not);
		}
		strcmp	cmp=$(opr),"!";
		if (cmp)
		{
			strcmp	cmp=$(opr),"!!";
		}
		if (cmp=0)
		{
			mlet	mne="eori";
		}
		strcmp	cmp=$(opr),"sq";
		if (cmp=0)
		{
			mlet	mne="muls";
		}
		strcmp	cmp=$(opr),"1+";
		if (cmp=0)
		{
			mlet	mne="addi";
		}
		strcmp	cmp=$(opr),"-1+";
		if (cmp=0)
		{
			mlet	mne="subi";
		}
		strcmp	cmp=$(opr),"2*";
		if (cmp=0)
		{
			mlet	mne="add";
		}
		strcmp	cmp=$(mne),"xxx";
		if (cmp=0)
		{
			// ERROR:
			errmsg	"mcoc_math_unary: unsupported operator ("$(opr)")";
			leave	stop_error;
		}

		// assembler
		fprint	fout,"// r0=("$(opr)" r0(="$(nval)"))"$,;
		strcmp	cmp=$(opr),"-";
		if (cmp)
		{
			strcmp	cmp=$(opr),"2*";
		}
		if (cmp=0)
		{
			if (opt_opr_typ=opt_int)
			{
				fprint	fout,$(mne)"	r0"$,;
			}
			else
			{
				fprint	fout,"f"$(mne)"	r0,r0"$,;
			}
		}
		strcmp	cmp=$(opr),"~";
		if (cmp=0)
		{
			fprint	fout,$(mne)"	r0"$,;
		}
		strcmp	cmp=$(opr),"!";
		if (cmp)
		{
			strcmp	cmp=$(opr),"!!";
		}
		if (cmp=0)
		{
			fprint	fout,"cmpi	r0,false"$,;
			fprint	fout,"beq	pcnt+2"$,;
			fprint	fout,"ldbiu	r0,true"$,;
			strcmp	cmp=$(opr),"!";
			if (cmp=0)
			{
				fprint	fout,$(mne)"	r0,true"$,;
			}
		}
		strcmp	cmp=$(opr),"sq";
		if (cmp=0)
		{
			if (opt_opr_typ=opt_int)
			{
				fprint	fout,$(mne)"	r0,r0"$,;
				opt_mul_need=true;
			}
			else
			{
				psub	"s$","",mne;
				fprint	fout,"f"$(mne)"	r0,r0"$,;
			}
		}
		strcmp	cmp=$(opr),"1+";
		if (cmp)
		{
			strcmp	cmp=$(opr),"-1+";
		}
		if (cmp=0)
		{
			if (opt_opr_typ=opt_int)
			{
				fprint	fout,$(mne)"	r0,1"$,;
			}
			else
			{
				psub	"i$","",mne;
				fprint	fout,"fld$(z)i	r1,1"$,;
				fprint	fout,"f"$(mne)"	r0,r1"$,;
			}
		}

		index	cmp=$(nval)," ";
		if (cmp>0)
		{
			mlet	nval="("$(nval)")";
		}
		mlet	do_blk_mcoc_math_unary=$(opr)" "$(nval);
	}
	procedure	do_blk_mcoc_math_number
	{
		var		cmp;
		macro	nval;

		while (true)
		{
			fget_xml;
			macro	cxml=$(fget_xml);
			pindex	cmp=$(cxml),"^</block[ >]";
			if (cmp<=0)
			{
				pindex	cmp=$(cxml),"^<next[ >]";
			}
			if (cmp>0)
			{
				break;
			}

			pindex	cmp=$(cxml),"^<[^/]";
			if (cmp>0)
			{
				static : analyze_xml	$(cxml);
				macro	dxml=$(_xml_);
				strcmp	cmp=$(dxml),"field";
				if (cmp=0)
				{
					fget_xml;
					mlet	nval=$(fget_xml);
					continue;
				}
				do_$(dxml);
			}
		}
		gsub	"&lt;","<",nval;
		mlet	do_blk_mcoc_math_number=$(nval);

		// assembler
		fprint	fout,"// r0="$(nval)$,;
		if (opt_opr_typ=opt_int)
		{
			fprint	fout,"ld$(z)i	r0,"$(nval)$,;
		}
		else
		{
			fprint	fout,"fld$(z)i	r0,"$(nval)$,;
		}

		val_done=true;
	}
	procedure	do_blk_mcoc_math_bit_operation
	{
		var		cmp;
		macro	opr;
		macro	lval;
		macro	rval;
		macro	mne;

		while (true)
		{
			fget_xml;
			macro	cxml=$(fget_xml);
			pindex	cmp=$(cxml),"^</block[ >]";
			if (cmp>0)
			{
				break;
			}

			pindex	cmp=$(cxml),"^<[^/]";
			if (cmp>0)
			{
				static : analyze_xml	$(cxml);
				macro	dxml=$(_xml_);
				nmacro	_xml_name;
				macro	dnam=$(_xml_name);
				do_$(dxml);
				strcmp	cmp=$(dxml),"field";
				if (cmp=0)
				{
					mlet	opr=$(do_$(dxml));
				}
				strcmp	cmp=$(dxml),"value";
				if (cmp=0)
				{
					strcmp	cmp=$(dnam),"data";
					if (cmp)
					{
						strcmp	cmp=$(dnam),"A";
					}
					if (cmp=0)
					{
						mlet	lval=$(do_$(dxml));

						// assembler
						fprint	fout,"push$(z)	r0"$,;
					}
					else
					{
						mlet	rval=$(do_$(dxml));

						// assembler
						fprint	fout,"// r1=r0(="$(rval)"); r0(="$(lval)")"$,;
						fprint	fout,"mov	r1,r0"$,;
						fprint	fout,"pop$(z)	r0"$,;
					}
				}
			}
		}

		// operator
		gsub	"&lt;","<",opr;
		tolower		opr;
		mlet	mne="xxx";
		strcmp	cmp=$(opr),"&";
		if (cmp=0)
		{
			mlet	opr="&";
			mlet	mne=$(str_and);
		}
		strcmp	cmp=$(opr),"|";
		if (cmp=0)
		{
			mlet	mne=$(str_or);
		}
		strcmp	cmp=$(opr),"<<";
		if (cmp=0)
		{
			mlet	opr="<<";
			mlet	mne="asft";
		}
		strcmp	cmp=$(opr),">>";
		if (cmp=0)
		{
			mlet	opr=">>";
			mlet	mne="asft";
		}
		strcmp	cmp=$(opr),"^";
		if (cmp=0)
		{
			mlet	mne="eor";
		}

		// error check
		strcmp	cmp=$(mne),"xxx";
		if (cmp=0)
		{
			// ERROR:
			errmsg	"mcoc_math_bit_operation: unsupported operator ("$(opr)")";
			leave	stop_error;
		}

		// assembler
		fprint	fout,"// r0(="$(lval)") "$(opr)" r1(="$(rval)")"$,;
		strcmp	cmp=$(opr),">>";
		if (cmp=0)
		{
			fprint	fout,"neg	r1"$,;
		}
		fprint	fout,$(mne)"	r0,r1"$,;

		index	cmp=$(lval)," ";
		if (cmp>0)
		{
			mlet	lval="("$(lval)")";
		}
		index	cmp=$(rval)," ";
		if (cmp>0)
		{
			mlet	rval="("$(rval)")";
		}
		mlet	do_blk_mcoc_math_bit_operation=$(lval)" "$(opr)" "$(rval);
	}
	procedure	do_blk_mcoc_pack
	{
		var		cmp;
		var		stat;
		var		cnts;
		macro	enbl;

		while (true)
		{
			fget_xml;
			macro	cxml=$(fget_xml);
			if (stat=0)
			{
				pindex	cmp=$(cxml),"^<statement[ >]";
				if (cmp<=0)
				{
					pindex	cmp=$(cxml),"^<next[ >]";
				}
				if (cmp<=0)
				{
					pindex	cmp=$(cxml),"^</block[ >]";
				}
				if (cmp>0)
				{
					// continue
					pindex	cmp=$(cxml),"^<statement[ >]";
					if (cmp>0)
					{
						// pack
						strcmp	cmp=$(enbl),"true";
						if (cmp=0)
						{
							stat=1;
						}
						else
						{
							stat=3;
						}
						continue;
					}
					else
					{
						// empty block
						stat=2;
						mlet	enbl="false";
					}
				}
			}
			if (stat=1 | stat=3)
			{
				// pack block
				pindex	cmp=$(cxml),"^</statement[ >]";
				if (cmp>0)
				{
					// end of statement
					if (cnts>0)
					{
						cnts=cnts - 1;
						continue;
					}

					// end of pack
					stat=2;
					continue;
				}
				if (stat=3)
				{
					// disabled pack
					pindex	cmp=$(cxml),"^<statement[ >]";
					if (cmp>0)
					{
						cnts=cnts + 1;
						continue;
					}
					continue;
				}
			}
			if (stat=2)
			{
				pindex	cmp=$(cxml),"^<next[ >]";
				if (cmp<=0)
				{
					pindex	cmp=$(cxml),"^</block[ >]";
				}
				if (cmp>0)
				{
					// end of pack
					break;
				}
			}

			pindex	cmp=$(cxml),"^<[^/]";
			if (cmp>0)
			{
				static : analyze_xml	$(cxml);
				macro	dxml=$(_xml_);
				do_$(dxml);
				if (stat=0)
				{
					strcmp	cmp=$(dxml),"field";
					if (cmp=0)
					{
						mlet	enbl=$(do_$(dxml));
						tolower		enbl;
					}
				}
			}
		}
	}
	procedure	do_blk_mcoc_swap
	{
		var		cmp;
		macro	vnam1;
		macro	vnam2;

		while (true)
		{
			fget_xml;
			macro	cxml=$(fget_xml);
			pindex	cmp=$(cxml),"^</block[ >]";
			if (cmp<=0)
			{
				pindex	cmp=$(cxml),"^<next[ >]";
			}
			if (cmp>0)
			{
				break;
			}

			pindex	cmp=$(cxml),"^<[^/]";
			if (cmp>0)
			{
				static : analyze_xml	$(cxml);
				macro	dxml=$(_xml_);
				nmacro	_xml_name;
				macro	dnam=$(_xml_name);
				do_$(dxml);
				strcmp	cmp=$(dxml),"field";
				if (cmp=0)
				{
					strcmp	cmp=$(dnam),"A";
					if (cmp=0)
					{
						mlet	vnam1=$(do_$(dxml));
					}
					else
					{
						mlet	vnam2=$(do_$(dxml));
					}
				}
			}
		}

		// check
		is_cstr		$(vnam1);
		var		vnam1_cstr=is_cstr;
		is_cstr		$(vnam2);
		var		vnam2_cstr=is_cstr;
		if (@(vnam1_cstr ^ vnam2_cstr))
		{
			// ERROR:
			errmsg	"mcoc_swap: swap number and string variables"
					$,"	"$(vnam1)" and "$(vnam2);
			leave	stop_error;
		}

		// assembler
		fprint	fout,"// swap "$(vnam1)" and "$(vnam2)$,;
		asm_ld_var_adr	"r0",$(vnam1);
		asm_ld_var_adr	"r1",$(vnam2);
		fprint	fout,"ld$(z)	r2,[r0]"$,;
		fprint	fout,"ld$(z)	r3,[r1]"$,;
		fprint	fout,"st$(z)	[r0],r3"$,;
		fprint	fout,"st$(z)	[r1],r2"$,;
	}
	procedure	do_blk_mcoc_task
	{
		var		cmp;
		var		stat;
		macro	tskf;

		// assembler
		if (defp_1st)
		{
			defp_1st=false;
			fprint	fout,""$,;
			fprint	fout,"// halt"$,;
			fprint	fout,"jmpr7	_rtlb_prog_halt"$,;
		}

		while (true)
		{
			fget_xml;
			macro	cxml=$(fget_xml);
			if (stat=0)
			{
				pindex	cmp=$(cxml),"^<statement[ >]";
				if (cmp<=0)
				{
					pindex	cmp=$(cxml),"^<next[ >]";
				}
				if (cmp<=0)
				{
					pindex	cmp=$(cxml),"^</block[ >]";
				}
				if (cmp>0)
				{
					// continue
					pindex	cmp=$(cxml),"^<statement[ >]";
					if (cmp>0)
					{
						// task
						stat=1;

						// assembler
						fprint	fout,""$,;
						fprint	fout,"// task"$,;
						fprint	fout,"_rtlb_task_"$(tskf)":"$,;

						continue;
					}
					else
					{
						// empty block
						stat=2;
					}
				}
			}
			if (stat=1)
			{
				// task block
				pindex	cmp=$(cxml),"^</statement[ >]";
				if (cmp>0)
				{
					// end of statement

					// assembler
					fprint	fout,"// end of task"$,;
					fprint	fout,"rtn$(z)"$,;

					// end of task
					stat=2;
					continue;
				}
			}
			if (stat=2)
			{
				pindex	cmp=$(cxml),"^<next[ >]";
				if (cmp<=0)
				{
					pindex	cmp=$(cxml),"^</block[ >]";
				}
				if (cmp>0)
				{
					// end of task
					break;
				}
			}

			pindex	cmp=$(cxml),"^<[^/]";
			if (cmp>0)
			{
				static : analyze_xml	$(cxml);
				macro	dxml=$(_xml_);
				do_$(dxml);
				if (stat=0)
				{
					strcmp	cmp=$(dxml),"field";
					if (cmp=0)
					{
						mlet	tskf=$(do_$(dxml));
						tolower		tskf;
						if (tsk_def_$(tskf))
						{
							// ERROR:
							errmsg	"mcoc_task: re-defined task "$(tskf);
							leave	stop_error;
						}
						tsk_def_$(tskf)=true;
					}
				}
			}
		}
	}
	procedure	do_blk_mcoc_text_itoa
	{
		var		cmp;
		macro	nval;

		if (!in_var_set)
		{
			register_vars	"_tmp_str";
			register_cstr	"_tmp_str";

			// assembler
			asm_ld_var	"r0","_tmp_str";
			fprint	fout,"push$(z) r0"$,;
		}

		while (true)
		{
			var		in_var_set=true;

			fget_xml;
			macro	cxml=$(fget_xml);
			pindex	cmp=$(cxml),"^</block[ >]";
			if (cmp>0)
			{
				break;
			}

			pindex	cmp=$(cxml),"^<[^/]";
			if (cmp>0)
			{
				static : analyze_xml	$(cxml);
				macro	dxml=$(_xml_);
				do_$(dxml);
				strcmp	cmp=$(dxml),"value";
				if (cmp=0)
				{
					mlet	nval=$(do_$(dxml));
				}
			}
		}
		mlet	do_blk_mcoc_text_itoa="'"$(nval)"'";

		// assembler
		fprint	fout,"// r1=r0(="$(nval)")"$,;
		fprint	fout,"mov	r1,r0"$,;
		fprint	fout,"// r0=strdec (r0,r1(="$(nval)"))"$,;
		fprint	fout,"pop$(z)	r0"$,;
		fprint	fout,"jal$(z)r7	_strdec_r0_r1"$,;
		fprint	fout,"push$(z)	r0"$,;
		if (!in_var_set)
		{
			asm_ld_var	"r1","_tmp_str";
			fprint	fout,"pop$(z) r0	// discard"$,;
		}
	}
	procedure	do_blk_mcoc_text_itox
	{
		var		cmp;
		macro	nval;
		macro	ndig;

		if (!in_var_set)
		{
			register_vars	"_tmp_str";
			register_cstr	"_tmp_str";

			// assembler
			asm_ld_var	"r0","_tmp_str";
		}

		while (true)
		{
			var		in_var_set=true;

			fget_xml;
			macro	cxml=$(fget_xml);
			pindex	cmp=$(cxml),"^</block[ >]";
			if (cmp>0)
			{
				break;
			}

			pindex	cmp=$(cxml),"^<[^/]";
			if (cmp>0)
			{
				static : analyze_xml	$(cxml);
				macro	dxml=$(_xml_);
				do_$(dxml);
				strcmp	cmp=$(dxml),"field";
				if (cmp=0)
				{
					mlet	ndig=$(do_$(dxml));

					// assembler
					fprint	fout,"// r2="$(ndig)$,;
					fprint	fout,"ld$(z)i	r2,"$(ndig)$,;
				}
				strcmp	cmp=$(dxml),"value";
				if (cmp=0)
				{
					mlet	nval=$(do_$(dxml));
				}
			}
		}
		mlet	do_blk_mcoc_text_itox="'"$(nval)"'";

		// assembler
		fprint	fout,"// r1=r0(="$(nval)")"$,;
		fprint	fout,"mov	r1,r0"$,;
		fprint	fout,"// r0=strhex (r0,r1(="$(nval)"),r2(="$(ndig)"))"$,;
		fprint	fout,"pop$(z)	r0"$,;
		fprint	fout,"jal$(z)r7	_strhex_r0_r1_r2"$,;
		fprint	fout,"push$(z)	r0"$,;
		if (!in_var_set)
		{
			asm_ld_var	"r1","_tmp_str";
			fprint	fout,"pop$(z) r0	// discard"$,;
		}
	}
	procedure	do_blk_mcoc_text_atoi
	{
		var		cmp;
		macro	cstr;

		while (true)
		{
			fget_xml;
			macro	cxml=$(fget_xml);
			pindex	cmp=$(cxml),"^</block[ >]";
			if (cmp>0)
			{
				break;
			}

			pindex	cmp=$(cxml),"^<[^/]";
			if (cmp>0)
			{
				static : analyze_xml	$(cxml);
				macro	dxml=$(_xml_);
				do_$(dxml);
				strcmp	cmp=$(dxml),"value";
				if (cmp=0)
				{
					mlet	cstr=$(do_$(dxml));
				}
			}
		}
		mlet	do_blk_mcoc_text_atoi="atoi ("$(cstr)")";

		// assembler
		fprint	fout,"// r0=atoi (r1(="$(cstr)"))"$,;
		fprint	fout,"jal$(z)r7	_atoi_r1"$,;
	}
	procedure	do_blk_mcoc_text_xtoi
	{
		var		cmp;
		macro	cstr;

		while (true)
		{
			fget_xml;
			macro	cxml=$(fget_xml);
			pindex	cmp=$(cxml),"^</block[ >]";
			if (cmp>0)
			{
				break;
			}

			pindex	cmp=$(cxml),"^<[^/]";
			if (cmp>0)
			{
				static : analyze_xml	$(cxml);
				macro	dxml=$(_xml_);
				do_$(dxml);
				strcmp	cmp=$(dxml),"value";
				if (cmp=0)
				{
					mlet	cstr=$(do_$(dxml));
				}
			}
		}
		mlet	do_blk_mcoc_text_xtoi="xtoi ("$(cstr)")";

		// assembler
		fprint	fout,"// r0=xtoi (r1(="$(cstr)"))"$,;
		fprint	fout,"jal$(z)r7	_xtoi_r1"$,;
	}
	procedure	do_blk_mcoc_string_compare_left
	{
		var		cmp;
		macro	vstr;
		macro	ofst;
		macro	cstr;

		while (true)
		{
			fget_xml;
			macro	cxml=$(fget_xml);
			pindex	cmp=$(cxml),"^</block[ >]";
			if (cmp>0)
			{
				break;
			}

			pindex	cmp=$(cxml),"^<[^/]";
			if (cmp>0)
			{
				static : analyze_xml	$(cxml);
				macro	dxml=$(_xml_);
				nmacro	_xml_name;
				macro	dnam=$(_xml_name);
				do_$(dxml);
				strcmp	cmp=$(dxml),"field";
				if (cmp=0)
				{
					mlet	vstr=$(do_$(dxml));
					is_cstr		$(vstr);
					if (!is_cstr)
					{
						// ERROR:
						errmsg	"mcoc_string_compare_left: "
								"not a string variable ("$(vstr)")";
						leave	stop_error;
					}
				}
				strcmp	cmp=$(dxml),"value";
				if (cmp=0)
				{
					strcmp	cmp=$(dnam),"OFST";
					if (cmp=0)
					{
						mlet	ofst=$(do_$(dxml));

						// assembler
						fprint	fout,"push$(z)	r0"$,;
					}
					else
					{
						mlet	cstr=$(do_$(dxml));
					}
				}
			}
		}
		mlet	do_blk_mcoc_string_compare_left="left ("$(vstr)" + "
				$(ofst)")="$(cstr);

		// assembler
		fprint	fout,"// r3=r1(="$(cstr)")"$,;
		fprint	fout,"mov	r3,r1"$,;
		asm_ld_var	"r1",$(vstr);
		fprint	fout,"// r1(="$(vstr)") += r0(="$(ofst)")"$,;
		fprint	fout,"pop$(z)	r0"$,;
		fprint	fout,"jal$(z)r7	_strofst_r1_r0"$,;
		fprint	fout,"// r2=r3(="$(cstr)")"$,;
		fprint	fout,"mov	r2,r3"$,;
		fprint	fout,"// compare left (r1(="$(vstr)" + "$(ofst)")) = r2(="
				$(cstr)")"$,;
		fprint	fout,"jal$(z)r7	_strfcmp_r1_r2"$,;
		fprint	fout,"cmpi	r0,0"$,;
		fprint	fout,"ldbiu	r0,true"$,;
		fprint	fout,"beq	pcnt+2"$,;
		fprint	fout,"ldbiu	r0,false"$,;
	}
	procedure	do_blk_mcoc_string_ctoa
	{
		var		cmp;
		macro	cchr;

		if (!in_var_set)
		{
			register_vars	"_tmp_str";
			register_cstr	"_tmp_str";

			// assembler
			asm_ld_var	"r0","_tmp_str";
			fprint	fout,"push$(z) r0"$,;
		}

		while (true)
		{
			var		in_var_set=true;

			fget_xml;
			macro	cxml=$(fget_xml);
			pindex	cmp=$(cxml),"^</block[ >]";
			if (cmp>0)
			{
				break;
			}

			pindex	cmp=$(cxml),"^<[^/]";
			if (cmp>0)
			{
				static : analyze_xml	$(cxml);
				macro	dxml=$(_xml_);
				do_$(dxml);
				strcmp	cmp=$(dxml),"value";
				if (cmp=0)
				{
					mlet	cchr=$(do_$(dxml));
				}
			}
		}
		mlet	do_blk_mcoc_string_ctoa="'"$(cchr)"'";

		// assembler
		fprint	fout,"// r1=r0(="$(cchr)")"$,;
		fprint	fout,"mov	r1,r0"$,;
		fprint	fout,"pop$(z)	r0"$,;
		fprint	fout,"// [r0++]=r1(="$(cchr)") ++ '\0'"$,;
		fprint	fout,"stb	[r0],r1"$,;
		fprint	fout,"addi	r0,1"$,;
		fprint	fout,"ldbiu	r1,0"$,;
		fprint	fout,"stb	[r0],r1"$,;
		fprint	fout,"push$(z)	r0"$,;
		if (!in_var_set)
		{
			asm_ld_var	"r1","_tmp_str";
			fprint	fout,"pop$(z) r0	// discard"$,;
		}
	}
	procedure	do_blk_mcoc_string_find
	{
		var		cmp;
		macro	vstr;
		macro	ofst;
		macro	cchr;

		while (true)
		{
			fget_xml;
			macro	cxml=$(fget_xml);
			pindex	cmp=$(cxml),"^</block[ >]";
			if (cmp>0)
			{
				break;
			}

			pindex	cmp=$(cxml),"^<[^/]";
			if (cmp>0)
			{
				static : analyze_xml	$(cxml);
				macro	dxml=$(_xml_);
				nmacro	_xml_name;
				macro	dnam=$(_xml_name);
				do_$(dxml);
				strcmp	cmp=$(dxml),"field";
				if (cmp=0)
				{
					mlet	vstr=$(do_$(dxml));
					is_cstr		$(vstr);
					if (!is_cstr)
					{
						// ERROR:
						errmsg	"mcoc_string_find: "
								"not a string variable ("$(vstr)")";
						leave	stop_error;
					}
				}
				strcmp	cmp=$(dxml),"value";
				if (cmp=0)
				{
					strcmp	cmp=$(dnam),"OFST";
					if (cmp=0)
					{
						mlet	ofst=$(do_$(dxml));

						// assembler
						fprint	fout,"push$(z)	r0"$,;
					}
					else
					{
						mlet	cchr=$(do_$(dxml));
					}
				}
			}
		}
		mlet	do_blk_mcoc_string_find="strchr ("$(vstr)" + "$(ofst)","
				$(cchr)")";

		// assembler
		fprint	fout,"// r3=r0(="$(cchr)"), r0="$(ofst)$,;
		fprint	fout,"mov	r3,r0"$,;
		fprint	fout,"pop$(z)	r0"$,;
		asm_ld_var	"r1",$(vstr);
		fprint	fout,"// r4=r1(="$(vstr)")"$,;
		fprint	fout,"mov	r4,r1"$,;
		fprint	fout,"// r1(="$(vstr)") += r0(="$(ofst)")"$,;
		fprint	fout,"jal$(z)r7	_strofst_r1_r0"$,;
		fprint	fout,"// r0=r1(="$(vstr)" + "$(ofst)")"$,;
		fprint	fout,"mov	r0,r1"$,;
		fprint	fout,"// r4=r1(="$(vstr)" + "$(ofst)") - r4(="$(vstr)")"$,;
		fprint	fout,"sub	r1,r4"$,;
		fprint	fout,"mov	r4,r1"$,;
		fprint	fout,"// r1=r3(="$(cchr)")"$,;
		fprint	fout,"mov	r1,r3"$,;
		fprint	fout,"// find in r0(="$(vstr)" + "$(ofst)"), r1(="$(cchr)")"$,;
		fprint	fout,"jal$(z)r7	_strchr_r0_r1"$,;
		fprint	fout,"// r0 += r4(=offset from "$(vstr)")"$,;
		fprint	fout,"cmpi	r0,0"$,;
		fprint	fout,"blt	pcnt+2"$,;
		fprint	fout,"add	r0,r4"$,;
	}
	procedure	do_blk_mcoc_string_get_char
	{
		var		cmp;
		macro	vstr;
		macro	ofst;

		while (true)
		{
			fget_xml;
			macro	cxml=$(fget_xml);
			pindex	cmp=$(cxml),"^</block[ >]";
			if (cmp>0)
			{
				break;
			}

			pindex	cmp=$(cxml),"^<[^/]";
			if (cmp>0)
			{
				static : analyze_xml	$(cxml);
				macro	dxml=$(_xml_);
				do_$(dxml);
				strcmp	cmp=$(dxml),"field";
				if (cmp=0)
				{
					mlet	vstr=$(do_$(dxml));
					is_cstr		$(vstr);
					if (!is_cstr)
					{
						// ERROR:
						errmsg	"mcoc_string_get_char: "
								"not a string variable ("$(vstr)")";
						leave	stop_error;
					}
				}
				strcmp	cmp=$(dxml),"value";
				if (cmp=0)
				{
					mlet	ofst=$(do_$(dxml));
				}
			}
		}
		mlet	do_blk_mcoc_string_get_char="["$(vstr)" + "$(ofst)"]";

		// assembler
		asm_ld_var	"r1",$(vstr);
		fprint	fout,"// r1(="$(vstr)") += r0(="$(ofst)")"$,;
		fprint	fout,"jal$(z)r7	_strofst_r1_r0"$,;
		fprint	fout,"// get char r0=[r1(="$(vstr)" + "$(ofst)")]"$,;
		fprint	fout,"ldb	r0,[r1]"$,;
	}
	procedure	do_blk_mcoc_string_label
	{
		var		cmp;
		macro	lnam;
		macro	ofst;

		while (true)
		{
			fget_xml;
			macro	cxml=$(fget_xml);
			pindex	cmp=$(cxml),"^</block[ >]";
			if (cmp>0)
			{
				break;
			}

			pindex	cmp=$(cxml),"^<[^/]";
			if (cmp>0)
			{
				static : analyze_xml	$(cxml);
				macro	dxml=$(_xml_);
				do_$(dxml);
				strcmp	cmp=$(dxml),"field";
				if (cmp=0)
				{
					mlet	lnam=$(do_$(dxml));
				}
				strcmp	cmp=$(dxml),"value";
				if (cmp=0)
				{
					mlet	ofst=$(do_$(dxml));
				}
			}
		}
		mlet	do_blk_mcoc_string_label=$"$(lnam)" + "$(ofst)$";

		// assembler
		fprint	fout,"// r1="$(lnam)$,;
		fprint	fout,"ldwi	r1,"$(lnam)$,;
		fprint	fout,"// r1(="$(lnam)") += r0(="$(ofst)")"$,;
		fprint	fout,"jal$(z)r7	_strofst_r1_r0"$,;
	}
	procedure	do_blk_mcoc_string_pointer
	{
		var		cmp;
		macro	vstr;
		macro	ofst;

		while (true)
		{
			fget_xml;
			macro	cxml=$(fget_xml);
			pindex	cmp=$(cxml),"^</block[ >]";
			if (cmp>0)
			{
				break;
			}

			pindex	cmp=$(cxml),"^<[^/]";
			if (cmp>0)
			{
				static : analyze_xml	$(cxml);
				macro	dxml=$(_xml_);
				do_$(dxml);
				strcmp	cmp=$(dxml),"field";
				if (cmp=0)
				{
					mlet	vstr=$(do_$(dxml));
					is_cstr		$(vstr);
					if (!is_cstr)
					{
						// ERROR:
						errmsg	"mcoc_string_pointer: "
								"not a string variable ("$(vstr)")";
						leave	stop_error;
					}
				}
				strcmp	cmp=$(dxml),"value";
				if (cmp=0)
				{
					mlet	ofst=$(do_$(dxml));
				}
			}
		}
		mlet	do_blk_mcoc_string_pointer=$"$(vstr)" + "$(ofst)$";

		// assembler
		asm_ld_var	"r1",$(vstr);
		fprint	fout,"// r1(="$(vstr)") += r0(="$(ofst)")"$,;
		fprint	fout,"jal$(z)r7	_strofst_r1_r0"$,;
	}
	procedure	do_blk_mcoc_string_set
	{
		var		cmp;
		macro	vstr;
		macro	ofst;
		macro	cstr;

		in_var_set=true;
		while (true)
		{
			fget_xml;
			macro	cxml=$(fget_xml);
			pindex	cmp=$(cxml),"^</block[ >]";
			if (cmp<=0)
			{
				pindex	cmp=$(cxml),"^<next[ >]";
			}
			if (cmp>0)
			{
				break;
			}

			pindex	cmp=$(cxml),"^<[^/]";
			if (cmp>0)
			{
				static : analyze_xml	$(cxml);
				macro	dxml=$(_xml_);
				nmacro	_xml_name;
				macro	dnam=$(_xml_name);
				do_$(dxml);
				strcmp	cmp=$(dxml),"field";
				if (cmp=0)
				{
					mlet	vstr=$(do_$(dxml));
					is_cstr		$(vstr);
					if (!is_cstr)
					{
						// ERROR:
						errmsg	"mcoc_string_set: "
								"not a string variable ("$(vstr)")";
						leave	stop_error;
					}
				}
				strcmp	cmp=$(dxml),"value";
				if (cmp=0)
				{
					strcmp	cmp=$(dnam),"VAL";
					if (cmp=0)
					{
						mlet	ofst=$(do_$(dxml));

						// assembler
						asm_ld_var	"r1",$(vstr);
						fprint	fout,"// r1(="$(vstr)") += r0(="$(ofst)")"$,;
						fprint	fout,"jal$(z)r7	_strofst_r1_r0"$,;
						fprint	fout,"// r0=r1(="$(vstr)" + "$(ofst)")"$,;
						fprint	fout,"mov	r0,r1"$,;
						fprint	fout,"push$(z)	r0"$,;
					}
					else
					{
						mlet	cstr=$(do_$(dxml));
					}
				}
			}
		}
		in_var_set=false;

		// assembler
		fprint	fout,"// end of "$(vstr)" + "$(ofst)"="$(cstr)$,;

		// string variable = <string>
		strcmp	cmp=$(cstr),"'", left;
		if (cmp=0)
		{
			// already processed (number ==> string)

			// assembler
			fprint	fout,"pop$(z)	r0	// discard"$,;
		}
		else
		{
			strcmp	cmp=$(cstr)," ++ ",left;
			if (cmp=0)
			{
				// joined
				psub	"^ \+\+ ","",cstr;

				// assembler
				fprint	fout,"pop$(z)	r0	// discard"$,;
			}
			else
			{
				// not joined
				pindex	cmp=$(cstr),"^"$""[^"$""]*"$""$";
				if (cmp<=0)
				{
					// not a string constant
					is_cstr		$(cstr);
					if (is_cstr)
					{
						// string variable
						cmp=1;
					}
				}
				if (cmp>0)
				{
					// string constant or string variable

					// assembler
					fprint	fout,"pop$(z)	r0"$,;
					fprint	fout,"jal$(z)r7	_strcpy_r0_r1"$,;
				}
				else
				{
					// number

					// assembler
					fprint	fout,"// r1=r0(="$(cstr)")"$,;
					fprint	fout,"mov	r1,r0"$,;
					fprint	fout,"// r0=strdec (r0,r1(="$(cstr)"))"$,;
					fprint	fout,"pop$(z)	r0"$,;
					fprint	fout,"jal$(z)r7	_strdec_r0_r1"$,;
				}
			}
		}
	}
	procedure	do_blk_mcoc_sytm_delay
	{
		do_blk_delay_custom;
	}
	procedure	do_blk_mcoc_sytm_delay_us
	{
		do_blk_delayMicroseconds_custom;
	}
	procedure	do_blk_mcoc_sytm_delay_cyc
	{
		var		cmp;
		macro	nval;

		while (true)
		{
			fget_xml;
			macro	cxml=$(fget_xml);
			pindex	cmp=$(cxml),"^</block[ >]";
			if (cmp<=0)
			{
				pindex	cmp=$(cxml),"^<next[ >]";
			}
			if (cmp>0)
			{
				break;
			}

			pindex	cmp=$(cxml),"^<[^/]";
			if (cmp>0)
			{
				static : analyze_xml	$(cxml);
				macro	dxml=$(_xml_);
				do_$(dxml);
				strcmp	cmp=$(dxml),"value";
				if (cmp=0)
				{
					mlet	nval=$(do_$(dxml));
				}
			}
		}

		// assembler
		fprint	fout,"// delayTicks (r0(="$(nval)"))"$,;
		fprint	fout,"_delay_cyc_r0"$,;
	}
	procedure	do_blk_mcoc_sytm_ticks
	{
		// assembler
		fprint	fout,"// r0=ticks"$,;
		fprint	fout,"ldwi	r7,_rtlb_sytmtck$(z)"$,;
		fprint	fout,"ld$(z)	r0,[r7]"$,;

		skip_one	"block";
		mlet	do_blk_mcoc_sytm_ticks="ticks";
	}
	procedure	do_blk_mcoc_sytm_micros
	{
		do_blk_micros;
		mlet	do_blk_mcoc_sytm_micros=$(do_blk_micros);
	}
	procedure	do_blk_mcoc_sytm_millis
	{
		do_blk_millis;
		mlet	do_blk_mcoc_sytm_millis=$(do_blk_millis);
	}
	procedure	do_blk_mcoc_uart_print
	{
		do_blk_text_print;
	}
	procedure	do_blk_mcoc_uart_println
	{
		do_blk_text_print;

		// assembler
		fprint	fout,"// print CR+LF"$,;
		fprint	fout,"ldbiu	r0,asc_cr"$,;
		fprint	fout,"jal$(z)r7	_print_chr_r0"$,;
		fprint	fout,"ldbiu	r0,asc_lf"$,;
		fprint	fout,"jal$(z)r7	_print_chr_r0"$,;
	}
	procedure	do_blk_mcoc_uart_getline
	{
		var		cmp;

		if (!in_var_set)
		{
			register_vars	"_tmp_str";
			register_cstr	"_tmp_str";

			// assembler
			asm_ld_var	"r0","_tmp_str";
		}

		while (true)
		{
			var		in_var_set=true;

			fget_xml;
			macro	cxml=$(fget_xml);
			pindex	cmp=$(cxml),"^</block[ >]";
			if (cmp<=0)
			{
				pindex	cmp=$(cxml),"^<next[ >]";
			}
			if (cmp>0)
			{
				break;
			}

			pindex	cmp=$(cxml),"^<[^/]";
			if (cmp>0)
			{
				static : analyze_xml	$(cxml);
				macro	dxml=$(_xml_);
				do_$(dxml);
			}
		}
		mlet	do_blk_mcoc_uart_getline="'getline'";

		// assembler
		fprint	fout,"// r0,r1=getline (r0)"$,;
		fprint	fout,"jal$(z)r7	_getline_r0"$,;
	}
	procedure	do_blk_mcoc_uart_avail
	{
		var		cmp;

		while (true)
		{
			fget_xml;
			macro	cxml=$(fget_xml);
			pindex	cmp=$(cxml),"^</block[ >]";
			if (cmp<=0)
			{
				pindex	cmp=$(cxml),"^<next[ >]";
			}
			if (cmp>0)
			{
				break;
			}

			pindex	cmp=$(cxml),"^<[^/]";
			if (cmp>0)
			{
				static : analyze_xml	$(cxml);
				macro	dxml=$(_xml_);
				do_$(dxml);
			}
		}
		mlet	do_blk_mcoc_uart_avail="uart_avail";

		// assembler
		fprint	fout,"// r0=uart_avail"$,;
		fprint	fout,"ldwi	r7,uartctl"$,;
		fprint	fout,"ldw	r0,[r7]"$,;
		fprint	fout,"andi	r0,uart_ravl"$,;
		fprint	fout,"ldbiu	r0,true"$,;
		fprint	fout,"bne	pcnt+2"$,;
		fprint	fout,"ldbiu	r0,false"$,;
	}
	procedure	do_blk_mcoc_port_read
	{
		var		cmp;
		macro	npin;

		while (true)
		{
			fget_xml;
			macro	cxml=$(fget_xml);
			pindex	cmp=$(cxml),"^</block[ >]";
			if (cmp<=0)
			{
				pindex	cmp=$(cxml),"^<next[ >]";
			}
			if (cmp>0)
			{
				break;
			}

			pindex	cmp=$(cxml),"^<[^/]";
			if (cmp>0)
			{
				static : analyze_xml	$(cxml);
				macro	dxml=$(_xml_);
				do_$(dxml);
				strcmp	cmp=$(dxml),"value";
				if (cmp=0)
				{
					mlet	npin=$(do_$(dxml));
				}
			}
		}
		mlet	do_blk_mcoc_port_read="digitalRead ("$(npin)")";

		// assembler
		fprint	fout,"// r0=digitalRead (r0(="$(npin)"))"$,;
		fprint	fout,"jal$(z)r7	_digital_read_r0"$,;
	}
	procedure	do_blk_mcoc_port_write
	{
		var		cmp;
		macro	npin;
		macro	nval;

		while (true)
		{
			fget_xml;
			macro	cxml=$(fget_xml);
			pindex	cmp=$(cxml),"^</block[ >]";
			if (cmp<=0)
			{
				pindex	cmp=$(cxml),"^<next[ >]";
			}
			if (cmp>0)
			{
				break;
			}

			pindex	cmp=$(cxml),"^<[^/]";
			if (cmp>0)
			{
				static : analyze_xml	$(cxml);
				macro	dxml=$(_xml_);
				nmacro	_xml_name;
				macro	dnam=$(_xml_name);
				do_$(dxml);
				strcmp	cmp=$(dxml),"value";
				if (cmp=0)
				{
					strcmp	cmp=$(dnam),"PIN";
					if (cmp=0)
					{
						mlet	npin=$(do_$(dxml));

						// assembler
						fprint	fout,"push$(z)	r0"$,;
					}
					else
					{
						mlet	nval=$(do_$(dxml));

						// assembler
						fprint	fout,"// r1=r0(="$(nval)"); r0(="$(npin)")"$,;
						fprint	fout,"mov	r1,r0"$,;
						fprint	fout,"pop$(z)	r0"$,;
					}
				}
			}
		}

		// assembler
		fprint	fout,"// digitalWrite (r0(="$(npin)"), r1(="$(nval)"))"$,;
		fprint	fout,"jal$(z)r7	_digital_write_r0_r1"$,;
	}
	procedure	do_blk_serial_available
	{
		do_blk_mcoc_uart_avail;
		mlet	do_blk_serial_available=$(do_blk_mcoc_uart_avail);
	}
	procedure	do_blk_serial_read
	{
		var		cmp;

		while (true)
		{
			fget_xml;
			macro	cxml=$(fget_xml);
			pindex	cmp=$(cxml),"^</block[ >]";
			if (cmp<=0)
			{
				pindex	cmp=$(cxml),"^<next[ >]";
			}
			if (cmp>0)
			{
				break;
			}

			pindex	cmp=$(cxml),"^<[^/]";
			if (cmp>0)
			{
				static : analyze_xml	$(cxml);
				macro	dxml=$(_xml_);
				do_$(dxml);
			}
		}
		mlet	do_blk_serial_read="getbyte";

		// assembler
		labid=labid + 1;
		macro	slabid;
		num2str		slabid=labid,"%04x";
		fprint	fout,"// r0=getbyte"$,;
		fprint	fout,"ldwi	r7,uartctl"$,;
		fprint	fout,"ldw	r0,[r7]"$,;
		fprint	fout,"cmpi	r0,uart_ravl"$,;
		fprint	fout,"beq	_auto_"$(slabid)"_nodat"$,;
		fprint	fout,"// read byte"$,;
		fprint	fout,"ldwi	r7,uartrdat"$,;
		fprint	fout,"ldw	r0,[r7]"$,;
		fprint	fout,"bra	_auto_"$(slabid)"_endif"$,;
		fprint	fout,"_auto_"$(slabid)"_nodat:"$,;
		fprint	fout,"// no data available"$,;
		fprint	fout,"ld$(z)i	r0,-1"$,;
		fprint	fout,"_auto_"$(slabid)"_endif:"$,;
	}
	procedure	do_blk_serial_print
	{
		do_blk_text_print;
	}
	procedure	do_blk_serial_println
	{
		do_blk_mcoc_uart_println;
	}
	procedure	do_blk_inout_digital_read
	{
		var		cmp;
		macro	npin;

		while (true)
		{
			fget_xml;
			macro	cxml=$(fget_xml);
			pindex	cmp=$(cxml),"^</block[ >]";
			if (cmp>0)
			{
				break;
			}

			pindex	cmp=$(cxml),"^<[^/]";
			if (cmp>0)
			{
				static : analyze_xml	$(cxml);
				macro	dxml=$(_xml_);
				nmacro	_xml_name="";
				macro	dnam=$(_xml_name);
				do_$(dxml);
				strcmp	cmp=$(dxml),"field";
				if (cmp=0)
				{
					strcmp	cmp=$(dnam),"PIN";
					if (cmp=0)
					{
						mlet	npin=$(do_$(dxml));

						pindex	cmp=$(npin),"^[0-9.+-]";
						if (cmp>0)
						{
							// assembler
							fprint	fout,"// r0="$(npin)$,;
							fprint	fout,"ld$(z)i	r0,"$(npin)$,;
						}
					}
					strcmp	cmp=$(dnam),"INPUT_MODE";
					if (cmp=0)
					{
						// ignore
					}
				}
			}
		}
		mlet	do_blk_inout_digital_read="digitalRead ("$(npin)")";

		// assembler
		fprint	fout,"// digitalRead (r0(="$(npin)"))"$,;
		fprint	fout,"jal$(z)r7	_digital_read_r0"$,;
	}
	procedure	do_blk_inout_custom_digital_write
	{
		var		cmp;
		macro	npin;
		macro	nval;

		while (true)
		{
			fget_xml;
			macro	cxml=$(fget_xml);
			pindex	cmp=$(cxml),"^</block[ >]";
			if (cmp<=0)
			{
				pindex	cmp=$(cxml),"^<next[ >]";
			}
			if (cmp>0)
			{
				break;
			}

			pindex	cmp=$(cxml),"^<[^/]";
			if (cmp>0)
			{
				static : analyze_xml	$(cxml);
				macro	dxml=$(_xml_);
				nmacro	_xml_name="";
				macro	dnam=$(_xml_name);
				do_$(dxml);
				strcmp	cmp=$(dxml),"value";
				if (cmp=0)
				{
					strcmp	cmp=$(dnam),"PIN";
					if (cmp=0)
					{
						mlet	npin=$(do_$(dxml));

						// assembler
						fprint	fout,"push$(z)	r0"$,;
					}
					strcmp	cmp=$(dnam),"STAT";
					if (cmp=0)
					{
						mlet	nval=$(do_$(dxml));

						pindex	cmp=$(nval),"^[0-9.+-]";
						if (cmp>0)
						{
							// assembler
							fprint	fout,"// r0="$(nval)$,;
							fprint	fout,"ld$(z)i	r0,"$(nval)$,;
						}
					}
				}
			}
		}

		// assembler
		fprint	fout,"// r1=r0(="$(nval)"); r0(="$(npin)")"$,;
		fprint	fout,"mov	r1,r0"$,;
		fprint	fout,"pop$(z)	r0"$,;
		fprint	fout,"// digitalWrite (r0(="$(npin)"), r1(="$(nval)"))"$,;
		fprint	fout,"jal$(z)r7	_digital_write_r0_r1"$,;
	}
	procedure	do_blk_inout_digital_write
	{
		var		cmp;
		macro	npin;
		macro	nval;

		while (true)
		{
			fget_xml;
			macro	cxml=$(fget_xml);
			pindex	cmp=$(cxml),"^</block[ >]";
			if (cmp<=0)
			{
				pindex	cmp=$(cxml),"^<next[ >]";
			}
			if (cmp>0)
			{
				break;
			}

			pindex	cmp=$(cxml),"^<[^/]";
			if (cmp>0)
			{
				static : analyze_xml	$(cxml);
				macro	dxml=$(_xml_);
				nmacro	_xml_name="";
				macro	dnam=$(_xml_name);
				do_$(dxml);
				strcmp	cmp=$(dxml),"field";
				if (cmp=0)
				{
					strcmp	cmp=$(dnam),"PIN";
					if (cmp=0)
					{
						mlet	npin=$(do_$(dxml));

						pindex	cmp=$(npin),"^[0-9.+-]";
						if (cmp>0)
						{
							// assembler
							fprint	fout,"// r0="$(npin)$,;
							fprint	fout,"ld$(z)i	r0,"$(npin)$,;
						}

						// assembler
						fprint	fout,"push$(z)	r0"$,;
					}
					strcmp	cmp=$(dnam),"STAT";
					if (cmp=0)
					{
						var		nval;

						mlet	nval=$(do_$(dxml));

						// assembler
						strcmp	cmp=$(nval),"LOW";
						if (cmp=0)
						{
							nval=0;
						}
						else
						{
							nval=1;
						}
						fprint	fout,"// r0="$(nval)$,;
						fprint	fout,"ld$(z)i	r0,#"$,,nval;
					}
				}
			}
		}

		// assembler
		fprint	fout,"// r1=r0(="$(nval)"); r0(="$(npin)")"$,;
		fprint	fout,"mov	r1,r0"$,;
		fprint	fout,"pop$(z)	r0"$,;
		fprint	fout,"// digitalWrite (r0(="$(npin)"), r1(="$(nval)"))"$,;
		fprint	fout,"jal$(z)r7	_digital_write_r0_r1"$,;
	}
	procedure	do_blk_inout_digitalpin
	{
		var		cmp;
		macro	npin;

		while (true)
		{
			fget_xml;
			macro	cxml=$(fget_xml);
			pindex	cmp=$(cxml),"^</block[ >]";
			if (cmp<=0)
			{
				pindex	cmp=$(cxml),"^<next[ >]";
			}
			if (cmp>0)
			{
				break;
			}

			pindex	cmp=$(cxml),"^<[^/]";
			if (cmp>0)
			{
				static : analyze_xml	$(cxml);
				macro	dxml=$(_xml_);
				do_$(dxml);
				strcmp	cmp=$(dxml),"field";
				if (cmp=0)
				{
					mlet	npin=$(do_$(dxml));
				}
			}
		}
		mlet	do_blk_inout_digitalpin=$(npin);

		// assembler
		fprint	fout,"// r0="$(npin)$,;
		fprint	fout,"ld$(z)i	r0,"$(npin)$,;
	}
	procedure	do_blk_inout_highlow
	{
		var		cmp;
		macro	nval;

		while (true)
		{
			fget_xml;
			macro	cxml=$(fget_xml);
			pindex	cmp=$(cxml),"^</block[ >]";
			if (cmp<=0)
			{
				pindex	cmp=$(cxml),"^<next[ >]";
			}
			if (cmp>0)
			{
				break;
			}

			pindex	cmp=$(cxml),"^<[^/]";
			if (cmp>0)
			{
				static : analyze_xml	$(cxml);
				macro	dxml=$(_xml_);
				do_$(dxml);
				strcmp	cmp=$(dxml),"field";
				if (cmp=0)
				{
					mlet	nval=$(do_$(dxml));
				}
			}
		}
		mlet	do_blk_inout_highlow=$(nval);

		// assembler
		fprint	fout,"// r0="$(nval)$,;
		fprint	fout,"ld$(z)i	r0,"$(nval)$,;
	}
	procedure	do_blk_delay_custom
	{
		var		cmp;
		nvar	millis_times=1;			// uint16
		macro	nval;

		while (true)
		{
			fget_xml;
			macro	cxml=$(fget_xml);
			pindex	cmp=$(cxml),"^</block[ >]";
			if (cmp<=0)
			{
				pindex	cmp=$(cxml),"^<next[ >]";
			}
			if (cmp>0)
			{
				break;
			}

			pindex	cmp=$(cxml),"^<[^/]";
			if (cmp>0)
			{
				static : analyze_xml	$(cxml);
				macro	dxml=$(_xml_);
				do_$(dxml);
				strcmp	cmp=$(dxml),"value";
				if (cmp=0)
				{
					mlet	nval=$(do_$(dxml));
				}
			}
		}
		if (millis_times>1)
		{
			mlet	nval=$(nval)" * "#(millis_times);
		}

		// assembler
		fprint	fout,"// delay (r0(="$(nval)"))"$,;
		if (millis_times>1)
		{
			fprint	fout,"ldwi	r1,#"$,,millis_times;
			fprint	fout,"muls	r0,r1"$,;
			opt_mul_need=true;
		}
		fprint	fout,"jal$(z)r7	_delay_ms_r0"$,;
	}
	procedure	do_blk_delayMicroseconds_custom
	{
		var		cmp;
		macro	nval;

		while (true)
		{
			fget_xml;
			macro	cxml=$(fget_xml);
			pindex	cmp=$(cxml),"^</block[ >]";
			if (cmp<=0)
			{
				pindex	cmp=$(cxml),"^<next[ >]";
			}
			if (cmp>0)
			{
				break;
			}

			pindex	cmp=$(cxml),"^<[^/]";
			if (cmp>0)
			{
				static : analyze_xml	$(cxml);
				macro	dxml=$(_xml_);
				do_$(dxml);
				strcmp	cmp=$(dxml),"value";
				if (cmp=0)
				{
					mlet	nval=$(do_$(dxml));
				}
			}
		}

		// assembler
		fprint	fout,"// delayMicroseconds (r0(="$(nval)"))"$,;
		fprint	fout,"jal$(z)r7	_delay_us_r0"$,;
	}
	procedure	do_blk_millis
	{
		// assembler
		fprint	fout,"// r0=millis"$,;
		fprint	fout,"ldwi	r7,_rtlb_sytmmil$(z)"$,;
		fprint	fout,"ld$(z)	r0,[r7]"$,;

		skip_one	"block";
		mlet	do_blk_millis="millis";
	}
	procedure	do_blk_micros
	{
		// assembler
		fprint	fout,"// r0=micros"$,;
		fprint	fout,"ldwi	r7,_rtlb_sytmmcr$(z)"$,;
		fprint	fout,"ld$(z)	r0,[r7]"$,;

		skip_one	"block";
		mlet	do_blk_micros="micros";
	}
	procedure	do_blk_cast_number
	{
		var		cmp;
		nmacro	ctyp;
		macro	nval;

		while (true)
		{
			fget_xml;
			macro	cxml=$(fget_xml);
			pindex	cmp=$(cxml),"^</block[ >]";
			if (cmp>0)
			{
				break;
			}

			pindex	cmp=$(cxml),"^<[^/]";
			if (cmp>0)
			{
				static : analyze_xml	$(cxml);
				macro	dxml=$(_xml_);
				do_$(dxml);
				strcmp	cmp=$(dxml),"field";
				if (cmp=0)
				{
					mlet	ctyp=$(do_$(dxml));
					psub	"^\((.*)\)$","\1",ctyp;
				}
				strcmp	cmp=$(dxml),"value";
				if (cmp=0)
				{
					mlet	nval=$(do_$(dxml));
				}
			}
		}
		strcmp	cmp=$(ctyp),"int";
		if (cmp)
		{
			strcmp	cmp=$(ctyp),"float";
		}
		if (cmp)
		{
			// ERROR:
			errmsg	"cast_number: unsupported cast ("$(ctyp)")";
			leave	stop_error;
		}
		mlet	do_blk_cast_number=$(ctyp)" ("$(nval)")";

		// assembler
		strcmp	cmp=$(ctyp),"int";
		if (cmp=0)
		{
			fprint	fout,"// r0="$(ctyp)" (float r0(="$(nval)"))"$,;
			fprint	fout,"cmpi	r0,0"$,;
			fprint	fout,"ldbiu	r1,false	// 0 or positive"$,;
			fprint	fout,"bpl	pcnt+4"$,;
			fprint	fout,"ldbiu	r1,true	// negative"$,;
			fprint	fout,"fneg	r0,r0"$,;
			fprint	fout,"fuint	r0,r0"$,;
			fprint	fout,"cmpi	r1,false"$,;
			fprint	fout,"beq	pcnt+2"$,;
			fprint	fout,"neg	r0"$,;
			opt_fpu_need=true;
		}
		strcmp	cmp=$(ctyp),"float";
		if (cmp=0)
		{
			fprint	fout,"// r0="$(ctyp)" (int r0(="$(nval)"))"$,;
			fprint	fout,"cmpi	r0,0"$,;
			fprint	fout,"ldbiu	r1,false	// 0 or positive"$,;
			fprint	fout,"bpl	pcnt+4"$,;
			fprint	fout,"ldbiu	r1,true	// negative"$,;
			fprint	fout,"neg	r0"$,;
			fprint	fout,"fsngl	r0,r0"$,;
			fprint	fout,"cmpi	r1,false"$,;
			fprint	fout,"beq	pcnt+2"$,;
			fprint	fout,"fneg	r0,r0"$,;
			opt_fpu_need=true;
		}
	}
	procedure	do_blk_math_number
	{
		var		cmp;
		macro	nval;

		while (true)
		{
			fget_xml;
			macro	cxml=$(fget_xml);
			pindex	cmp=$(cxml),"^</block[ >]";
			if (cmp>0)
			{
				break;
			}

			pindex	cmp=$(cxml),"^<[^/]";
			if (cmp>0)
			{
				static : analyze_xml	$(cxml);
				macro	dxml=$(_xml_);
				do_$(dxml);
				mlet	nval=$(do_$(dxml));
			}
		}
		mlet	do_blk_math_number=$(nval);

		// assembler
		macro	fi;
		if (opt_opr_typ=opt_float)
		{
			mlet	fi="f";
		}
		fprint	fout,"// r0="$(nval)$,;
		fprint	fout,$(fi)"ld$(z)i	r0,"$(nval)$,;

		val_done=true;
	}
	procedure	do_blk_math_number_property
	{
		var		cmp;
		var		pdone;
		macro	prop;
		macro	nval;

		while (true)
		{
			fget_xml;
			macro	cxml=$(fget_xml);
			pindex	cmp=$(cxml),"^</block[ >]";
			if (cmp>0)
			{
				break;
			}

			pindex	cmp=$(cxml),"^<[^/]";
			if (cmp>0)
			{
				static : analyze_xml	$(cxml);
				macro	dxml=$(_xml_);
				do_$(dxml);
				strcmp	cmp=$(dxml),"field";
				if (cmp=0)
				{
					mlet	prop=$(do_$(dxml));
					tolower		prop;
				}
				strcmp	cmp=$(dxml),"value";
				if (cmp=0)
				{
					mlet	nval=$(do_$(dxml));
				}
			}
		}
		if (opt_opr_typ=opt_float)
		{
			// ERROR:
			errmsg	"math_number_property: does not support float type";
			leave	stop_error;
		}

		// assembler
		fprint	fout,"// "$(prop)" (r0(="$(nval)"))"$,;
		strcmp	cmp=$(prop),"even";
		if (cmp=0)
		{
			pdone=true;
			fprint	fout,"andi	r0,0x01"$,;
			fprint	fout,"eori	r0,0x01"$,;
		}
		strcmp	cmp=$(prop),"odd";
		if (cmp=0)
		{
			pdone=true;
			fprint	fout,"andi	r0,0x01"$,;
		}
		strcmp	cmp=$(prop),"positive";
		if (cmp=0)
		{
			pdone=true;
			fprint	fout,"cmpi	r0,1"$,;
			fprint	fout,"ldbiu	r0,false"$,;
			fprint	fout,"blt	pcnt+2"$,;
			fprint	fout,"ldbiu	r0,true"$,;
		}
		strcmp	cmp=$(prop),"negative";
		if (cmp=0)
		{
			pdone=true;
			fprint	fout,"cmpi	r0,0"$,;
			fprint	fout,"ldbiu	r0,true"$,;
			fprint	fout,"blt	pcnt+2"$,;
			fprint	fout,"ldbiu	r0,false"$,;
		}
		if (!pdone)
		{
			// ERROR:
			errmsg	"math_number_property: unsupported property ("$(prop)")"$,;
			leave	stop_error;
		}
		mlet	do_blk_math_number_property=$(prop)" ("$(nval)")";
	}
	procedure	do_blk_math_constrain
	{
		var		cmp;
		macro	nval;
		macro	nlow;
		macro	nhgh;

		while (true)
		{
			fget_xml;
			macro	cxml=$(fget_xml);
			pindex	cmp=$(cxml),"^</block[ >]";
			if (cmp>0)
			{
				break;
			}

			pindex	cmp=$(cxml),"^<[^/]";
			if (cmp>0)
			{
				static : analyze_xml	$(cxml);
				macro	dxml=$(_xml_);
				nmacro	_xml_name;
				macro	dnam=$(_xml_name);
				do_$(dxml);
				strcmp	cmp=$(dxml),"value";
				if (cmp=0)
				{
					strcmp	cmp=$(dnam),"VALUE";
					if (cmp=0)
					{
						mlet	nval=$(do_$(dxml));

						// assembler
						fprint	fout,"push$(z)	r0"$,;
					}
					strcmp	cmp=$(dnam),"LOW";
					if (cmp=0)
					{
						mlet	nlow=$(do_$(dxml));

						// assembler
						fprint	fout,"push$(z)	r0"$,;
					}
					strcmp	cmp=$(dnam),"HIGH";
					if (cmp=0)
					{
						mlet	nhgh=$(do_$(dxml));
					}
				}
			}
		}
		mlet	do_blk_math_constrain="clip ("$(nval)", "$(nlow)", "$(nhgh)")";

		// assembler
		macro	fi;
		if (opt_opr_typ=opt_float)
		{
			mlet	fi="f";
		}
		fprint	fout,"// r0=clip (r0(="$(nval)"), r1(="$(nlow)"), r2(="
				$(nhgh)"))"$,;
		fprint	fout,"mov	r2,r0"$,;
		fprint	fout,"pop$(z)	r1"$,;
		fprint	fout,"pop$(z)	r0"$,;
		fprint	fout,$(fi)"cmp	r0,r1"$,;
		fprint	fout,"bge	pcnt+2"$,;
		fprint	fout,"mov	r0,r1"$,;
		fprint	fout,$(fi)"cmp	r2,r0"$,;
		fprint	fout,"bge	pcnt+2"$,;
		fprint	fout,"mov	r0,r2"$,;
	}
	procedure	do_blk_math_change
	{
		var		cmp;
		nvar	vdec;
		macro	vnam;
		macro	nval;
		macro	opr;
		macro	mne;

		while (true)
		{
			fget_xml;
			macro	cxml=$(fget_xml);
			pindex	cmp=$(cxml),"^</block[ >]";
			if (cmp<=0)
			{
				pindex	cmp=$(cxml),"^<next[ >]";
			}
			if (cmp>0)
			{
				break;
			}

			pindex	cmp=$(cxml),"^<[^/]";
			if (cmp>0)
			{
				static : analyze_xml	$(cxml);
				macro	dxml=$(_xml_);
				do_$(dxml);
				strcmp	cmp=$(dxml),"field";
				if (cmp=0)
				{
					mlet	vnam=$(do_$(dxml));
				}
				strcmp	cmp=$(dxml),"block";
				if (cmp)
				{
					strcmp	cmp=$(dxml),"value";
				}
				if (cmp=0)
				{
					mlet	nval=$(do_$(dxml));
				}
			}
		}

		// assembler
		if (vdec)
		{
			mlet	opr="-";
			mlet	mne="sub";
		}
		else
		{
			mlet	opr="+";
			mlet	mne="add";
		}
		if (opt_opr_typ=opt_float)
		{
			mlet	mne="f"$(mne);
		}
		asm_ld_var	"r1",$(vnam), "r7";
		fprint	fout,"// r1(="$(vnam)") "$(opr)"= r0(="$(nval)")"$,;
		fprint	fout,$(mne)"	r1,r0"$,;
		fprint	fout,"st$(z)	[r7],r1"$,;
	}
	procedure	do_blk_math_constant
	{
		var		cmp;
		macro	nval;

		while (true)
		{
			fget_xml;
			macro	cxml=$(fget_xml);
			pindex	cmp=$(cxml),"^</block[ >]";
			if (cmp>0)
			{
				break;
			}

			pindex	cmp=$(cxml),"^<[^/]";
			if (cmp>0)
			{
				static : analyze_xml	$(cxml);
				macro	dxml=$(_xml_);
				do_$(dxml);
				mlet	nval=$(do_$(dxml));
			}
		}
		mlet	do_blk_math_constant=$(nval);

		// assembler
		fprint	fout,"// r0="$(nval)$,;
		fprint	fout,"ld$(z)i	r0,"$(nval)$,;
	}
	procedure	do_blk_math_modulo
	{
		var		cmp;
		macro	lval;
		macro	rval;

		while (true)
		{
			fget_xml;
			macro	cxml=$(fget_xml);
			pindex	cmp=$(cxml),"^</block[ >]";
			if (cmp>0)
			{
				break;
			}

			pindex	cmp=$(cxml),"^<[^/]";
			if (cmp>0)
			{
				static : analyze_xml	$(cxml);
				macro	dxml=$(_xml_);
				nmacro	_xml_name;
				macro	dnam=$(_xml_name);
				do_$(dxml);
				strcmp	cmp=$(dxml),"value";
				if (cmp=0)
				{
					strcmp	cmp=$(dnam),"DIVIDEND";
					if (cmp=0)
					{
						mlet	lval=$(do_$(dxml));

						// assembler
						fprint	fout,"push$(z)	r0"$,;
					}
					else
					{
						mlet	rval=$(do_$(dxml));

						// assembler
						fprint	fout,"// r1=r0(="$(rval)"); r0(="$(lval)")"$,;
						fprint	fout,"mov	r1,r0"$,;
						fprint	fout,"pop$(z)	r0"$,;
					}
				}
			}
		}

		// assembler
		fprint	fout,"// r0(="$(lval)") % r1(="$(rval)")"$,;
		if (opt_opr_typ=opt_int)
		{
			fprint	fout,"divsr	r0,r1"$,;
			opt_div_need=true;
		}
		else
		{
			fprint	fout,"// A%B=A - fdown (A/B)*B"$,;
			fprint	fout,"push$(z)	r0"$,;
			fprint	fout,"fdiv	r0,r1"$,;
			fprint	fout,"fdown	r2,r0"$,;
			fprint	fout,"fmul	r2,r1"$,;
			fprint	fout,"pop$(z)	r1"$,;
			fprint	fout,"fsub	r1,r2"$,;
		}
		fprint	fout,"// r2=r0(=quotient), r0=r1(=remainder)"$,;
		fprint	fout,"mov	r2,r0"$,;
		fprint	fout,"mov	r0,r1"$,;

		index	cmp=$(lval)," ";
		if (cmp>0)
		{
			mlet	lval="("$(lval)")";
		}
		index	cmp=$(rval)," ";
		if (cmp>0)
		{
			mlet	rval="("$(rval)")";
		}
		mlet	do_blk_math_modulo=$(lval)" % "$(rval);
	}
	procedure	do_blk_math_arithmetic
	{
		var		cmp;
		macro	opr;
		macro	lval;
		macro	rval;
		macro	mne;

		while (true)
		{
			fget_xml;
			macro	cxml=$(fget_xml);
			pindex	cmp=$(cxml),"^</block[ >]";
			if (cmp>0)
			{
				break;
			}

			pindex	cmp=$(cxml),"^<[^/]";
			if (cmp>0)
			{
				static : analyze_xml	$(cxml);
				macro	dxml=$(_xml_);
				nmacro	_xml_name;
				macro	dnam=$(_xml_name);
				do_$(dxml);
				strcmp	cmp=$(dxml),"field";
				if (cmp=0)
				{
					mlet	opr=$(do_$(dxml));
					tolower		opr;
				}
				strcmp	cmp=$(dxml),"value";
				if (cmp=0)
				{
					strcmp	cmp=$(dnam),"A";
					if (cmp)
					{
						strcmp	cmp=$(dnam),"VAR1";
					}
					if (cmp=0)
					{
						mlet	lval=$(do_$(dxml));

						// assembler
						fprint	fout,"push$(z)	r0"$,;
					}
					else
					{
						mlet	rval=$(do_$(dxml));

						// assembler
						fprint	fout,"// r1=r0(="$(rval)"); r0(="$(lval)")"$,;
						fprint	fout,"mov	r1,r0"$,;
						fprint	fout,"pop$(z)	r0"$,;
					}
				}
			}
		}

		// operator
		mlet	mne="xxx";
		strcmp	cmp=$(opr),"add";
		if (cmp)
		{
			strcmp	cmp=$(opr),"+";
		}
		if (cmp=0)
		{
			mlet	opr="+";
			mlet	mne="add";
		}
		strcmp	cmp=$(opr),"minus";
		if (cmp)
		{
			strcmp	cmp=$(opr),"-";
		}
		if (cmp=0)
		{
			mlet	opr="-";
			mlet	mne="sub";
		}
		strcmp	cmp=$(opr),"multiply";
		if (cmp)
		{
			strcmp	cmp=$(opr),"*";
		}
		if (cmp=0)
		{
			mlet	opr="*";
			mlet	mne="muls";
			if (opt_opr_typ=opt_int)
			{
				opt_mul_need=true;
			}
		}
		strcmp	cmp=$(opr),"divide";
		if (cmp)
		{
			strcmp	cmp=$(opr),"/";
		}
		if (cmp=0)
		{
			mlet	opr="/";
			mlet	mne="divs";
			if (opt_opr_typ=opt_int)
			{
				opt_div_need=true;
			}
		}
		strcmp	cmp=$(opr),"remainder";
		if (cmp)
		{
			strcmp	cmp=$(opr),"modulo";
		}
		if (cmp)
		{
			strcmp	cmp=$(opr),"%";
		}
		if (cmp=0)
		{
			mlet	opr="%";
			mlet	mne="divsr";
			opt_div_need=true;
		}
		strcmp	cmp=$(opr),$(str_and);
		if (cmp=0)
		{
			mlet	opr="&";
			mlet	mne=$(str_and);
		}
		strcmp	cmp=$(opr),$(str_or);
		if (cmp=0)
		{
			mlet	opr="|";
			mlet	mne=$(str_or);
		}
		strcmp	cmp=$(opr),"xor";
		if (cmp=0)
		{
			mlet	opr="^";
			mlet	mne="eor";
		}

		// error check
		strcmp	cmp=$(mne),"xxx";
		if (cmp=0)
		{
			// ERROR:
			errmsg	"math_arithmetic: unsupported operator ("$(opr)")";
			leave	stop_error;
		}
		// floating point operation
		if (opt_opr_typ=opt_float)
		{
			mlet	mne="f"$(mne);
			sub		"fmuls","fmul",mne;
			sub		"fdivs","fdiv",mne;
			index	cmp="_fadd_fsub_fmul_fdiv_","_"$(mne)"_";
			if (cmp<=0)
			{
				// ERROR:
				errmsg	"math_arithmetic: unsupported operator ("
						$(opr)") for float";
				leave	stop_error;
			}
		}

		// assembler
		fprint	fout,"// r0(="$(lval)") "$(opr)" r1(="$(rval)")"$,;
		strcmp	cmp=$(opr),"max";
		if (cmp=0)
		{
			// r0 max r1=(r0>=r1)? r1: r0 (PICAXE BASIC operator)
			mlet	mne="mov";

			// assembler
			fprint	fout,"cmp	r0,r1"$,;
			fprint	fout,"bge	pcnt+2"$,;
			fprint	fout,"mov	r1,r0"$,;
		}
		strcmp	cmp=$(opr),"min";
		if (cmp=0)
		{
			// r0 min r1=(r0<=r1)? r1: r0 (PICAXE BASIC operator)
			mlet	mne="mov";

			// assembler
			fprint	fout,"cmp	r1,r0"$,;
			fprint	fout,"bge	pcnt+2"$,;
			fprint	fout,"mov	r1,r0"$,;
		}
		fprint	fout,$(mne)"	r0,r1"$,;
		strcmp	cmp=$(opr),"%";
		if (cmp=0)
		{
			fprint	fout,"// r2=r0(=quotient), r0=r1(=remainder)"$,;
			fprint	fout,"mov	r2,r0"$,;
			fprint	fout,"mov	r0,r1"$,;
		}

		index	cmp=$(lval)," ";
		if (cmp>0)
		{
			mlet	lval="("$(lval)")";
		}
		index	cmp=$(rval)," ";
		if (cmp>0)
		{
			mlet	rval="("$(rval)")";
		}
		mlet	do_blk_math_arithmetic=$(lval)" "$(opr)" "$(rval);
	}
	procedure	do_blk_logic_boolean
	{
		var		cmp;
		macro	bval;
		
		while (true)
		{
			fget_xml;
			macro	cxml=$(fget_xml);
			pindex	cmp=$(cxml),"^</block[ >]";
			if (cmp>0)
			{
				break;
			}

			pindex	cmp=$(cxml),"^<[^/]";
			if (cmp>0)
			{
				static : analyze_xml	$(cxml);
				macro	dxml=$(_xml_);
				do_$(dxml);
				strcmp	cmp=$(dxml),"field";
				if (cmp=0)
				{
					mlet	bval=$(do_$(dxml));
					tolower		bval;
				}
			}
		}
		mlet	do_blk_logic_boolean=$(bval);

		// assembler
		fprint	fout,"// r0="$(bval)$,;
		fprint	fout,"ldbiu	r0,"$(bval)$,;
	}
	procedure	do_blk_logic_negate
	{
		var		cmp;
		macro	bval;
		
		while (true)
		{
			fget_xml;
			macro	cxml=$(fget_xml);
			pindex	cmp=$(cxml),"^</block[ >]";
			if (cmp>0)
			{
				break;
			}

			pindex	cmp=$(cxml),"^<[^/]";
			if (cmp>0)
			{
				static : analyze_xml	$(cxml);
				macro	dxml=$(_xml_);
				do_$(dxml);
				strcmp	cmp=$(dxml),"value";
				if (cmp=0)
				{
					mlet	bval=$(do_$(dxml));
				}
			}
		}

		// assembler
		fprint	fout,"// !r0(="$(bval)")"$,;
		fprint	fout,"cmpi	r0,false"$,;
		fprint	fout,"beq	pcnt+2"$,;
		fprint	fout,"ldbiu	r0,true"$,;
		fprint	fout,"eori	r0,true"$,;

		index	cmp=$(bval)," ";
		if (cmp>0)
		{
			mlet	bval="("$(bval)")";
		}
		mlet	do_blk_logic_negate="! "$(bval);
	}
	procedure	do_blk_logic_ternary
	{
		var		cmp;
		var		iblk;
		macro	iexp;
		macro	vthn;
		macro	vels;

		// assembler
		labid=labid + 1;
		macro	slabid;
		num2str		slabid=labid,"%04x";
		fprint	fout,""$,;
		fprint	fout,"// if test"$,;

		while (true)
		{
			fget_xml;
			macro	cxml=$(fget_xml);
			pindex	cmp=$(cxml),"^</block[ >]";
			if (cmp>0)
			{
				break;
			}

			pindex	cmp=$(cxml),"^<[^/]";
			if (cmp>0)
			{
				static : analyze_xml	$(cxml);
				macro	dxml=$(_xml_);
				nmacro	_xml_name;
				macro	dnam=$(_xml_name);
				do_$(dxml);
				strcmp	cmp=$(dxml),"value";
				if (cmp=0)
				{
					strcmp	cmp=$(dnam),"IF";
					if (cmp=0)
					{
						iblk=@(iblk | 0x01);
						mlet	iexp=$(do_$(dxml));

						// assembler
						fprint	fout,"// test ("$(iexp)")"$,;
						fprint	fout,"cmpi	r0,false"$,;
						fprint	fout,"beq	_auto_"$(slabid)"_else"$,;
						fprint	fout,""$,;
						fprint	fout,"// then"$,;
					}
					strcmp	cmp=$(dnam),"THEN";
					if (cmp=0)
					{
						iblk=@(iblk | 0x02);
						mlet	vthn=$(do_$(dxml));

						// assembler
						fprint	fout,"// then ("$(vthn)")"$,;
						fprint	fout,"bra	_auto_"$(slabid)"_endif"$,;
						fprint	fout,""$,;
						fprint	fout,"// else"$,;
						fprint	fout,"_auto_"$(slabid)"_else:"$,;
					}
					strcmp	cmp=$(dnam),"ELSE";
					if (cmp=0)
					{
						iblk=@(iblk | 0x04);
						mlet	vels=$(do_$(dxml));

						// assembler
						fprint	fout,""$,;
						fprint	fout,"// else ("$(vels)")"$,;
						fprint	fout,"_auto_"$(slabid)"_endif:"$,;
					}
				}
			}
		}
		if (iblk!=0x07)
		{
			// ERROR:
			errmsg "logic_ternary: inhibited empty block."$,;
			leave	stop_error;
		}
		index	cmp=$(vthn)," ";
		if (cmp>0)
		{
			mlet	vthn="("$(vthn)")";
		}
		index	cmp=$(vels)," ";
		if (cmp>0)
		{
			mlet	vels="("$(vels)")";
		}
		mlet	do_blk_logic_ternary="("$(iexp)")? "$(vthn)": "$(vels);

		// assembler
		fprint	fout,""$,;
		fprint	fout,"// end of test ("$(iexp)")? "$(vthn)": "$(vels)$,;
	}
	procedure	do_blk_logic_compare
	{
		var		cmp;
		var		is_cstr_cmp;
		macro	opr;
		macro	lval;
		macro	rval;
		macro	mne;

		while (true)
		{
			fget_xml;
			macro	cxml=$(fget_xml);
			pindex	cmp=$(cxml),"^</block[ >]";
			if (cmp>0)
			{
				break;
			}

			pindex	cmp=$(cxml),"^<[^/]";
			if (cmp>0)
			{
				static : analyze_xml	$(cxml);
				macro	dxml=$(_xml_);
				nmacro	_xml_name;
				macro	dnam=$(_xml_name);
				do_$(dxml);
				strcmp	cmp=$(dxml),"field";
				if (cmp=0)
				{
					mlet	opr=$(do_$(dxml));
					tolower		opr;
				}
				strcmp	cmp=$(dxml),"value";
				if (cmp=0)
				{
					strcmp	cmp=$(dnam),"A";
					if (cmp=0)
					{
						mlet	lval=$(do_$(dxml));
						// text compare?
						is_cstr		$(lval);
						if (!is_cstr)
						{
							// lval!=cstr_var
							strcmp	cmp=$(lval),$",left;
							if (cmp=0)
							{
								// lval=cstr_txt
								is_cstr=true;
							}
						}
						is_cstr_cmp=is_cstr_cmp + ( is_cstr!=0 );

						// assembler
						if (is_cstr)
						{
							fprint	fout,"push$(z)	r1"$,;
						}
						else
						{
							fprint	fout,"push$(z)	r0"$,;
						}
					}
					else
					{
						mlet	rval=$(do_$(dxml));
						// text compare?
						is_cstr		$(rval);
						if (!is_cstr)
						{
							// rval!=cstr_var
							strcmp	cmp=$(rval),$",left;
							if (cmp=0)
							{
								// rval=cstr_txt
								is_cstr=true;
							}
						}
						is_cstr_cmp=is_cstr_cmp + ( is_cstr!=0 )*2;

						// assembler
						if (is_cstr)
						{
							fprint	fout,"pop$(z)	r0"$,;
						}
						else
						{
							fprint	fout,"// r1=r0(="$(rval)"); r0(="
									$(lval)")"$,;
							fprint	fout,"mov	r1,r0"$,;
							fprint	fout,"pop$(z)	r0"$,;
						}
					}
				}
			}
		}

		// operator
		mlet	mne="xxx";
		strcmp	cmp=$(opr),"eq";
		if (cmp=0)
		{
			mlet	opr="==";
			mlet	mne="eq";
		}
		strcmp	cmp=$(opr),"neq";
		if (cmp=0)
		{
			mlet	opr="!=";
			mlet	mne="ne";
		}
		strcmp	cmp=$(opr),"gte";
		if (cmp=0)
		{
			mlet	opr=">=";
			mlet	mne="ge";
		}
		strcmp	cmp=$(opr),"lte";
		if (cmp=0)
		{
			mlet	opr="<=";
			mlet	mne="le";
		}
		strcmp	cmp=$(opr),"gt";
		if (cmp=0)
		{
			mlet	opr=">";
			mlet	mne="gt";
		}
		strcmp	cmp=$(opr),"lt";
		if (cmp=0)
		{
			mlet	opr="<";
			mlet	mne="lt";
		}
		mlet	do_blk_logic_compare=$(opr);

		// error check
		strcmp	cmp=$(mne),"xxx";
		if (cmp=0)
		{
			// ERROR:
			errmsg	"logic_compare: unsupported operator ("$(opr)")";
			leave	stop_error;
		}
		// text compare?
		if (is_cstr_cmp=1 | is_cstr_cmp=2)
		{
			// ERROR:
			errmsg	"logic_compare: illegal text compare ("
					$(lval)" "$(opr)" "$(rval)")";
			leave	stop_error;
		}

		// assembler
		fprint	fout,"// r0(="$(lval)") "$(opr)" r1(="$(rval)")";
		strcmp	cmp=$(opr),"==";
		if (cmp)
		{
			strcmp	cmp=$(opr),"!=";
		}
		if (cmp)
		{
			strcmp	cmp=$(opr),">=";
		}
		if (cmp)
		{
			strcmp	cmp=$(opr),"<";
		}
		if (cmp=0)
		{
			fprint	fout,""$,;
			if (is_cstr_cmp)
			{
				fprint	fout,"mov	r2,r1"$,;
				fprint	fout,"mov	r1,r0"$,;
				fprint	fout,"jal$(z)r7	_strcmp_r1_r2"$,;
				fprint	fout,"cmpi	r0,0"$,;
			}
			else
			{
				if (opt_opr_typ=opt_int)
				{
					fprint	fout,"cmp	r0,r1"$,;
				}
				else
				{
					fprint	fout,"fcmp	r0,r1"$,;
				}
			}
		}
		strcmp	cmp=$(opr),">";
		if (cmp=0)
		{
			mlet	opr="<";
			mlet	mne="lt";
			fprint	fout," ==> r1(="$(rval)") "$(opr)" r0(="$(lval)")"$,;
			if (is_cstr_cmp)
			{
				fprint	fout,"mov	r2,r0"$,;
				fprint	fout,"jal$(z)r7	_strcmp_r1_r2"$,;
				fprint	fout,"cmpi	r0,0"$,;
			}
			else
			{
				if (opt_opr_typ=opt_int)
				{
					fprint	fout,"cmp	r1,r0"$,;
				}
				else
				{
					fprint	fout,"fcmp	r1,r0"$,;
				}
			}
		}
		strcmp	cmp=$(opr),"<=";
		if (cmp=0)
		{
			mlet	opr=">=";
			mlet	mne="ge";
			fprint	fout," ==> r1(="$(rval)") "$(opr)" r0(="$(lval)")"$,;
			if (is_cstr_cmp)
			{
				fprint	fout,"mov	r2,r0"$,;
				fprint	fout,"jal$(z)r7	_strcmp_r1_r2"$,;
				fprint	fout,"cmpi	r0,0"$,;
			}
			else
			{
				if (opt_opr_typ=opt_int)
				{
					fprint	fout,"cmp	r1,r0"$,;
				}
				else
				{
					fprint	fout,"fcmp	r1,r0"$,;
				}
			}
		}
		fprint	fout,"ldbiu	r0,true"$,;
		fprint	fout,"b"$(mne)"	pcnt+2"$,;
		fprint	fout,"ldbiu	r0,false"$,;

		index	cmp=$(lval)," ";
		if (cmp>0)
		{
			mlet	lval="("$(lval)")";
		}
		index	cmp=$(rval)," ";
		if (cmp>0)
		{
			mlet	rval="("$(rval)")";
		}
		mlet	do_blk_logic_compare=$(lval)" "
				$(do_blk_logic_compare)" "$(rval);
	}
	procedure	do_blk_logic_operation
	{
		var		cmp;
		macro	opr;
		macro	lval;
		macro	rval;
		macro	mne;

		while (true)
		{
			fget_xml;
			macro	cxml=$(fget_xml);
			pindex	cmp=$(cxml),"^</block[ >]";
			if (cmp>0)
			{
				break;
			}

			pindex	cmp=$(cxml),"^<[^/]";
			if (cmp>0)
			{
				static : analyze_xml	$(cxml);
				macro	dxml=$(_xml_);
				nmacro	_xml_name;
				macro	dnam=$(_xml_name);
				do_$(dxml);
				strcmp	cmp=$(dxml),"field";
				if (cmp=0)
				{
					mlet	opr=$(do_$(dxml));
					tolower		opr;
				}
				strcmp	cmp=$(dxml),"value";
				if (cmp=0)
				{
					strcmp	cmp=$(dnam),"A";
					if (cmp=0)
					{
						mlet	lval=$(do_$(dxml));

						// assembler
						fprint	fout,"push$(z)	r0"$,;
					}
					else
					{
						mlet	rval=$(do_$(dxml));

						// assembler
						fprint	fout,"// r1=r0(="$(rval)"); r0(="$(lval)")"$,;
						fprint	fout,"mov	r1,r0"$,;
						fprint	fout,"pop$(z)	r0"$,;
					}
				}
			}
		}

		// operator
		mlet	mne="xxx";
		strcmp	cmp=$(opr),$(str_and);
		if (cmp=0)
		{
			mlet	mne=$(opr);
			mlet	opr="&&";
		}
		strcmp	cmp=$(opr),$(str_or);
		if (cmp=0)
		{
			mlet	mne=$(opr);
			mlet	opr="||";
		}

		// error check
		strcmp	cmp=$(mne),"xxx";
		if (cmp=0)
		{
			// ERROR:
			errmsg	"logic_operation: unsupported operator ("$(opr)")";
			leave	stop_error;
		}

		// assembler
		fprint	fout,"// r0(="$(lval)") "$(opr)" r1(="$(rval)")"$,;
		fprint	fout,$(mne)"	r0,r1"$,;

		index	cmp=$(lval)," ";
		if (cmp>0)
		{
			mlet	lval="("$(lval)")";
		}
		index	cmp=$(rval)," ";
		if (cmp>0)
		{
			mlet	rval="("$(rval)")";
		}
		mlet	do_blk_logic_operation=$(lval)" "$(opr)" "$(rval);
	}
	procedure	do_blk_text
	{
		var		cmp;
		macro	cstr;

		while (true)
		{
			fget_xml;
			macro	cxml=$(fget_xml);
			pindex	cmp=$(cxml),"^</block[ >]";
			if (cmp>0)
			{
				break;
			}

			pindex	cmp=$(cxml),"^<[^/]";
			if (cmp>0)
			{
				static : analyze_xml	$(cxml);
				macro	dxml=$(_xml_);
				do_$(dxml);
				strcmp	cmp=$(dxml),"field";
				if (cmp=0)
				{
					mlet	cstr=$(do_$(dxml));
				}
			}
		}
		gsub	"#","##",cstr;
		mlet	do_blk_text=$(cstr);
		strcmp	cmp=$(do_blk_text),$",left;
		if (cmp)
		{
			mlet	do_blk_text=$"$(do_blk_text)$";
		}

		// assembler
		labid=labid + 1;
		macro	slabid;
		num2str		slabid=labid,"%04x";
		psub	"^"$""([^"$""]*)"$""$","\1",cstr;
		gsub	"&lt;","<",cstr;
		fprint	fout,"// r1="$(do_blk_text)$,;
		fprint	fout,"ldwi	r1,lab__auto_"$(slabid)"_text"$,;
		fprint	fout,"bra	_auto_"$(slabid)_pool$,;
		fprint	fout,"_auto_"$(slabid)"_text:"$,;
		fprint	fout,"dats	"$"$(cstr)"\0"$"$,;
		fprint	fout,"_auto_"$(slabid)"_pool:"$,;

		val_done=true;
	}
	procedure	do_blk_text_length
	{
		var		cmp;
		macro	cstr;

		while (true)
		{
			fget_xml;
			macro	cxml=$(fget_xml);
			pindex	cmp=$(cxml),"^</block[ >]";
			if (cmp<=0)
			{
				pindex	cmp=$(cxml),"^<next[ >]";
			}
			if (cmp>0)
			{
				break;
			}

			pindex	cmp=$(cxml),"^<[^/]";
			if (cmp>0)
			{
				static : analyze_xml	$(cxml);
				macro	dxml=$(_xml_);
				do_$(dxml);
				mlet	cstr=$(do_$(dxml));
			}
		}
		mlet	do_blk_text_length="strlen ("$(cstr)")";

		// assembler
		fprint	fout,"// r0=strlen (r1(="$(cstr)"))"$,;
		fprint	fout,"jal$(z)r7	_strlen_r1"$,;
	}
	procedure	do_blk_text_isEmpty
	{
		var		cmp;
		macro	cstr;

		while (true)
		{
			fget_xml;
			macro	cxml=$(fget_xml);
			pindex	cmp=$(cxml),"^</block[ >]";
			if (cmp<=0)
			{
				pindex	cmp=$(cxml),"^<next[ >]";
			}
			if (cmp>0)
			{
				break;
			}

			pindex	cmp=$(cxml),"^<[^/]";
			if (cmp>0)
			{
				static : analyze_xml	$(cxml);
				macro	dxml=$(_xml_);
				do_$(dxml);
				mlet	cstr=$(do_$(dxml));
			}
		}
		mlet	do_blk_text_isEmpty="isempty ("$(cstr)")";

		// assembler
		fprint	fout,"// r0=isempty (r1(="$(cstr)"))"$,;
		fprint	fout,"ldb	r0,[r1]"$,;
		fprint	fout,"cmpi	r0,0"$,;
		fprint	fout,"ldbiu	r0,true"$,;
		fprint	fout,"beq	pcnt+2"$,;
		fprint	fout,"ldbiu	r0,false"$,;
	}
	procedure	do_blk_text_print
	{
		var		cmp;
		macro	cstr;

		while (true)
		{
			fget_xml;
			macro	cxml=$(fget_xml);
			pindex	cmp=$(cxml),"^</block[ >]";
			if (cmp<=0)
			{
				pindex	cmp=$(cxml),"^<next[ >]";
			}
			if (cmp>0)
			{
				break;
			}

			pindex	cmp=$(cxml),"^<[^/]";
			if (cmp>0)
			{
				static : analyze_xml	$(cxml);
				macro	dxml=$(_xml_);
				do_$(dxml);
				mlet	cstr=$(do_$(dxml));
			}
		}

		// string?
		strcmp	cmp=$(cstr),$",left;
		if (cmp)
		{
			is_cstr		$(cstr);
			if (is_cstr)
			{
				cmp=0;
			}
		}
		if (cmp=0)
		{
			// string or string variable

			// assembler
			fprint	fout,"// print r1(="$(cstr)")"$,;
			fprint	fout,"jal$(z)r7	_print_r1"$,;
		}
		else
		{
			// done?
			strcmp	cmp=$(cstr),"'",left;
			if (cmp=0)
			{
				// already done, just print

				// assembler
				fprint	fout,"// print r1(="$(cstr)")"$,;
				fprint	fout,"jal$(z)r7	_print_r1"$,;
			}
			else
			{
				// join?
				strcmp	cmp=$(cstr)," ++ ",left;
				if (cmp=0)
				{
					// join
					psub	"^ \+\+ ","",cstr;

					// assembler
					fprint	fout,"// print r1(="$(cstr)")"$,;
					fprint	fout,"jal$(z)r7	_print_r1"$,;
				}
				else
				{
					// number
					register_vars	"_tmp_str";
					register_cstr	"_tmp_str";

					// assembler
					fprint	fout,"// r1=r0(="$(cstr)")"$,;
					fprint	fout,"mov	r1,r0"$,;
					asm_ld_var	"r0","_tmp_str";
					fprint	fout,"// r0=strdec (r0,r1(="$(cstr)"))"$,;
					fprint	fout,"jal$(z)r7	_strdec_r0_r1"$,;
					asm_ld_var	"r1","_tmp_str";
					fprint	fout,"// print r1(='"$(cstr)"')"$,;
					fprint	fout,"jal$(z)r7	_print_r1"$,;

					mlet	cstr="'"$(cstr)"'";
				}
			}
		}
	}
	procedure	do_blk_text_join
	{
		var		cmp;
		macro	cstr;

		// nesting check
		nvar	in_text_join=false;
		if (in_text_join)
		{
			// ERROR:
			errmsg	"text_join: nesting";
			leave	stop_error;
		}
		in_text_join=true;

		// assembler
		fprint	fout,""$,;
		fprint	fout,"// join"$,;
		if (!in_var_set)
		{
			register_vars	"_tmp_str";
			register_cstr	"_tmp_str";

			// assembler
			asm_ld_var	"r0","_tmp_str";
		}
		fprint	fout,"push$(z)	r0"$,;

		while (true)
		{
			var		in_var_set=true;

			fget_xml;
			macro	cxml=$(fget_xml);
			pindex	cmp=$(cxml),"^</block[ >]";
			if (cmp<=0)
			{
				pindex	cmp=$(cxml),"^<next[ >]";
			}
			if (cmp>0)
			{
				break;
			}

			pindex	cmp=$(cxml),"^<[^/]";
			if (cmp>0)
			{
				static : analyze_xml	$(cxml);
				macro	dxml=$(_xml_);
				do_$(dxml);
				strcmp	cmp=$(dxml),"value";
				if (cmp=0)
				{
					mlet	cstr=$(do_$(dxml));

					// string?
					strcmp	cmp=$(cstr),$",left;
					if (cmp)
					{
						is_cstr		$(cstr);
						if (is_cstr)
						{
							cmp=0;
						}
					}
					if (cmp=0)
					{
						// string or string variable

						// assembler
						fprint	fout,"// join "$(cstr)$,;
						fprint	fout,"pop$(z)	r0"$,;
						fprint	fout,"jal$(z)r7	_strcpy_r0_r1"$,;
						fprint	fout,"push$(z)	r0"$,;
					}
					else
					{
						// done?
						strcmp	cmp=$(cstr),"'",left;
						if (cmp=0)
						{
							// already done
						}
						else
						{
							// number

							// assembler
							fprint	fout,"// r1=r0(="$(cstr)")"$,;
							fprint	fout,"mov	r1,r0"$,;
							fprint	fout,"// r0=strdec (r0,r1(="$(cstr)"))"$,;
							fprint	fout,"pop$(z)	r0"$,;
							fprint	fout,"jal$(z)r7	_strdec_r0_r1"$,;
							fprint	fout,"push$(z)	r0"$,;

							mlet	cstr="'"$(cstr)"'";
						}
					}
					mlet	do_blk_text_join=$(do_blk_text_join)" ++ "$(cstr);
				}
			}
		}

		// assembler
		mlet	cstr=$(do_blk_text_join);
		sub		" ++ ","",cstr;
		fprint	fout,"// end of join ("$(cstr)")"$,;
		fprint	fout,"pop$(z)	r0	// discard"$,;
		if (!in_var_set)
		{
			asm_ld_var	"r1","_tmp_str";
		}
	}
	procedure	do_blk_text_append
	{
		var		cmp;
		macro	vnam;
		macro	cstr;

		in_var_set=true;
		while (true)
		{
			fget_xml;
			macro	cxml=$(fget_xml);
			pindex	cmp=$(cxml),"^</block[ >]";
			if (cmp<=0)
			{
				pindex	cmp=$(cxml),"^<next[ >]";
			}
			if (cmp>0)
			{
				break;
			}

			pindex	cmp=$(cxml),"^<[^/]";
			if (cmp>0)
			{
				static : analyze_xml	$(cxml);
				macro	dxml=$(_xml_);
				do_$(dxml);
				strcmp	cmp=$(dxml),"field";
				if (cmp=0)
				{
					mlet	vnam=$(do_$(dxml));

					// assembler
					asm_ld_var	"r0",$(vnam);
					fprint	fout,"// r0=tail of string "$(vnam)$,;
					fprint	fout,"ldb	r7,[r0]"$,;
					fprint	fout,"addi	r0,1"$,;
					fprint	fout,"cmpi	r7,0"$,;
					fprint	fout,"bne	pcnt-8"$,;
					fprint	fout,"subi	r0,1"$,;
					fprint	fout,"push$(z)	r0"$,;
				}
				strcmp	cmp=$(dxml),"value";
				if (cmp=0)
				{
					mlet	cstr=$(do_$(dxml));
				}
			}
		}
		in_var_set=false;

		// string variable += <string>
		strcmp	cmp=$(cstr),"'", left;
		if (cmp=0)
		{
			// already processed (number ==> string)
			fprint	fout,"pop$(z)	r0	// discard"$,;
		}
		else
		{
			strcmp	cmp=$(cstr)," ++ ",left;
			if (cmp=0)
			{
				// joined
				psub	"^ \+\+ ","",cstr;

				// assembler
				fprint	fout,"// end of "$(vnam)"="$(cstr)$,;
				fprint	fout,"pop$(z)	r0	// discard"$,;
			}
			else
			{
				// not joined
				pindex	cmp=$(cstr),"^"$""[^"$""]*"$""$";
				if (cmp<=0)
				{
					// not a string constant
					is_cstr		$(cstr);
					if (is_cstr)
					{
						// string variable
						cmp=1;
					}
				}
				if (cmp>0)
				{
					// string constant or string variable

					// assembler
					fprint	fout,"// end of "$(vnam)"="$(cstr)$,;
					fprint	fout,"pop$(z)	r0"$,;
					fprint	fout,"jal$(z)r7	_strcpy_r0_r1"$,;
				}
				else
				{
					// number

					// assembler
					fprint	fout,"// r1=r0(="$(cstr)")"$,;
					fprint	fout,"mov	r1,r0"$,;
					fprint	fout,"// r0=strdec (r0,r1(="$(cstr)"))"$,;
					fprint	fout,"pop$(z)	r0"$,;
					fprint	fout,"jal$(z)r7	_strdec_r0_r1"$,;
				}
			}
		}
	}
	procedure	do_blk_procedures_ifreturn
	{
		var		cmp;
		macro	cexp;
		macro	vrtn;

		// assembler
		labid=labid + 1;
		macro	slabid;
		num2str		slabid=labid,"%04x";
		fprint	fout,""$,;
		fprint	fout,"// if return"$,;

		while (true)
		{
			fget_xml;
			macro	cxml=$(fget_xml);
			pindex	cmp=$(cxml),"^</block[ >]";
			if (cmp<=0)
			{
				pindex	cmp=$(cxml),"^<next[ >]";
			}
			if (cmp>0)
			{
				break;
			}

			pindex	cmp=$(cxml),"^<[^/]";
			if (cmp>0)
			{
				static : analyze_xml	$(cxml);
				macro	dxml=$(_xml_);
				nmacro	_xml_name;
				macro	dnam=$(_xml_name);
				do_$(dxml);
				strcmp	cmp=$(dxml),"value";
				if (cmp=0)
				{
					strcmp	cmp=$(dnam),"CONDITION";
					if (cmp=0)
					{
						mlet	cexp=$(do_$(dxml));

						// assembler
						fprint	fout,"// if ("$(cexp)")"$,;
						fprint	fout,"cmpi	r0,false"$,;
						fprint	fout,"beq	_auto_"$(slabid)"_endif"$,;
					}
					strcmp	cmp=$(dnam),"VALUE";
					if (cmp=0)
					{
						mlet	vrtn=$(do_$(dxml));
					}
				}
			}
		}

		// assembler
		strcmp	cmp=$(vrtn),"";
		if (cmp)
		{
			fprint	fout,"// return ("$(vrtn)")"$,;
		}
		else
		{
			fprint	fout,"// return"$,;
		}
		fprint	fout,"rtn$(z)"$,;
		fprint	fout,""$,;
		fprint	fout,"_auto_"$(slabid)"_endif:"$,;
	}
	procedure	do_blk_procedures_defreturn
	{
		var		cmp;
		var		stat;
		macro	fnam;
		macro	muta;
		macro	vrtn;

		while (true)
		{
			fget_xml;
			macro	cxml=$(fget_xml);
			if (stat=0)
			{
				pindex	cmp=$(cxml),"^<statement[ >]";
				if (cmp<=0)
				{
					pindex	cmp=$(cxml),"^<next[ >]";
				}
				if (cmp<=0)
				{
					pindex	cmp=$(cxml),"^</block[ >]";
				}
				if (cmp>0)
				{
					// continue
					pindex	cmp=$(cxml),"^<statement[ >]";
					if (cmp>0)
					{
						stat=1;
						continue;
					}
					else
					{
						// empty block
						stat=2;
					}
				}
			}
			if (stat=1)
			{
				// function block
				pindex	cmp=$(cxml),"^</statement[ >]";
				if (cmp>0)
				{
					// end of loop
					stat=2;
					continue;
				}
			}
			if (stat=2)
			{
				pindex	cmp=$(cxml),"^<next[ >]";
				if (cmp<=0)
				{
					pindex	cmp=$(cxml),"^</block[ >]";
				}
				if (cmp>0)
				{
					// end of function

					// assembler
					fprint	fout,""$,;
					fprint	fout,"// end of function: "$(fnam)$,;
					strcmp	cmp=$(vrtn),"";
					if (cmp)
					{
						fprint	fout,"// return ("$(vrtn)")"$,;
					}
					fprint	fout,"rtn$(z)"$,;

					break;
				}
			}

			pindex	cmp=$(cxml),"^<[^/]";
			if (cmp>0)
			{
				static : analyze_xml	$(cxml);
				macro	dxml=$(_xml_);
				do_$(dxml);
				if (stat=0)
				{
					strcmp	cmp=$(dxml),"mutation";
					if (cmp=0)
					{
						mlet	muta=$(do_$(dxml));
					}
					strcmp	cmp=$(dxml),"field";
					if (cmp=0)
					{
						mlet	fnam=$(do_$(dxml));
						
						// assembler
						if (defp_1st)
						{
							defp_1st=false;
							fprint	fout,""$,;
							fprint	fout,"// halt"$,;
							fprint	fout,"jmpr7	_rtlb_prog_halt"$,;
						}
						fprint	fout,""$,;
						fprint	fout,"// function: "$(fnam);
						strcmp	cmp=$(muta),"";
						if (cmp)
						{
							psub	" $","",muta;
							pgsub	" ",", ",muta;
							fprint	fout," ("$(muta)")";
						}
						fprint	fout,""$,;
						fprint	fout,"align	4"$,;
						fprint	fout,$(fnam)":"$,;
					}
				}
				if (true | stat=2)
				{
					strcmp	cmp=$(dxml),"value";
					if (cmp=0)
					{
						mlet	vrtn=$(do_$(dxml));
					}
				}
			}
		}
	}
	procedure	do_blk_procedures_defnoreturn
	{
		do_blk_procedures_defreturn;
	}
	procedure	do_blk_procedures_callreturn
	{
		var		cmp;
		macro	fnam;
		macro	muta;

		while (true)
		{
			fget_xml;
			macro	cxml=$(fget_xml);
			pindex	cmp=$(cxml),"^</block[ >]";
			if (cmp<=0)
			{
				pindex	cmp=$(cxml),"^<next[ >]";
			}
			if (cmp>0)
			{
				break;
			}

			pindex	cmp=$(cxml),"^<[^/]";
			if (cmp>0)
			{
				static : analyze_xml	$(cxml);
				macro	dxml=$(_xml_);
				nmacro	_xml_name;
				macro	dnam=$(_xml_name);
				do_$(dxml);
				strcmp	cmp=$(dxml),"mutation";
				if (cmp=0)
				{
					mlet	fnam=$(dnam);
					mlet	muta=$(do_$(dxml));
					psub	" $","",muta;
				}
				strcmp	cmp=$(dxml),"value";
				if (cmp=0)
				{
					var		num;
					var		narg;

					field	num=muta;
					psub	"[^0-9]*([0-9]+).*","\1",dnam;
					narg=$(dnam) + 1;

					// variable type check
					is_cstr		$(muta#(narg));
					if (is_cstr)
					{
						// ERROR:
						errmsg	"procedures_callreturn: "
								"inhibited string parameter ("$(muta#(narg))")";
						leave	stop_error;
					}

					// assembler
					fprint	fout,"// "$(muta#(narg))"=r0(="$(do_$(dxml))")"$,;
					asm_ld_var_adr	"r7",$(muta#(narg));
					fprint	fout,"st$(z)	[r7],r0"$,;
				}
			}
		}
		mlet	do_blk_procedures_callreturn=$(fnam);

		// assembler
		fprint	fout,"// function call: "$(fnam)$,;
		fprint	fout,"jal$(z)r7	"$(fnam)$,;
	}
	procedure	do_blk_procedures_callnoreturn
	{
		do_blk_procedures_callreturn;
	}
	procedure	do_blk_controls_repeat
	{
		do_blk_controls_repeat_ext;
	}
	procedure	do_blk_controls_repeat_ext
	{
		var		cmp;
		var		stat;
		var		ld_rpt;
		macro	rcnt;

		// register control variable
		register_vars	"_rpt_cnt";

		// assembler
		labid=labid + 1;
		macro	slabid;
		num2str		slabid=labid,"%04x";
		macro	slabid_loop=$(slabid);
		fprint	fout,""$,;
		fprint	fout,"// repeat loop"$,;

		while (true)
		{
			fget_xml;
			macro	cxml=$(fget_xml);
			if (stat=0)
			{
				pindex	cmp=$(cxml),"^<statement[ >]";
				if (cmp<=0)
				{
					pindex	cmp=$(cxml),"^<next[ >]";
				}
				if (cmp<=0)
				{
					pindex	cmp=$(cxml),"^</block[ >]";
				}
				if (cmp>0)
				{
					// loop condition

					// assembler
					fprint	fout,"// backup _rpt_cnt variable"$,;
					asm_ld_var	"r1","_rpt_cnt", "r7";
					fprint	fout,"push$(z)	r1"$,;
					if (ld_rpt)
					{
						fprint	fout,"// r0="$(rcnt)$,;
						fprint	fout,"ld$(z)i	r0,"$(rcnt)$,;
					}
					fprint	fout,"// _rpt_cnt=r0(="$(rcnt)")"$,;
					fprint	fout,"st$(z)	[r7],r0"$,;
					fprint	fout,"// r0(=_rpt_cnt)<1 ?"$,;
					fprint	fout,"cmpi	r0,1"$,;
					fprint	fout,"blt	_auto_"$(slabid)"_break"$,;
					fprint	fout,"// repeat ("$(rcnt)")"$,;
					fprint	fout,"_auto_"$(slabid)"_repeat:"$,;

					// continue
					pindex	cmp=$(cxml),"^<statement[ >]";
					if (cmp>0)
					{
						stat=1;
						continue;
					}
					else
					{
						// empty block
						stat=2;
					}
				}
			}
			if (stat=1)
			{
				// loop block
				pindex	cmp=$(cxml),"^</statement[ >]";
				if (cmp>0)
				{
					// end of loop
					stat=2;
					continue;
				}
			}
			if (stat=2)
			{
				pindex	cmp=$(cxml),"^<next[ >]";
				if (cmp<=0)
				{
					pindex	cmp=$(cxml),"^</block[ >]";
				}
				if (cmp>0)
				{
					// end of loop

					// assembler
					fprint	fout,""$,;
					fprint	fout,"// end of repeat loop"$,;
					fprint	fout,"_auto_"$(slabid)"_continue:"$,;
					asm_ld_var	"r0","_rpt_cnt", "r7";
					fprint	fout,"subi	r0,1"$,;
					fprint	fout,"st$(z)	[r7],r0"$,;
					fprint	fout,"bne	_auto_"$(slabid)"_repeat"$,;
					fprint	fout,""$,;
					fprint	fout,"_auto_"$(slabid)"_break:"$,;
					fprint	fout,"// restore _rpt_cnt variable"$,;
					asm_ld_var_adr	"r7","_rpt_cnt";
					fprint	fout,"pop$(z)	r0"$,;
					fprint	fout,"st$(z)	[r7],r0"$,;
					num2str		slabid_loop=0,"%04x";

					break;
				}
			}

			pindex	cmp=$(cxml),"^<[^/]";
			if (cmp>0)
			{
				static : analyze_xml	$(cxml);
				macro	dxml=$(_xml_);
				do_$(dxml);
				if (stat=0)
				{
					strcmp	cmp=$(dxml),"field";
					if (cmp)
					{
						strcmp	cmp=$(dxml),"value";
					}
					if (cmp=0)
					{
						mlet	rcnt=$(do_$(dxml));
						strcmp	cmp=$(dxml),"field";
						ld_rpt=( cmp=0 );
					}
				}
			}
		}
	}
	procedure	do_blk_controls_for
	{
		var		cmp;
		var		stat;
		macro	vnam;
		macro	vsta;
		macro	vend;
		macro	vstp;

		// assembler
		labid=labid + 1;
		macro	slabid;
		num2str		slabid=labid,"%04x";
		macro	slabid_loop=$(slabid);
		fprint	fout,""$,;
		fprint	fout,"// for loop"$,;

		while (true)
		{
			fget_xml;
			macro	cxml=$(fget_xml);
			if (stat=0)
			{
				pindex	cmp=$(cxml),"^<statement[ >]";
				if (cmp<=0)
				{
					pindex	cmp=$(cxml),"^<next[ >]";
				}
				if (cmp<=0)
				{
					pindex	cmp=$(cxml),"^</block[ >]";
				}
				if (cmp>0)
				{
					// loop condition
					strcmp	cmp=$(vstp),"";
					if (cmp=0)
					{
						mlet	vstp="1";

						// assembler
						fprint	fout,"// r0="$(vstp)$,;
						fprint	fout,"ld$(z)i	r0,"$(vstp)$,;
					}

					// assembler
					macro	fi;
					if (opt_opr_typ=opt_float)
					{
						mlet	fi="f";
					}
					fprint	fout,"// r2=r4=r0(="$(vstp)"); r1(="$(vend)")"$,;
					fprint	fout,"mov	r2,r0"$,;
					fprint	fout,"mov	r4,r0"$,;
					fprint	fout,"pop$(z)	r1"$,;
					fprint	fout,"// for ("$(vnam)"="$(vsta)"; "$(vend)"; "
							$(vstp)")"$,;
					fprint	fout,"// start mark?"$,;
					fprint	fout,"pop$(z)	r3"$,;
					fprint	fout,"cmpi	r3,false"$,;
					fprint	fout,"beq	pcnt+4"$,;
					fprint	fout,"ldbiu	r3,false"$,;
					fprint	fout,"ldbiu	r2,0"$,;
					fprint	fout,"push$(z)	r3"$,;
					asm_ld_var	"r0",$(vnam), "r7";
					fprint	fout,"// r0(="$(vnam)") += r2(="$(vstp)")"$,;
					fprint	fout,$(fi)"add	r0,r2"$,;
					fprint	fout,"st$(z)	[r7],r0"$,;
					fprint	fout,"// up or down count"$,;
					fprint	fout,"cmpi	r4,0"$,;
					fprint	fout,"blt	pcnt+4"$,;
					fprint	fout,$(fi)"cmp	r1,r0	// up count"$,;
					fprint	fout,"bra	pcnt+2"$,;
					fprint	fout,$(fi)"cmp	r0,r1	// down count"$,;
					fprint	fout,"blt	_auto_"$(slabid)"_break"$,;

					// continue
					pindex	cmp=$(cxml),"^<statement[ >]";
					if (cmp>0)
					{
						stat=1;
						continue;
					}
					else
					{
						// empty block
						stat=2;
					}
				}
			}
			if (stat=1)
			{
				// loop block
				pindex	cmp=$(cxml),"^</statement[ >]";
				if (cmp>0)
				{
					// end of loop
					stat=2;
					continue;
				}
			}
			if (stat=2)
			{
				pindex	cmp=$(cxml),"^<next[ >]";
				if (cmp<=0)
				{
					pindex	cmp=$(cxml),"^</block[ >]";
				}
				if (cmp>0)
				{
					// end of loop

					// assembler
					fprint	fout,""$,;
					fprint	fout,"// end of for loop"$,;
					fprint	fout,"bra	_auto_"$(slabid)"_for"$,;
					fprint	fout,""$,;
					fprint	fout,"_auto_"$(slabid)"_break:"$,;
					fprint	fout,"pop$(z)	r3	// discard"$,;
					num2str		slabid_loop=0,"%04x";

					break;
				}
			}

			pindex	cmp=$(cxml),"^<[^/]";
			if (cmp>0)
			{
				static : analyze_xml	$(cxml);
				macro	dxml=$(_xml_);
				nmacro	_xml_name;
				macro	dnam=$(_xml_name);
				do_$(dxml);
				if (stat=0)
				{
					strcmp	cmp=$(dxml),"field";
					if (cmp=0)
					{
						mlet	vnam=$(do_$(dxml));
					}
					strcmp	cmp=$(dxml),"value";
					if (cmp=0)
					{
						strcmp	cmp=$(dnam),"FROM";
						if (cmp=0)
						{
							mlet	vsta=$(do_$(dxml));

							// assembler
							fprint	fout,"// "$(vnam)"=r0(="$(vsta)")"$,;
							asm_ld_var_adr	"r7",$(vnam);
							fprint	fout,"st$(z)	[r7],r0"$,;
							fprint	fout,"// set start mark"$,;
							fprint	fout,"ldbiu	r3,true"$,;
							fprint	fout,"push$(z)	r3"$,;
							fprint	fout,"_auto_"$(slabid)"_for:"$,;
							fprint	fout,"_auto_"$(slabid)"_continue:"$,;
						}
						strcmp	cmp=$(dnam),"TO";
						if (cmp=0)
						{
							mlet	vend=$(do_$(dxml));

							// assembler
							fprint	fout,"push$(z)	r0"$,;
						}
						strcmp	cmp=$(dnam),"BY";
						if (cmp=0)
						{
							mlet	vstp=$(do_$(dxml));
						}
					}
				}
			}
		}
	}
	procedure	do_blk_controls_while
	{
		do_blk_controls_whileUntil;
	}
	procedure	do_blk_controls_whileUntil
	{
		var		cmp;
		var		stat;
		macro	wexp;
		macro	wmod=$(str_whl);

		// assembler
		labid=labid + 1;
		macro	slabid;
		num2str		slabid=labid,"%04x";
		macro	slabid_loop=$(slabid);
		fprint	fout,""$,;
		fprint	fout,"// while/until loop"$,;
		fprint	fout,"_auto_"$(slabid)"_while:"$,;
		fprint	fout,"_auto_"$(slabid)"_continue:"$,;

		while (true)
		{
			fget_xml;
			macro	cxml=$(fget_xml);
			if (stat=0)
			{
				pindex	cmp=$(cxml),"^<statement[ >]";
				if (cmp<=0)
				{
					pindex	cmp=$(cxml),"^<next[ >]";
				}
				if (cmp<=0)
				{
					pindex	cmp=$(cxml),"^</block[ >]";
				}
				if (cmp>0)
				{
					// loop condition

					// assembler
					fprint	fout,"// "$(wmod)" ("$(wexp)")"$,;
					strcmp	cmp=$(wmod),"until";
					if (cmp)
					{
						fprint	fout,"cmpi	r0,false"$,;
					}
					else
					{
						fprint	fout,"cmpi	r0,true"$,;
					}
					fprint	fout,"beq	_auto_"$(slabid)"_break"$,;

					// continue
					pindex	cmp=$(cxml),"^<statement[ >]";
					if (cmp>0)
					{
						stat=1;
						continue;
					}
					else
					{
						// empty block
						stat=2;
					}
				}
			}
			if (stat=1)
			{
				// loop block
				pindex	cmp=$(cxml),"^</statement[ >]";
				if (cmp>0)
				{
					// end of loop block
					stat=2;
					continue;
				}
			}
			if (stat=2)
			{
				pindex	cmp=$(cxml),"^<next[ >]";
				if (cmp<=0)
				{
					pindex	cmp=$(cxml),"^</block[ >]";
				}
				if (cmp>0)
				{
					// end of loop

					// assembler
					fprint	fout,""$,;
					fprint	fout,"// end of "$(wmod)" loop"$,;
					fprint	fout,"bra	_auto_"$(slabid)"_while"$,;
					fprint	fout,""$,;
					fprint	fout,"_auto_"$(slabid)"_break:"$,;
					num2str		slabid_loop=0,"%04x";

					break;
				}
			}

			pindex	cmp=$(cxml),"^<[^/]";
			if (cmp>0)
			{
				static : analyze_xml	$(cxml);
				macro	dxml=$(_xml_);
				do_$(dxml);
				if (stat=0)
				{
					strcmp	cmp=$(dxml),"field";
					if (cmp=0)
					{
						mlet	wmod=$(do_$(dxml));
						tolower	wmod;
					}
					strcmp	cmp=$(dxml),"value";
					if (cmp=0)
					{
						mlet	wexp=$(do_$(dxml));
					}
				}
			}
		}
	}
	procedure	do_blk_controls_flow_statements
	{
		var		cmp;
		macro	flws;

		while (true)
		{
			fget_xml;
			macro	cxml=$(fget_xml);
			pindex	cmp=$(cxml),"^</block[ >]";
			if (cmp>0)
			{
				break;
			}

			pindex	cmp=$(cxml),"^<[^/]";
			if (cmp>0)
			{
				static : analyze_xml	$(cxml);
				macro	dxml=$(_xml_);
				do_$(dxml);
				strcmp	cmp=$(dxml),"field";
				if (cmp=0)
				{
					mlet	flws=$(do_$(dxml));
				}
			}
		}
		tolower		flws;

		// assembler
		fprint	fout,"// "$(flws)$,;
		fprint	fout,"bra	_auto_"$(slabid_loop)"_"$(flws)$,;
	}
	procedure	do_blk_controls_if
	{
		var		idx;
		var		cmp;
		var		stat;
		var		cnt_elif;
		var		cnt_else;
		macro	cexp;

		// assembler
		labid=labid + 1;
		macro	slabid;
		num2str		slabid=labid,"%04x";
		fprint	fout,""$,;
		fprint	fout,"// if statement"$,;

		// if
		while (true)
		{
			fget_xml;
			macro	cxml=$(fget_xml);
			if (stat=0)
			{
				pindex	cmp=$(cxml),"^<statement[ >]";
				if (cmp<=0)
				{
					pindex	cmp=$(cxml),"^<next[ >]";
				}
				if (cmp<=0)
				{
					pindex	cmp=$(cxml),"^</block[ >]";
				}
				if (cmp>0)
				{
					// if condition
					static : analyze_xml	$(cxml);
					nmacro	_xml_name;
					strcmp	cmp=$(_xml_name),"DO0";
					if (cmp)
					{
						// ERROR:
						errmsg	"controls_if: inhibited empty if block";
						leave	stop_error;
					}
					strcmp	cmp=$(cexp),"";
					if (cmp=0)
					{
						// ERROR:
						errmsg	"controls_if: if condition not found";
						leave	stop_error;
					}

					// assembler
					fprint	fout,"// if ("$(cexp)")"$,;
					fprint	fout,"cmpi	r0,false"$,;
					fprint	fout,"beq	_auto_"$(slabid)"_if0"$,;

					// continue
					pindex	cmp=$(cxml),"^<statement[ >]";
					if (cmp>0)
					{
						stat=1;
						continue;
					}
					else
					{
						// ERROR:
						errmsg	"controls_if: inhibited empty if block";
						leave	stop_error;
					}
				}
			}
			if (stat=1)
			{
				// if block
				pindex	cmp=$(cxml),"^</statement[ >]";
				if (cmp>0)
				{
					// end of if block

					// assembler
					fprint	fout,""$,;
					fprint	fout,"// end of if block"$,;
					fprint	fout,"bra	_auto_"$(slabid)"_endif"$,;
					fprint	fout,""$,;
					fprint	fout,"_auto_"$(slabid)"_if0:"$,;

					break;
				}
			}

			pindex	cmp=$(cxml),"^<[^/]";
			if (cmp>0)
			{
				static : analyze_xml	$(cxml);
				macro	dxml=$(_xml_);
				if (stat=0)
				{
					// mutation must be processed before calling do_$(dxml)
					strcmp	cmp=$(dxml),"mutation";
					if (cmp=0)
					{
						nmacro	_xml_elseif="0";
						nmacro	_xml_else="0";
						cnt_elif=$(_xml_elseif);
						cnt_else=$(_xml_else);
					}
				}
				do_$(dxml);
				if (stat=0)
				{
					strcmp	cmp=$(dxml),"value";
					if (cmp=0)
					{
						mlet	cexp=$(do_$(dxml));
					}
				}
			}
		}

		// elif
		idx=1;
		while (idx<=cnt_elif)
		{
			stat=0;
			mlet	cexp="";
			while (true)
			{
				fget_xml;
				macro	cxml=$(fget_xml);
				if (stat=0)
				{
					pindex	cmp=$(cxml),"^<statement[ >]";
					if (cmp<=0)
					{
						pindex	cmp=$(cxml),"^<next[ >]";
					}
					if (cmp<=0)
					{
						pindex	cmp=$(cxml),"^</block[ >]";
					}
					if (cmp>0)
					{
						// elif condition
						static : analyze_xml	$(cxml);
						strcmp	cmp=$(_xml_name),"DO"#(idx);
						if (cmp)
						{
							// ERROR:
							errmsg	"controls_if: inhibited empty elif# block",
									idx;
							leave	stop_error;
						}
						strcmp	cmp=$(cexp),"";
						if (cmp=0)
						{
							// ERROR:
							errmsg	"controls_if: elif# condition not found",
									idx;
							leave	stop_error;
						}

						// assembler
						fprint	fout,"// elif# ("$(cexp)")"$,,idx;
						fprint	fout,"cmpi	r0,false"$,;
						fprint	fout,"beq	_auto_"$(slabid)"_elif#"$,,idx;

						// continue
						pindex	cmp=$(cxml),"^<statement[ >]";
						if (cmp>0)
						{
							stat=1;
							continue;
						}
						else
						{
							// ERROR:
							errmsg	"controls_if: inhibited empty elif# block",
									idx;
							leave	stop_error;
						}
					}
				}
				if (stat=1)
				{
					// elif block
					pindex	cmp=$(cxml),"^</statement[ >]";
					if (cmp>0)
					{
						// end of elif block

						// assembler
						fprint	fout,""$,;
						fprint	fout,"// end of elif# block"$,,idx;
						fprint	fout,"bra	_auto_"$(slabid)"_endif"$,;
						fprint	fout,""$,;
						fprint	fout,"_auto_"$(slabid)"_elif#:"$,,idx;

						break;
					}
				}

				pindex	cmp=$(cxml),"^<[^/]";
				if (cmp>0)
				{
					static : analyze_xml	$(cxml);
					macro	dxml=$(_xml_);
					do_$(dxml);
					if (stat=0)
					{
						strcmp	cmp=$(dxml),"value";
						if (cmp=0)
						{
							mlet	cexp=$(do_$(dxml));
						}
					}
				}
			}

			// continue
			idx=idx + 1;
		}

		// else
		if (cnt_else>0)
		{
			stat=0;
			while (true)
			{
				fget_xml;
				macro	cxml=$(fget_xml);
				if (stat=0)
				{
					pindex	cmp=$(cxml),"^<statement[ >]";
					if (cmp<=0)
					{
						pindex	cmp=$(cxml),"^<next[ >]";
					}
					if (cmp<=0)
					{
						pindex	cmp=$(cxml),"^</block[ >]";
					}
					if (cmp>0)
					{
						// else
						static : analyze_xml	$(cxml);
						strcmp	cmp=$(_xml_name),"ELSE";
						if (cmp)
						{
							// ERROR:
							errmsg	"controls_if: inhibited empty else block";
							leave	stop_error;
						}

						// assembler
						fprint	fout,""$,;
						fprint	fout,"// else"$,;

						// continue
						pindex	cmp=$(cxml),"^<statement[ >]";
						if (cmp>0)
						{
							stat=1;
							continue;
						}
						else
						{
							// ERROR:
							errmsg	"controls_if: inhibited empty else block.";
							leave	stop_error;
						}
					}
				}
				if (stat=1)
				{
					// else block
					pindex	cmp=$(cxml),"^</statement[ >]";
					if (cmp>0)
					{
						// end of else block

						// assembler
						fprint	fout,""$,;
						fprint	fout,"// end of else block"$,;

						break;
					}
				}

				pindex	cmp=$(cxml),"^<[^/]";
				if (cmp>0)
				{
					static : analyze_xml	$(cxml);
					macro	dxml=$(_xml_);
					do_$(dxml);
				}
			}
		}
		skip_one	"block";

		// assembler
		fprint	fout,""$,;
		fprint	fout,"// endif"$,;
		fprint	fout,"_auto_"$(slabid)"_endif:"$,;
	}
	procedure	do_block
	{
		var		cmp;

		nmacro	_xml_disabled="";
		strcmp	cmp=$(_xml_disabled),"true";
		if (cmp=0)
		{
			fget_xml;
			pindex	cmp=$(fget_xml),"^<next[ >]";
			if (cmp>0)
			{
				return;
			}
			repeat
			{
				skip_one	"block";
				pindex	cmp=$(fget_xml),"^<next[ >]";
			} until (cmp<=0);
		}
		else
		{
			// block type
			macro	blktyp=$(_xml_type);
			do_blk_$(blktyp);
			mlet	do_block=$(do_blk_$(blktyp));
		}
	}
	procedure	do_xml
	{
		var		cmp;

		fget_xml;
		while (fget_xml>=0)
		{
			static : analyze_xml	$(fget_xml);
			if (!analyze_xml)
			{
				// continue
				fget_xml;
				continue;
			}
			strcmp	cmp=$(_xml_),"";
			if (cmp)
			{
				strcmp	cmp=$(_xml_),"/",left;
			}
			if (cmp)
			{
				strcmp	cmp=$(_xml_),"next";
			}
			if (cmp=0)
			{
				// continue
				fget_xml;
				continue;
			}

			pindex	cmp=$(fget_xml),"^<";
			if (true & cmp>0)
			{
				do_$(_xml_);
			}

			// continue
			fget_xml;
		}
	}


	// open files
	var		fin;
	var		fout;
	fopen	fin,$(fnam_in),"r";
	fopen	fout,$(fnam_out),"w";

	// input file size
	var		fpos;
	var		fsiz;
	fseek	fin,-1;
	ftell	fin,fsiz;
	fseek	fin,0;
	if (fsiz=0)
	{
		// ERROR:
		errmsg	"Empty XML file";
		leave	stop_error;
	}

	// assembler
	fprint	fout,"// "$(prog_name)" ver."$(prog_vers)$,;
	fprint	fout,"//	Blockly.XML file: "$(fnam)"."$(ext)$,;
	fprint	fout,"## assembler"$,;
	fprint	fout,"asm	"$""mcoc_irom.mem"$"$,;
	fprint	fout,"##asm	"$""mcoc_irom.dat2"$"",bit16,list"$,;
	fprint	fout,"##@rom_siz@"$,;
	fprint	fout,"incl	"$""mcoc115.incl"$"$,;
	fprint	fout,"## constants"$,;
	fprint	fout,"equ	_rtlb_mul_need,@mul_need@"$,;
	fprint	fout,"equ	_rtlb_div_need,@div_need@"$,;
	fprint	fout,"equ	_rtlb_fpu_need,@fpu_need@"$,;
	fprint	fout,"equ	_rtlb_iram_need,@iram_need@"$,;
	fprint	fout,"equ	_rtlb_cstr_siz,@cstr_siz@"$,;
	fprint	fout,"## string macros"$,;
	fprint	fout,"def	s,"$""@sim_mod@"$""	// simulation="
			$"$"" / real fpga="$""##"$"$,;
	fprint	fout,"def	z,"$""@cpu_mod@"$""	// access size l(ong) / w(ord)"$,;
	fprint	fout,"##@vars_def@"$,;
	
	do_xml;
	progress	"",-1;

	// assembler
	if (defp_1st)
	{
		defp_1st=false;
		fprint	fout,""$,;
		fprint	fout,"// halt"$,;
		fprint	fout,"jmpr7	_rtlb_prog_halt"$,;
	}
	define_cstr;
	fprint	fout,""$,;
	fprint	fout,"// task entry point"$,;
	fprint	fout,"_rtlb_cpu2:"$,;
	if (tsk_def_cpu2)
	{
		fprint	fout,"datw	lab__rtlb_task_cpu2"$,;
	}
	else
	{
		fprint	fout,"datw	_rtlb_null"$,;
	}

	// close files
	fclose	fin;
	fclose	fout;


	// translator options
	opt_cstr_siz=@(opt_cstr_siz);
	clip	opt_cstr_siz=16,32767;

	// embed variable definitions
	fopen	fin,$(fnam_out),"r";
	fopen	fout,$(fnam_tmp),"w";

	fgets	fin,lbuf;
	while (status=0)
	{
		var		cmp;

		pindex	cmp=$(lbuf),"^#@vars_def@$";
		if (cmp>0)
		{
			var		idx;
			var		num;

			// assembler
			fprint	fout,""$,;
			fprint	fout,"## define variables"$,;
			fprint	fout,"equ	_rtlb_var_sizw,2"$,;
			fprint	fout,"equ	_rtlb_var_sizl,4"$,;
			fprint	fout,"equ	_va,0"$,;

			psub	"^@","",vlst_vars;
			field	num=vlst_vars,"@";
			idx=1;
			while (idx<num)
			{
				// assembler
				fprint	fout,"equ	"$(vlst_vars#(idx))",_va"$,;
				fprint	fout,"equ	_va,_va+_rtlb_var_siz$(z)"$,;

				// continue
				idx=idx + 1;
			}

			// assembler
			fprint	fout,"## end of define variables"$,;
			fprint	fout,"equ	_rtlb_var_static,_va"$,;
			fprint	fout,""$,;
			fprint	fout,"## define string buffers"$,;

			psub	"^@","",vlst_cstr;
			field	num=vlst_cstr,"@";
			idx=1;
			while (idx<num)
			{
				// assembler
				fprint	fout,"equ	_cstr_"$(vlst_cstr#(idx))",_va"$,;
				fprint	fout,"equ	_va,_va+_rtlb_cstr_siz"$,;

				// continue
				idx=idx + 1;
			}

			// assembler
			fprint	fout,"## end of define string buffers"$,;
			fprint	fout,"equ	_rtlb_var_array,_va"$,;
			fprint	fout,""$,;
			fprint	fout,"## include run time library"$,;
			fprint	fout,"incl	"$"$(mynam)".incl"$"$,;
			fprint	fout,""$,;

			// continue
			fgets	fin,lbuf;
			continue;
		}
		pindex	cmp=$(lbuf),"^#@rom_siz@$";
		if (cmp>0)
		{
			fprint	fout,"romsiz	#"$,,opt_rom_siz;

			// continue
			fgets	fin,lbuf;
			continue;
		}

		if (opt_mul_need)
		{
			sub		"@mul_need@","true",lbuf;
		}
		else
		{
			sub		"@mul_need@","false",lbuf;
		}
		if (opt_div_need)
		{
			sub		"@div_need@","true",lbuf;
		}
		else
		{
			sub		"@div_need@","false",lbuf;
		}
		if (opt_fpu_need)
		{
			sub		"@fpu_need@","true",lbuf;
		}
		else
		{
			sub		"@fpu_need@","false",lbuf;
		}
		if (opt_iram_need)
		{
			sub		"@iram_need@","true",lbuf;
		}
		else
		{
			sub		"@iram_need@","false",lbuf;
		}
		if (opt_cpu_mod=opt_nh)
		{
			sub		"@cpu_mod@","l",lbuf;
		}
		else
		{
			sub		"@cpu_mod@","w",lbuf;
		}
		if (opt_sim_mod)
		{
			sub		"@sim_mod@","",lbuf;
		}
		else
		{
			sub		"@sim_mod@","#",lbuf;
		}
		if (true)
		{
			sub		"@cstr_siz@",#(opt_cstr_siz),lbuf;
		}
		fputl	fout,$(lbuf);

		// continue
		fgets	fin,lbuf;
	}

	// close files
	fclose	fin;
	fclose	fout;

	// replace output file
	fmove	$(fnam_tmp),$(fnam_out), force;


	leave	stop_error;
}

