model	"Blockly.XML to Moscovium.ASM translator"
{
	macro	prog_name="Blockly.XML to Moscovium.ASM translator";
	macro	prog_vers="1.18";
// ================================
//
//	Moscovium series Blockly.XML to Moscovium.ASM translator
//		(c) 2024	1YEN Toru
//
//
//		2025/03/08	ver.1.18
//			corresponding to Wire (STWMST unit)
//			add: mcoc_wire_*
//			add: mcoc_math_post; variable reference and post process
//
//		2025/03/01	ver.1.16
//			add: mcoc_math_binary
//			add: mcoc_math_func2, mcoc_math_func3
//				mcoc_math_func2; sqrt, exp, log, log10, log2
//				mcoc_math_func3; sin, cos, tan, asin, acos, atan
//
//		2025/02/22	ver.1.14
//			corresponding to poly-core CPU
//			add: translator option @stk_iram@
//			add: mcoc_task; POLY and IRQP task
//			add: mcoc_math_bit_operation; logical shift operator ([>>])
//			add: mcoc_math_label
//			add: mcvm_cpu_exsg
//
//		2025/01/11	ver.1.12
//			corresponding to SPI-TFT (STFT61 unit, ST7735R)
//			add: mcoc_stft_*
//			add: mcoc_math_func; abs, rand, rseed, floor, ceil, round
//			update: corresponding to S-JIS encode string;
//				mcoc_math_ascii, mcoc_string_ctoa, mcoc_string_get_char
//			fix: atoi, xtoi; in_var_set=false for text_join control
//			fix: itox; need "push r0" for !in_var_set
//
//		2024/10/26	ver.1.10
//			corresponding to interrupt
//			optimized string constants
//			add: translator option @isr_bank@, @uart_baud@
//			add: mcoc_task; irq and irq2 task
//			add: mcvm_cpu_irqen
//			add: mcoc_controls_dorept, mcoc_controls_loop
//
//		2024/10/19	ver.1.08
//			corresponding to dual core cpu
//			corresponding to S-JIS encoding XML
//			add: translator option @var_iram@
//			del: translator option @var_top@
//			add: mcoc_task, mcoc_sytm_delay_cyc, mcvm_mem_addr
//
//		2024/09/21	ver.1.06
//			determine RAM top address from @rom_siz@ translator option
//			add: translator option @var_top@ (must be ramtop or iramtop)
//
//		2024/09/07	ver.1.04
//			add: mcoc_string_compare_left, mcoc_string_ctoa, mcoc_string_find,
//				mcoc_string_get_char, mcoc_string_label, mcoc_string_pointer,
//				mcoc_string_set
//
//		2024/08/31	ver.1.02
//			fix: do_blk_mcoc_uart_avail
//			fix: do_value, do_blk_mcoc_text_print, do_blk_controls_for
//			fix: do_blk_text: replace "&lt;" as "<"
//			change: reference to temporary string variable _tmp_str
//			change: automatic jump label name "_auto_*"
//			change: conditional branch for float; bmi/bpl to blt/bge
//			add: translator option @sim@ / @rom_siz@
//			add: custom blocks for Moscovium series CPU
//
//		2024/07/27	ver.1.00
//			need: run time library to assemble
//				https://github.com/1YEN-Toru/MCOC115-VD/blob/main/
//					asm/incl/blky2mcvm.incl
//
// ================================


	// constants
	var		opt_int=0;					// opt: int
	var		opt_float=1;				// opt: float
	var		opt_mc=1;					// opt: Mc
	var		opt_nh=2;					// opt: Nh
	macro	str_and="AND";				// str: "and"
	tolower		str_and;
	macro	str_or="OR";				// str: "or"
	tolower		str_or;
	macro	str_not="NOT";				// str: "not"
	tolower		str_not;
	macro	str_whl="WHILE";			// str: "while"
	tolower		str_whl;
	macro	str_bool0="false";			// str: "false"
	macro	str_bool1="true";			// str: "true"


	// variables
	var		labid;						// label id
	var		in_var_set;					// in variables_set block
	var		defp_1st=true;				// encounter 1st define procedure
	var		n_str_cnst=0;				// number of string constants
	var		need_math=false;			// mathematical function blocks used
	var		need_wire=false;			// Wire blocks used
	var		need_stft=false;			// SPI-TFT blocks used
	var		tsk_def_cpu2=false;			// tsk: task CPU2 defined
	var		tsk_def_poly=false;			// tsk: task POLY defined
	var		tsk_def_irq=false;			// tsk: task IRQ defined
	var		tsk_def_irq2=false;			// tsk: task IRQ2 defined
	var		tsk_def_irqp=false;			// tsk: task IRQP defined
	var		opt_cpu_mod=0;				// opt: CPU mode Mc (0,1) / Nh (2)
	var		opt_sim_mod=false;			// opt: simulation mode
	var		opt_mul_need=false;			// opt: need MULC16 / or not
	var		opt_div_need=false;			// opt: need DIVC32 / or not
	var		opt_fpu_need=false;			// opt: need FPU / or not
	var		opt_iram_need=false;		// opt: need I-RAM / or not
	var		opt_iram_stack=false;		// opt: set stack area to I-RAM
	var		opt_opr_typ=opt_int;		// opt: operation type (int / float)
	var		opt_cstr_siz=64;			// opt: string buffer size
	var		opt_rom_siz=4*1024;			// opt: instruction ROM size
	var		opt_isr_bank=1;				// opt: general register bank for isr
	var		opt_uart_baud=9600;			// opt: UART8N1 baud rate
	macro	vlst_vars;					// list of variables
	macro	vlst_cstr;					// list of string variables
	macro	dir,mynam,ext;
	pathsplit	$(pathname), dir,mynam,ext;


	// input file name
	var		rtn;
	macro	fnam;
	macro	fnam_in;
	macro	fnam_out;
	macro	fnam_tmp;
	gui		openfile, rtn, "Input File","",fnam_in;
	if (rtn=guiCancel)
	{
		// cancelled; select default source
		pathsplit	$(pathname), dir,fnam,ext;
		mlet	fnam_in=$(dir)$/$(fnam)".txt";
		ifnacc	$(fnam_in)
		{
			// cancelled; default source not found
			leave	stop_error;
		}
	}
	pathsplit	$(fnam_in), dir,fnam,ext;
	mlet	fnam_out=$(dir)$/$(fnam)".asm";
	mlet	fnam_tmp=$(dir)$/$(fnam)".tmp";


	// procedures
	procedure	fget_sjis
	{
		// If cod is within the range of the first byte of S-JIS code,
		//	read the second byte.
		if (0x81<=cod & cod<0xa0 | 0xe0<=cod & cod<0xfd)
		{
			var		cod2;

			fgetb	fin,cod2;
			cod=@((cod<<8) + cod2);
		}
	}
	procedure	fget_xml
	{
		// get string between "<" ~ ">"
		//	If the first character is not "<", extract up to the next "<".
		var		cmp;
		var		cod;
		macro	chr;

		ftell	fin,fpos;
		progress	"Translating...",100*fpos/fsiz;

		// read
		fgetb	fin,cod;
		fget_sjis;
		num2chr		chr=cod;
		strcmp	cmp="<",$(chr);
		if (cmp=0)
		{
			// "<" ~ ">"
			repeat
			{
				strcat	fget_xml, $(chr);
				fgetb	fin,cod;
				fget_sjis;
				if (cod<0)
				{
					// ERROR:
					fget_xml=cod;
					break;
				}
				num2chr		chr=cod;
				strcmp	cmp=">",$(chr);
			} until (cmp=0);
			strcat	fget_xml, $(chr);
		}
		else
		{
			// to the next "<"
			var		fpos;

			repeat
			{
				strcat	fget_xml, $(chr);
				ftell	fin,fpos;
				fgetb	fin,cod;
				fget_sjis;
				if (cod<0)
				{
					// ERROR:
					fget_xml=cod;
					break;
				}
				if (cod=0x0a)
				{
					mlet	chr=$,;
				}
				else
				{
					num2chr		chr=cod;
				}
				strcmp	cmp="<",$(chr);
			} until (cmp=0);
			fseek	fin,fpos;
			// ignore newline and indentation
			psub	"^"$," *$","",fget_xml;
			// replace newline with "\n"
			gsub	$,,"\n",fget_xml;
		}
		// remove unnecessary items
		pgsub	"\\"$",$",fget_xml;
		// tag
		pindex	cmp=$(fget_xml),"^<[^>]*>$";
		if (cmp>0)
		{
			pgsub	" [xyhw]="$""[^"$""]*"$","",fget_xml;
			pgsub	" id="$""[^"$""]*"$","",fget_xml;
			pgsub	" varid="$""[^"$""]*"$","",fget_xml;
			pgsub	" inline="$""[^"$""]*"$","",fget_xml;
			pgsub	" pinned="$""[^"$""]*"$","",fget_xml;
			pgsub	" deletable="$""[^"$""]*"$","",fget_xml;
			// change parameters to be space-separated
			repeat
			{
				psub	" ([A-z]+)=("$""[^"$""]*)"," \1 \2",fget_xml;
			} until (status=0);
		}
		// except tag
		pindex	cmp=$(fget_xml),"^<";
		if (cmp<=0)
		{
			gsub	"&#9;","\t",fget_xml;
			gsub	"&#10;","\n",fget_xml;
			gsub	"&gt;",">",fget_xml;
//			gsub	"&lt;","<",fget_xml;	// do not convert
			gsub	"&amp;","&",fget_xml;
		}
		// exit when a read error occurs
		if (fget_xml)
		{
			// error injection
			mlet	fget_xml="<error>";
		}
		// If empty string, read the next one
		//	(the above error processing should be done first)
		strcmp	cmp=$(fget_xml),"";
		if (cmp=0)
		{
			fget_xml;
		}
if (false)
{
	macro	tmp=$(fget_xml);
	pgsub	"#","##",tmp;
	fprint	fout,"##fget_xml:"$(tmp)$,;
}
	}
	procedure	analyze_xml		$$xstr
	{
		// analyze XML
		nvar	ax_idx;
		nvar	ax_num;
		nvar	ax_cmp;

		// XML?
		pindex	ax_cmp=$(fget_xml),"^<";
		if (ax_cmp<=0)
		{
			analyze_xml=0;
			return;
		}

		// analyze
		psub	"<([^>]*)>","\1",xstr;
		field	ax_num=xstr;
		nmacro	_xml_;
		mlet	_xml_=$(xstr1);
		ax_idx=2;
		static : while (ax_idx<ax_num)
		{
			nmacro	_xml_$(xstr#(ax_idx));
			mlet	_xml_$(xstr#(ax_idx))=$(xstr#(ax_idx + 1));
			psub	$""([^"$""]*)"$","\1",_xml_$(xstr#(ax_idx));

			// continue
			ax_idx=ax_idx + 2;
		}
		analyze_xml=ax_num;
	}
	procedure	skip_one	$$sxml
	{
		// skip the block sxml (return if it finds <next>.)
		var		cmp;

		while (true)
		{
			fget_xml;
			pindex	cmp=$(fget_xml),"</"$(sxml)"[ >";
			if (cmp<=0)
			{
				pindex	cmp=$(fget_xml),"^<next[ >]";
			}
			if (cmp>0)
			{
				break;
			}

			static : analyze_xml	$(fget_xml);
			if (analyze_xml=0)
			{
				continue;
			}
			strcmp	cmp=$(_xml_),"/",left;
			if (cmp=0)
			{
				continue;
			}

			skip_one	$(_xml_);
			pindex	cmp=$(fget_xml),"^<next[ >]";
			if (cmp>0)
			{
				break;
			}
		}
	}
	procedure	is_cstr		$$vnam
	{
		// return true if variable vnam was C-string variable
		pindex	is_cstr=$(vlst_cstr),"@"$(vnam)"@";
		is_cstr=!( is_cstr=false );
	}
	procedure	register_cstr	$$vnam
	{
		// register C-string variable vnam
		is_cstr		$(vnam);
		if (!is_cstr)
		{
			mlet	vlst_cstr=$(vlst_cstr)"@"$(vnam)"@";
			gsub	"@@","@",vlst_cstr;
		}
	}
	procedure	is_vars		$$vnam
	{
		// return true if variable vnam was registered
		pindex	is_vars=$(vlst_vars),"@"$(vnam)"@";
	}
	procedure	register_vars	$$vnam
	{
		// register variable vnam
		is_vars		$(vnam);
		if (!is_vars)
		{
			mlet	vlst_vars=$(vlst_vars)"@"$(vnam)"@";
			gsub	"@@","@",vlst_vars;
		}
	}
	procedure	asm_ld_var_adr	$$reg,$$vnam
	{
		// load address of variable vnam to general register reg
		//	outputs the assembler source list and returns
		//	R6: starting address of the variable area

		// assembler
		fprint	fout,"ldwi	"$(reg)","$(vnam)$,;
		fprint	fout,"add	"$(reg)",r6"$,;
	}
	procedure	asm_ld_var	$$reg,$$vnam,$$treg
	{
		// load the value of the variable vnam into general register reg
		//	outputs the assembler source list and returns
		//	uses general register treg for the pointer to the variable
		//	if treg is omitted, uses treg = reg
		nmacro	treg=$(reg);

		// assembler
		is_cstr		$(vnam);
		if (is_cstr)
		{
			fprint	fout,"// "$(reg)"=&"$(vnam)"[]"$,;
		}
		else
		{
			fprint	fout,"// "$(reg)"="$(vnam)$,;
		}
		asm_ld_var_adr	$(treg),$(vnam);
		fprint	fout,"ld$(z)	"$(reg)",["$(treg)"]"$,;
	}
	procedure	define_cstr
	{
		// outputs assembler source list to allocate
		//	and initialize C-string variable area
		var		idx;
		var		num;

		// assembler
		fprint	fout,""$,;
		fprint	fout,"// initialize string variables"$,;
		fprint	fout,"align	4"$,;
		fprint	fout,"_rtlb_vlst_cstr:"$,;

		psub	"^@","",vlst_cstr;
		field	num=vlst_cstr,"@";
		idx=1;
		while (idx<num)
		{
			// assembler
			fprint	fout,"// "$(vlst_cstr#(idx))"=&_cstr_"
					$(vlst_cstr#(idx))"[](="$"$"")"$,;
			asm_ld_var_adr	"r7",$(vlst_cstr#(idx));
			asm_ld_var_adr	"r0","_cstr_"$(vlst_cstr#(idx));
			fprint	fout,"st$(z)	[r7],r0"$,;
			fprint	fout,"ldbiu	r7,0"$,;
			fprint	fout,"stb	[r0],r7"$,;

			// continue
			idx=idx + 1;
		}

		// assembler
		fprint	fout,"// end of initialize string variables"$,;
		fprint	fout,"rtn$(z)"$,;
	}
	procedure	translator_options
	{
		// interpret the compile options in <comment>(cmnt)
		//	translator option: <comment>.*@<options>@.*</comment>
		//	<options>: <option>[,<option>[,...]]
		//	<option>: Mc / Nh / sim / int / float / <opt_name>=<val>
		//	<opt_name>: name of option
		//	<val>: numerical value
		var		idx;
		var		cmp;
		var		num;
		macro	copt;

		// translator options
		mlet	copt=$(cmnt);
		psub	".*@([^@]+)@.*","\1",copt;
		pgsub		"[ 	]","",copt;
		tolower		copt;
		field	num=copt,",";
		idx=1;
		while (idx<=num)
		{
			strcmp	cmp=$(copt#(idx)),"Mc",ics_match;
			if (cmp)
			{
				strcmp	cmp=$(copt#(idx)),"mcvm",ics_match;
			}
			if (cmp)
			{
				strcmp	cmp=$(copt#(idx)),"Moscovium",ics_match;
			}
			if (cmp=0)
			{
				if (opt_cpu_mod=opt_nh)
				{
					// ERROR:
					errmsg	"translator_options: re-defined CPU mode ("
							$(copt#(idx))")";
					leave	stop_error;
				}
				opt_cpu_mod=opt_mc;
			}
			strcmp	cmp=$(copt#(idx)),"Nh",ics_match;
			if (cmp)
			{
				strcmp	cmp=$(copt#(idx)),"niho",ics_match;
			}
			if (cmp)
			{
				strcmp	cmp=$(copt#(idx)),"Nihonium",ics_match;
			}
			if (cmp=0)
			{
				if (opt_cpu_mod=opt_mc)
				{
					// ERROR:
					errmsg	"translator_options: re-defined CPU mode ("
							$(copt#(idx))")";
					leave	stop_error;
				}
				opt_cpu_mod=opt_nh;
			}
			strcmp	cmp=$(copt#(idx)),"sim";
			if (cmp=0)
			{
				opt_sim_mod=true;
			}
			strcmp	cmp=$(copt#(idx)),"int";
			if (cmp=0)
			{
				opt_opr_typ=opt_int;
			}
			strcmp	cmp=$(copt#(idx)),"float";
			if (cmp=0)
			{
				opt_opr_typ=opt_float;
				opt_fpu_need=true;
			}
			strcmp	cmp=$(copt#(idx)),"var_iram";
			if (cmp=0)
			{
				opt_iram_need=true;
			}
			strcmp	cmp=$(copt#(idx)),"stk_iram";
			if (cmp=0)
			{
				opt_iram_need=true;
				opt_iram_stack=true;
			}
			index	cmp=$(copt#(idx)),"=";
			if (cmp>0)
			{
				macro	vnam;
				macro	nval;

				mlet	vnam=$(copt#(idx));
				psub	"=.*","",vnam;
				mlet	nval=$(copt#(idx));
				psub	".*=","",nval;
				static : nvar	opt_$(vnam);
				opt_$(vnam)=$(nval);
			}

			// continue
			idx=idx + 1;
		}

		// assembler
		fprint	fout,"// translator options: ("$(copt)")"$,;
	}
	procedure	do_comment
	{
		var		cmp;
		macro	cmnt;

		while (true)
		{
			fget_xml;
			macro	cxml=$(fget_xml);
			pindex	cmp=$(cxml),"^</comment[ >]";
			if (cmp>0)
			{
				break;
			}

			pindex	cmp=$(cxml),"^<[^/]";
			if (cmp>0)
			{
				static : analyze_xml	$(cxml);
				macro	dxml=$(_xml_);
				do_$(dxml);
			}
			else
			{
				mlet	cmnt=$(cmnt)$(cxml);
			}
		}

		// translator option
		pindex	cmp=$(cmnt),"@[^@]*@";
		if (cmp>0)
		{
			translator_options;
			psub	"@([^@]+)@","",cmnt;
		}

		// comment
		mlet	cmnt="// "$(cmnt);
		repeat
		{
			psub	"\\n[	 ]+$","",cmnt;
		} until (status=0);
		gsub	"&lt;","<",cmnt;
		gsub	"\t","	",cmnt;
		gsub	"\n",$,"// ",cmnt;
		gsub	"// 	","//	",cmnt;
		gsub	"// "$,,"//"$,,cmnt;
		psub	"// $","//",cmnt;
		gsub	"#","##",cmnt;

		// assembler
		strcmp	cmp=$(cmnt),"//";
		if (cmp)
		{
			fprint	fout,$(cmnt)$,;
		}
	}
	procedure	do_shadow
	{
		// empty, ignore shadow
	}
	procedure	do_field
	{
		var		cmp;
		var		is_txt;

		// text field?
		strcmp	cmp=$(_xml_name),"TEXT",ics_match;
		is_txt=( cmp=0 );

		while (true)
		{
			fget_xml;
			macro	cxml=$(fget_xml);
			pindex	cmp=$(cxml),"^</field[ >]";
			if (cmp>0)
			{
				break;
			}

			pindex	cmp=$(cxml),"^<";
			if (cmp<=0)
			{
				mlet	do_field=$(cxml);
			}
			pindex	cmp=$(cxml),"^<[^/]";
			if (cmp>0)
			{
				static : analyze_xml	$(cxml);
				macro	dxml=$(_xml_);
				do_$(dxml);
				mlet	do_field=$(do_$(dxml));
			}
		}
		if (is_txt)
		{
			gsub	$","\x22",do_field;
			mlet	do_field=$"$(do_field)$";
		}
	}
	procedure	do_value
	{
		var		cmp;
		var		val_done=true;

		strcmp	cmp=$(_xml_name),"text",ics_match;
		if (cmp=0)
		{
			val_done=false;
		}
		while (true)
		{
			fget_xml;
			macro	cxml=$(fget_xml);
			pindex	cmp=$(cxml),"^</value[ >]";
			if (cmp>0)
			{
				break;
			}

			pindex	cmp=$(cxml),"^<[^/]";
			if (cmp>0)
			{
				static : analyze_xml	$(cxml);
				macro	dxml=$(_xml_);
				do_$(dxml);
				strcmp	cmp=$(dxml),"block";
				if (cmp)
				{
					val_done=false;
				}
				mlet	do_value=$(do_$(dxml));
			}
		}
		strcmp	cmp=$(do_value),$",left;
		if (!val_done & cmp=0)
		{
// this code has never been activated.(?)
			// assembler
			labid=labid + 1;
			macro	slabid;
			num2str		slabid=labid,"%04x";
			macro	cstr=$(do_value);
			psub	"^"$""([^"$""]*)"$""$","\1",cstr;
			gsub	"&lt;","<",cstr;
			fprint	fout,"// r1="$(do_value)$,;
			fprint	fout,"ldwi	r1,lab__auto_"$(slabid)"_text"$,;
			fprint	fout,"bra	_auto_"$(slabid)_pool$,;
			fprint	fout,"_auto_"$(slabid)"_text:"$,;
			fprint	fout,"dats	"$"$(cstr)"\0"$"$,;
			fprint	fout,"_auto_"$(slabid)"_pool:"$,;
		}
		else
		{
			pindex	cmp=$(do_value),"^[0-9.+-]";
			if (cmp>0)
			{
				index	cmp=$(do_value)," ";
				cmp=( cmp=0 );
			}
			if (!val_done & cmp>0)
			{
				// assembler
				fprint	fout,"// r0="$(do_value)$,;
				if (opt_opr_typ=opt_int)
				{
					fprint	fout,"ld$(z)i	r0,"$(do_value)$,;
				}
				else
				{
					fprint	fout,"fld$(z)i	r0,"$(do_value)$,;
				}
			}
		}
	}
	procedure	do_mutation
	{
		var		cmp;

		while (true)
		{
			fget_xml;
			macro	cxml=$(fget_xml);
			pindex	cmp=$(cxml),"^</mutation[ >]";
			if (cmp>0)
			{
				break;
			}

			pindex	cmp=$(cxml),"^<[^/]";
			if (cmp>0)
			{
				static : analyze_xml	$(cxml);
				macro	dxml=$(_xml_);
				nmacro	_xml_name;
				macro	dnam=$(_xml_name);
				strcmp	cmp=$(dxml),"arg";
				if (cmp=0)
				{
					strcat	do_mutation,$(dnam)" ";
					continue;
				}
				do_$(dxml);
			}
		}
	}
	procedure	do_variable
	{
		fget_xml;
		register_vars	$(fget_xml);
	}
	procedure	do_variables
	{
		var		cmp;

		while (true)
		{
			fget_xml;
			macro	cxml=$(fget_xml);
			pindex	cmp=$(cxml),"^</variables[ >]";
			if (cmp>0)
			{
				break;
			}

			pindex	cmp=$(cxml),"^<[^/]";
			if (cmp>0)
			{
				static : analyze_xml	$(cxml);
				macro	dxml=$(_xml_);
				do_$(dxml);
			}
		}
	}
	procedure	do_blk_variables_set
	{
		var		cmp;
		macro	vnam;
		macro	nval;

		in_var_set=true;
		while (true)
		{
			fget_xml;
			macro	cxml=$(fget_xml);
			pindex	cmp=$(cxml),"^</block[ >]";
			if (cmp<=0)
			{
				pindex	cmp=$(cxml),"^<next[ >]";
			}
			if (cmp>0)
			{
				break;
			}

			pindex	cmp=$(cxml),"^<[^/]";
			if (cmp>0)
			{
				static : analyze_xml	$(cxml);
				macro	dxml=$(_xml_);
				do_$(dxml);
				strcmp	cmp=$(dxml),"field";
				if (cmp=0)
				{
					mlet	vnam=$(do_$(dxml));
					is_cstr		$(vnam);
					if (is_cstr)
					{
						// string variable

						// assembler
						asm_ld_var	"r0",$(vnam);
						fprint	fout,"push$(z)	r0"$,;
					}
				}
				strcmp	cmp=$(dxml),"value";
				if (cmp=0)
				{
					mlet	nval=$(do_$(dxml));
					strcmp	cmp=$(nval),$",left;
					is_cstr		$(vnam);
					if ((!is_cstr) & cmp=0)
					{
						// string variable declaration
						register_cstr	$(vnam);

						// assembler
						asm_ld_var	"r0",$(vnam);
						fprint	fout,"push$(z)	r0"$,;
					}
				}
			}
		}
		in_var_set=false;

		// target variable
		register_vars	$(vnam);
		is_cstr		$(vnam);
		if (!is_cstr)
		{
			// variable = <number>

			// assembler
			fprint	fout,"// "$(vnam)"=r0(="$(nval)")"$,;
			asm_ld_var_adr	"r7",$(vnam);
			fprint	fout,"st$(z)	[r7],r0"$,;
		}
		else
		{
			// string variable = <string>

			// assembler
			fprint	fout,"// end of "$(vnam)"="$(nval)$,;

			strcmp	cmp=$(nval),"'", left;
			if (cmp=0)
			{
				// already processed (number ==> string)

				// assembler
				fprint	fout,"pop$(z)	r0	// discard"$,;
			}
			else
			{
				strcmp	cmp=$(nval)," ++ ",left;
				if (cmp=0)
				{
					// joined
					psub	"^ \+\+ ","",nval;

					// assembler
					fprint	fout,"pop$(z)	r0	// discard"$,;
				}
				else
				{
					// not joined
					pindex	cmp=$(nval),"^"$""[^"$""]*"$""$";
					if (cmp<=0)
					{
						// not a string constant
						is_cstr		$(nval);
						if (is_cstr)
						{
							// string variable
							cmp=1;
						}
					}
					if (cmp>0)
					{
						// string constant or string variable

						// assembler
						fprint	fout,"pop$(z)	r0"$,;
						fprint	fout,"jal$(z)r7	_strcpy_r0_r1"$,;
					}
					else
					{
						// number

						// assembler
						fprint	fout,"// r1=r0(="$(nval)")"$,;
						fprint	fout,"mov	r1,r0"$,;
						fprint	fout,"// r0=strdec (r0,r1(="$(nval)"))"$,;
						fprint	fout,"pop$(z)	r0"$,;
						fprint	fout,"jal$(z)r7	_strdec_r0_r1"$,;
					}
				}
			}
		}
	}
	procedure	do_blk_variables_get
	{
		var		cmp;
		macro	vnam;

		while (true)
		{
			fget_xml;
			macro	cxml=$(fget_xml);
			pindex	cmp=$(cxml),"^</block[ >]";
			if (cmp>0)
			{
				break;
			}

			pindex	cmp=$(cxml),"^<[^/]";
			if (cmp>0)
			{
				static : analyze_xml	$(cxml);
				macro	dxml=$(_xml_);
				do_$(dxml);
				mlet	vnam=$(do_$(dxml));
			}
		}
		mlet	do_blk_variables_get=$(vnam);
		register_vars	$(vnam);

		// assembler
		is_cstr		$(vnam);
		if (is_cstr)
		{
			asm_ld_var	"r1",$(vnam);
		}
		else
		{
			asm_ld_var	"r0",$(vnam);
		}
	}
	procedure	do_blk_mcvm_cpu_asm
	{
		var		cmp;
		macro	iasm;

		while (true)
		{
			fget_xml;
			macro	cxml=$(fget_xml);
			pindex	cmp=$(cxml),"^</block[ >]";
			if (cmp<=0)
			{
				pindex	cmp=$(cxml),"^<next[ >]";
			}
			if (cmp>0)
			{
				break;
			}

			pindex	cmp=$(cxml),"^<[^/]";
			if (cmp>0)
			{
				static : analyze_xml	$(cxml);
				macro	dxml=$(_xml_);
				do_$(dxml);
				strcmp	cmp=$(dxml),"field";
				if (cmp=0)
				{
					mlet	iasm=$(do_$(dxml));
				}
			}
		}

		// assembler
		pgsub	"\\t","	",iasm;
		pgsub	"\\n",$,,iasm;
		pgsub	"#","##",iasm;
		pgsub	"&lt;","<",iasm;
		fprint	fout,$(iasm)$,;
	}
	procedure	do_blk_mcvm_cpu_cend
	{
		var		cmp;
		macro	nval;

		while (true)
		{
			fget_xml;
			macro	cxml=$(fget_xml);
			pindex	cmp=$(cxml),"^</block[ >]";
			if (cmp<=0)
			{
				pindex	cmp=$(cxml),"^<next[ >]";
			}
			if (cmp>0)
			{
				break;
			}

			pindex	cmp=$(cxml),"^<[^/]";
			if (cmp>0)
			{
				static : analyze_xml	$(cxml);
				macro	dxml=$(_xml_);
				do_$(dxml);
				strcmp	cmp=$(dxml),"value";
				if (cmp=0)
				{
					mlet	nval=$(do_$(dxml));
				}
			}
		}
		mlet	do_blk_mcvm_cpu_cend="cend ("$(nval)")";

		// assembler
		fprint	fout,"// convert endian r0(="$(nval)")"$,;
		fprint	fout,"cend$(z)	r0"$,;
	}
	procedure	do_blk_mcvm_cpu_irqen
	{
		var		cmp;
		macro	enlv;

		while (true)
		{
			fget_xml;
			macro	cxml=$(fget_xml);
			pindex	cmp=$(cxml),"^</block[ >]";
			if (cmp<=0)
			{
				pindex	cmp=$(cxml),"^<next[ >]";
			}
			if (cmp>0)
			{
				break;
			}

			pindex	cmp=$(cxml),"^<[^/]";
			if (cmp>0)
			{
				static : analyze_xml	$(cxml);
				macro	dxml=$(_xml_);
				do_$(dxml);
				strcmp	cmp=$(dxml),"field";
				if (cmp=0)
				{
					mlet	enlv=$(do_$(dxml));
				}
			}
		}

		// assembler
		fprint	fout,"// interrupts enable level"$,;
		fprint	fout,"srie	"$(enlv)$,;
	}
	procedure	do_blk_mcvm_cpu_reg
	{
		var		cmp;
		macro	rnam;

		while (true)
		{
			fget_xml;
			macro	cxml=$(fget_xml);
			pindex	cmp=$(cxml),"^</block[ >]";
			if (cmp<=0)
			{
				pindex	cmp=$(cxml),"^<next[ >]";
			}
			if (cmp>0)
			{
				break;
			}

			pindex	cmp=$(cxml),"^<[^/]";
			if (cmp>0)
			{
				static : analyze_xml	$(cxml);
				macro	dxml=$(_xml_);
				do_$(dxml);
				strcmp	cmp=$(dxml),"field";
				if (cmp=0)
				{
					mlet	rnam=$(do_$(dxml));
				}
			}
		}
		mlet	do_blk_mcvm_cpu_reg=$(rnam);

		// assembler
		strcmp	cmp=$(rnam),"r", left;
		fprint	fout,"// r0="$(rnam)$,;
		if (cmp=0)
		{
			// general register
			fprint	fout,"mov	r0,"$(rnam)$,;
		}
		else
		{
			// control register
			fprint	fout,"movfc	r0,"$(rnam)$,;
		}
	}
	procedure	do_blk_mcvm_cpu_set
	{
		var		cmp;
		macro	rnam;
		macro	nval;

		while (true)
		{
			fget_xml;
			macro	cxml=$(fget_xml);
			pindex	cmp=$(cxml),"^</block[ >]";
			if (cmp<=0)
			{
				pindex	cmp=$(cxml),"^<next[ >]";
			}
			if (cmp>0)
			{
				break;
			}

			pindex	cmp=$(cxml),"^<[^/]";
			if (cmp>0)
			{
				static : analyze_xml	$(cxml);
				macro	dxml=$(_xml_);
				do_$(dxml);
				strcmp	cmp=$(dxml),"field";
				if (cmp=0)
				{
					mlet	rnam=$(do_$(dxml));
				}
				strcmp	cmp=$(dxml),"value";
				if (cmp=0)
				{
					mlet	nval=$(do_$(dxml));
				}
			}
		}

		// assembler
		strcmp	cmp=$(rnam),"r", left;
		fprint	fout,"// "$(rnam)"=r0(="$(nval)")"$,;
		if (cmp=0)
		{
			// general register
			fprint	fout,"mov	"$(rnam)",r0"$,;
		}
		else
		{
			// control register
			fprint	fout,"movtc	"$(rnam)",r0"$,;
		}
	}
	procedure	do_blk_mcvm_cpu_exsg
	{
		var		cmp;
		macro	opcd;
		macro	nval;

		while (true)
		{
			fget_xml;
			macro	cxml=$(fget_xml);
			pindex	cmp=$(cxml),"^</block[ >]";
			if (cmp<=0)
			{
				pindex	cmp=$(cxml),"^<next[ >]";
			}
			if (cmp>0)
			{
				break;
			}

			pindex	cmp=$(cxml),"^<[^/]";
			if (cmp>0)
			{
				static : analyze_xml	$(cxml);
				macro	dxml=$(_xml_);
				do_$(dxml);
				strcmp	cmp=$(dxml),"field";
				if (cmp=0)
				{
					mlet	opcd=$(do_$(dxml));
				}
				strcmp	cmp=$(dxml),"value";
				if (cmp=0)
				{
					mlet	nval=$(do_$(dxml));
				}
			}
		}
		tolower		opcd;
		mlet	do_blk_mcvm_cpu_exsg=$(opcd)" ("$(nval)")";

		// assembler
		fprint	fout,"// "$(opcd)" (r0(="$(nval)"))"$,;
		fprint	fout,$(opcd)"	r0"$,;
	}
	procedure	do_blk_mcvm_fpu_isinf
	{
		var		cmp;
		macro	nval;

		while (true)
		{
			fget_xml;
			macro	cxml=$(fget_xml);
			pindex	cmp=$(cxml),"^</block[ >]";
			if (cmp<=0)
			{
				pindex	cmp=$(cxml),"^<next[ >]";
			}
			if (cmp>0)
			{
				break;
			}

			pindex	cmp=$(cxml),"^<[^/]";
			if (cmp>0)
			{
				static : analyze_xml	$(cxml);
				macro	dxml=$(_xml_);
				do_$(dxml);
				strcmp	cmp=$(dxml),"value";
				if (cmp=0)
				{
					mlet	nval=$(do_$(dxml));
				}
			}
		}
		mlet	do_blk_mcvm_fpu_isinf="isinf ("$(nval)")";

		// assembler
		fprint	fout,"// r0=abs (r0)"$,;
		fprint	fout,"lsli	r0,1"$,;
		fprint	fout,"lsri	r0,1"$,;
		fprint	fout,"// r1=INF"$,;
		fprint	fout,"ld$(z)i	r1,_rtlb_inf$(z)"$,;
		fprint	fout,"// r0=isinf (r0(="$(nval)"))"$,;
		fprint	fout,"fcmp	r0,r1"$,;	// fcmp is better than cmp
		fprint	fout,"ldbiu	r0,true"$,;
		fprint	fout,"bcs	pcnt+2"$,;
		fprint	fout,"ldbiu	r0,false"$,;
		opt_fpu_need=true;
	}
	procedure	do_blk_mcvm_fpu_isnan
	{
		var		cmp;
		macro	nval;

		while (true)
		{
			fget_xml;
			macro	cxml=$(fget_xml);
			pindex	cmp=$(cxml),"^</block[ >]";
			if (cmp<=0)
			{
				pindex	cmp=$(cxml),"^<next[ >]";
			}
			if (cmp>0)
			{
				break;
			}

			pindex	cmp=$(cxml),"^<[^/]";
			if (cmp>0)
			{
				static : analyze_xml	$(cxml);
				macro	dxml=$(_xml_);
				do_$(dxml);
				strcmp	cmp=$(dxml),"value";
				if (cmp=0)
				{
					mlet	nval=$(do_$(dxml));
				}
			}
		}
		mlet	do_blk_mcvm_fpu_isnan="isnan ("$(nval)")";

		// assembler
		fprint	fout,"// r1=NaN"$,;
		fprint	fout,"ld$(z)i	r1,_rtlb_nan$(z)"$,;
		fprint	fout,"// r0=isnan (r0(="$(nval)"))"$,;
		fprint	fout,"fcmp	r0,r1"$,;	// fcmp is better than cmp
		fprint	fout,"ldbiu	r0,true"$,;
		fprint	fout,"bcs	pcnt+2"$,;
		fprint	fout,"ldbiu	r0,false"$,;
		opt_fpu_need=true;
	}
	procedure	do_blk_mcvm_fpu_fdown
	{
		var		cmp;
		macro	nval;

		while (true)
		{
			fget_xml;
			macro	cxml=$(fget_xml);
			pindex	cmp=$(cxml),"^</block[ >]";
			if (cmp>0)
			{
				break;
			}

			pindex	cmp=$(cxml),"^<[^/]";
			if (cmp>0)
			{
				static : analyze_xml	$(cxml);
				macro	dxml=$(_xml_);
				do_$(dxml);
				strcmp	cmp=$(dxml),"value";
				if (cmp=0)
				{
					mlet	nval=$(do_$(dxml));
				}
			}
		}

		// assembler
		fprint	fout,"// r0=fdown (r0(="$(nval)"))"$,;
		fprint	fout,"fdown	r0,r0"$,;
		opt_fpu_need=true;

		mlet	do_blk_mcvm_fpu_fdown="fdown ("$(nval)")";
	}
	procedure	do_blk_mcvm_fpu_ftoi
	{
		macro	ctyp="int";

		do_blk_cast_number;
		mlet	do_blk_mcvm_fpu_ftoi=$(do_blk_cast_number);
	}
	procedure	do_blk_mcvm_fpu_itof
	{
		macro	ctyp="float";

		do_blk_cast_number;
		mlet	do_blk_mcvm_fpu_itof=$(do_blk_cast_number);
	}
	procedure	do_blk_mcvm_sim_pass
	{
		var		cmp;

		while (true)
		{
			fget_xml;
			macro	cxml=$(fget_xml);
			pindex	cmp=$(cxml),"^</block[ >]";
			if (cmp<=0)
			{
				pindex	cmp=$(cxml),"^<next[ >]";
			}
			if (cmp>0)
			{
				break;
			}

			pindex	cmp=$(cxml),"^<[^/]";
			if (cmp>0)
			{
				static : analyze_xml	$(cxml);
				macro	dxml=$(_xml_);
				do_$(dxml);
			}
		}

		// assembler
		fprint	fout,"$(s)// simulation pass"$,;
		fprint	fout,"$(s)// ********************************"$,;
		fprint	fout,"$(s)ldwi	r0,simpass"$,;
		fprint	fout,"$(s)ldwi	r7,simfnsh"$,;
		fprint	fout,"$(s)stw	[r7],r0"$,;
		fprint	fout,"$(s)// ********************************"$,;
	}
	procedure	do_blk_mcvm_sim_fail
	{
		var		cmp;

		while (true)
		{
			fget_xml;
			macro	cxml=$(fget_xml);
			pindex	cmp=$(cxml),"^</block[ >]";
			if (cmp<=0)
			{
				pindex	cmp=$(cxml),"^<next[ >]";
			}
			if (cmp>0)
			{
				break;
			}

			pindex	cmp=$(cxml),"^<[^/]";
			if (cmp>0)
			{
				static : analyze_xml	$(cxml);
				macro	dxml=$(_xml_);
				do_$(dxml);
			}
		}

		// assembler
		fprint	fout,"$(s)// simulation fail"$,;
		fprint	fout,"$(s)// ********************************"$,;
		fprint	fout,"$(s)ldwi	r0,simfail"$,;
		fprint	fout,"$(s)ldwi	r7,simfnsh"$,;
		fprint	fout,"$(s)stw	[r7],r0"$,;
		fprint	fout,"$(s)// ********************************"$,;
	}
	procedure	do_blk_mcvm_mem_addr
	{
		var		cmp;
		macro	vnam;

		while (true)
		{
			fget_xml;
			macro	cxml=$(fget_xml);
			pindex	cmp=$(cxml),"^</block[ >]";
			if (cmp<=0)
			{
				pindex	cmp=$(cxml),"^<next[ >]";
			}
			if (cmp>0)
			{
				break;
			}

			pindex	cmp=$(cxml),"^<[^/]";
			if (cmp>0)
			{
				static : analyze_xml	$(cxml);
				macro	dxml=$(_xml_);
				do_$(dxml);
				strcmp	cmp=$(dxml),"field";
				if (cmp=0)
				{
					mlet	vnam=$(do_$(dxml));
				}
			}
		}

		// assembler
		is_cstr		$(vnam);
		if (is_cstr)
		{
			// string variable
			asm_ld_var	"r0",$(vnam);
			mlet	do_blk_mcvm_mem_addr="&"$(vnam)"[]";
		}
		else
		{
			// variable
			fprint	fout,"// r0=&"$(vnam)$,;
			asm_ld_var_adr	"r0",$(vnam);
			mlet	do_blk_mcvm_mem_addr="&"$(vnam);
		}
	}
	procedure	do_blk_mcvm_mem_read
	{
		var		cmp;
		nvar	asiz=2;
		macro	siz;
		macro	adrx;
		macro	adr;

		while (true)
		{
			fget_xml;
			macro	cxml=$(fget_xml);
			pindex	cmp=$(cxml),"^</block[ >]";
			if (cmp<=0)
			{
				pindex	cmp=$(cxml),"^<next[ >]";
			}
			if (cmp>0)
			{
				break;
			}

			pindex	cmp=$(cxml),"^<[^/]";
			if (cmp>0)
			{
				static : analyze_xml	$(cxml);
				macro	dxml=$(_xml_);
				nmacro	_xml_name;
				macro	dnam=$(_xml_name);
				do_$(dxml);
				strcmp	cmp=$(dxml),"field";
				if (cmp=0)
				{
					mlet	siz=$(do_$(dxml));
					strcmp	cmp=$(siz),"B",ics_left;
					if (cmp=0)
					{
						asiz=1;
					}
					strcmp	cmp=$(siz),"W",ics_left;
					if (cmp=0)
					{
						asiz=2;
					}
					strcmp	cmp=$(siz),"L",ics_left;
					if (cmp=0)
					{
						asiz=4;
					}
				}
				strcmp	cmp=$(dxml),"value";
				if (cmp=0)
				{
					strcmp	cmp=$(dnam),"ADRX";
					if (cmp=0)
					{
						mlet	adrx=$(do_$(dxml));

						// assembler
						fprint	fout,"// tr=r0(="$(adrx)")"$,;
						fprint	fout,"movtc	tr,r0"$,;
					}
					else
					{
						mlet	adr=$(do_$(dxml));
					}
				}
			}
		}
		mlet	do_blk_mcvm_mem_read="["$(adr)"]";

		// check
		if (asiz=4 & opt_cpu_mod!=opt_nh)
		{
			// ERROR:
			errmsg	"mcvm_mem_read: need @Nh@ translator option"
					" for long access";
			leave	stop_error;
		}

		// assembler
		fprint	fout,"// memory read "$(siz)$,;
		strcmp	cmp=$(adrx),"";
		if (cmp=0)
		{
			fprint	fout,"// r0=[r0(="$(adr)")]"$,;
			if (asiz=4)
			{
				fprint	fout,"ldl	r0,[r0]"$,;
			}
			elif (asiz=2)
			{
				fprint	fout,"ldw	r0,[r0]"$,;
			}
			else
			{
				fprint	fout,"ldb	r0,[r0]"$,;
			}
		}
		else
		{
			fprint	fout,"// r0=[tr(="$(adrx)"):r0(="$(adr)")]"$,;
			if (asiz=2)
			{
				fprint	fout,"ldwx	r0,[tr:r0]"$,;
			}
			else
			{
				fprint	fout,"ldbx	r0,[tr:r0]"$,;
			}

			mlet	do_blk_mcvm_mem_read="["$(adrx)":"$(adr)"]";
		}
	}
	procedure	do_blk_mcvm_memx_read
	{
		do_blk_mcvm_mem_read;
		mlet	do_blk_mcvm_memx_read=$(do_blk_mcvm_mem_read);
	}
	procedure	do_blk_mcvm_mem_write
	{
		var		cmp;
		nvar	asiz=2;
		macro	siz;
		macro	adrx;
		macro	adr;
		macro	dat;

		while (true)
		{
			fget_xml;
			macro	cxml=$(fget_xml);
			pindex	cmp=$(cxml),"^</block[ >]";
			if (cmp<=0)
			{
				pindex	cmp=$(cxml),"^<next[ >]";
			}
			if (cmp>0)
			{
				break;
			}

			pindex	cmp=$(cxml),"^<[^/]";
			if (cmp>0)
			{
				static : analyze_xml	$(cxml);
				macro	dxml=$(_xml_);
				nmacro	_xml_name;
				macro	dnam=$(_xml_name);
				do_$(dxml);
				strcmp	cmp=$(dxml),"field";
				if (cmp=0)
				{
					mlet	siz=$(do_$(dxml));
					strcmp	cmp=$(siz),"B",ics_left;
					if (cmp=0)
					{
						asiz=1;
					}
					strcmp	cmp=$(siz),"W",ics_left;
					if (cmp=0)
					{
						asiz=2;
					}
					strcmp	cmp=$(siz),"L",ics_left;
					if (cmp=0)
					{
						asiz=4;
					}
				}
				strcmp	cmp=$(dxml),"value";
				if (cmp=0)
				{
					strcmp	cmp=$(dnam),"ADRX";
					if (cmp=0)
					{
						mlet	adrx=$(do_$(dxml));

						// assembler
						fprint	fout,"// tr=r0(="$(adrx)")"$,;
						fprint	fout,"movtc	tr,r0"$,;
					}
					strcmp	cmp=$(dnam),"ADR";
					if (cmp=0)
					{
						mlet	adr=$(do_$(dxml));

						// assembler
						fprint	fout,"push$(z)	r0"$,;
					}
					strcmp	cmp=$(dnam),"DAT";
					if (cmp=0)
					{
						mlet	dat=$(do_$(dxml));

						// assembler
						fprint	fout,"// r7(="$(adr)")"$,;
						fprint	fout,"pop$(z)	r7"$,;
					}
				}
			}
		}

		// check
		if (asiz=4 & opt_cpu_mod!=opt_nh)
		{
			// ERROR:
			errmsg	"mcvm_mem_write: need @Nh@ translator option"
					" for long access";
			leave	stop_error;
		}

		// assembler
		fprint	fout,"// memory write "$(siz)$,;
		strcmp	cmp=$(adrx),"";
		if (cmp=0)
		{
			fprint	fout,"// [r7(="$(adr)")] = r0(="$(dat)")"$,;
			if (asiz=4)
			{
				fprint	fout,"stl	[r7],r0"$,;
			}
			elif (asiz=2)
			{
				fprint	fout,"stw	[r7],r0"$,;
			}
			else
			{
				fprint	fout,"stb	[r7],r0"$,;
			}
		}
		else
		{
			fprint	fout,"// [tr(="$(adrx)"):r7(="$(adr)")] = r0(="$(dat)")"$,;
			if (asiz=2)
			{
				fprint	fout,"stwx	[tr:r7],r0"$,;
			}
			else
			{
				fprint	fout,"stbx	[tr:r7],r0"$,;
			}
		}
	}
	procedure	do_blk_mcvm_memx_write
	{
		do_blk_mcvm_mem_write;
		mlet	do_blk_mcvm_memx_write=$(do_blk_mcvm_mem_write);
	}
	procedure	do_blk_mcoc_math_ascii
	{
		var		cmp;
		var		chr;
		macro	cstr;
		macro	shex;

		while (true)
		{
			fget_xml;
			macro	cxml=$(fget_xml);
			pindex	cmp=$(cxml),"^</block[ >]";
			if (cmp>0)
			{
				break;
			}

			pindex	cmp=$(cxml),"^<[^/]";
			if (cmp>0)
			{
				static : analyze_xml	$(cxml);
				macro	dxml=$(_xml_);
				do_$(dxml);
				strcmp	cmp=$(dxml),"field";
				if (cmp=0)
				{
					mlet	cstr=$(do_$(dxml));
				}
			}
		}

		// ascii code
		gsub	"&lt;","<",cstr;
		psub	"^(.).*","\1",cstr;
		gsub	"#","##",cstr;
		chr2num		chr=$(cstr);
		if (chr>255)
		{
			num2str		shex=chr,"%04x";
		}
		else
		{
			num2str		shex=chr,"%02x";
		}
		mlet	do_blk_mcoc_math_ascii="0x"$(shex);

		// assembler
		fprint	fout,"// r0=0x"$(shex)"(=0a"$(cstr)")"$,;
		if (chr>255)
		{
			fprint	fout,"ldwi	r0,0x"$(shex)$,;	// do not use '0a'
		}
		else
		{
			fprint	fout,"ldbiu	r0,0x"$(shex)$,;	// do not use '0a'
		}

		val_done=true;
	}
	procedure	do_blk_mcoc_math_post
	{
		var		cmp;
		var		val;
		macro	mne;
		macro	opr;
		macro	vnam;

		while (true)
		{
			fget_xml;
			macro	cxml=$(fget_xml);
			pindex	cmp=$(cxml),"^</block[ >]";
			if (cmp<=0)
			{
				pindex	cmp=$(cxml),"^<next[ >]";
			}
			if (cmp>0)
			{
				break;
			}

			pindex	cmp=$(cxml),"^<[^/]";
			if (cmp>0)
			{
				static : analyze_xml	$(cxml);
				macro	dxml=$(_xml_);
				nmacro	_xml_name;
				macro	dnam=$(_xml_name);
				do_$(dxml);
				strcmp	cmp=$(dxml),"field";
				if (cmp=0)
				{
					strcmp	cmp=$(dnam),"VAR";
					if (cmp=0)
					{
						mlet	vnam=$(do_$(dxml));
					}
					else
					{
						mlet	opr=$(do_$(dxml));
					}
				}
			}
		}
		is_cstr		$(vnam);
		if (is_cstr)
		{
			// ERROR:
			errmsg	"mcoc_math_post: string variable ("$(vnam)") not suit.";
			leave	stop_error;
		}

		// operator
		gsub	"&lt;","<",opr;
		gsub	"&gt;",">",opr;
		val=1;
		mlet	mne="xxx";
		strcmp	cmp=$(opr),"++", left;
		if (cmp)
		{
			strcmp	cmp=$(opr),"--", left;
		}
		if (cmp=0)
		{
			strcmp	cmp=$(opr),"++", left;
			if (cmp=0)
			{
				mlet	mne="add";
			}
			else
			{
				mlet	mne="sub";
			}
			strcmp	cmp=$(opr),"2", right;
			if (cmp=0)
			{
				val=2;
			}
			strcmp	cmp=$(opr),"4", right;
			if (cmp=0)
			{
				val=4;
			}
		}
		else
		{
			// ERROR:
			errmsg	"mcoc_math_post: unsupported operator ("$(opr)")";
			leave	stop_error;
		}

		// assembler
		asm_ld_var	"r0",$(vnam);
		fprint	fout,"// "$(vnam)"=r1=r0(="$(vnam)") "$(opr)$,;
		fprint	fout,"mov	r1,r0"$,;
		if (opt_opr_typ!=opt_float)
		{
			fprint	fout,$(mne)"i	r1,#"$,,val;
		}
		else
		{
			fprint	fout,"fld$(z)i	r2,#"$,,val;
			fprint	fout,"f"$(mne)"	r1,r2"$,;
		}
		fprint	fout,"st$(z)	[r7],r1"$,;

		mlet	do_blk_mcoc_math_post=$(vnam)" "$(opr);
	}
	procedure	do_blk_mcoc_math_unary
	{
		var		cmp;
		macro	opr;
		macro	mne;
		macro	nval;

		while (true)
		{
			fget_xml;
			macro	cxml=$(fget_xml);
			pindex	cmp=$(cxml),"^</block[ >]";
			if (cmp<=0)
			{
				pindex	cmp=$(cxml),"^<next[ >]";
			}
			if (cmp>0)
			{
				break;
			}

			pindex	cmp=$(cxml),"^<[^/]";
			if (cmp>0)
			{
				static : analyze_xml	$(cxml);
				macro	dxml=$(_xml_);
				do_$(dxml);
				strcmp	cmp=$(dxml),"field";
				if (cmp=0)
				{
					mlet	opr=$(do_$(dxml));
				}
				strcmp	cmp=$(dxml),"value";
				if (cmp=0)
				{
					mlet	nval=$(do_$(dxml));
				}
			}
		}
		tolower		opr;

		// operator
		mlet	mne="xxx";
		strcmp	cmp=$(opr),"-";
		if (cmp=0)
		{
			mlet	mne="neg";
		}
		strcmp	cmp=$(opr),"~";
		if (cmp=0)
		{
			mlet	mne=$(str_not);
		}
		strcmp	cmp=$(opr),"!";
		if (cmp)
		{
			strcmp	cmp=$(opr),"!!";
		}
		if (cmp=0)
		{
			mlet	mne="eori";
		}
		strcmp	cmp=$(opr),"sq";
		if (cmp=0)
		{
			mlet	mne="muls";
		}
		strcmp	cmp=$(opr),"1+";
		if (cmp=0)
		{
			mlet	mne="addi";
		}
		strcmp	cmp=$(opr),"-1+";
		if (cmp=0)
		{
			mlet	mne="subi";
		}
		strcmp	cmp=$(opr),"2*";
		if (cmp=0)
		{
			mlet	mne="add";
		}
		strcmp	cmp=$(mne),"xxx";
		if (cmp=0)
		{
			// ERROR:
			errmsg	"mcoc_math_unary: unsupported operator ("$(opr)")";
			leave	stop_error;
		}

		// assembler
		fprint	fout,"// r0=("$(opr)" r0(="$(nval)"))"$,;
		strcmp	cmp=$(opr),"-";
		if (cmp)
		{
			strcmp	cmp=$(opr),"2*";
		}
		if (cmp=0)
		{
			if (opt_opr_typ=opt_int)
			{
				fprint	fout,$(mne)"	r0"$,;
			}
			else
			{
				fprint	fout,"f"$(mne)"	r0,r0"$,;
			}
		}
		strcmp	cmp=$(opr),"~";
		if (cmp=0)
		{
			fprint	fout,$(mne)"	r0"$,;
		}
		strcmp	cmp=$(opr),"!";
		if (cmp)
		{
			strcmp	cmp=$(opr),"!!";
		}
		if (cmp=0)
		{
			fprint	fout,"cmpi	r0,false"$,;
			fprint	fout,"beq	pcnt+2"$,;
			fprint	fout,"ldbiu	r0,true"$,;
			strcmp	cmp=$(opr),"!";
			if (cmp=0)
			{
				fprint	fout,$(mne)"	r0,true"$,;
			}
		}
		strcmp	cmp=$(opr),"sq";
		if (cmp=0)
		{
			if (opt_opr_typ=opt_int)
			{
				fprint	fout,$(mne)"	r0,r0"$,;
				opt_mul_need=true;
			}
			else
			{
				psub	"s$","",mne;
				fprint	fout,"f"$(mne)"	r0,r0"$,;
			}
		}
		strcmp	cmp=$(opr),"1+";
		if (cmp)
		{
			strcmp	cmp=$(opr),"-1+";
		}
		if (cmp=0)
		{
			if (opt_opr_typ=opt_int)
			{
				fprint	fout,$(mne)"	r0,1"$,;
			}
			else
			{
				psub	"i$","",mne;
				fprint	fout,"fld$(z)i	r1,1"$,;
				fprint	fout,"f"$(mne)"	r0,r1"$,;
			}
		}

		index	cmp=$(nval)," ";
		if (cmp>0)
		{
			mlet	nval="("$(nval)")";
		}
		mlet	do_blk_mcoc_math_unary=$(opr)" "$(nval);
	}
	procedure	do_blk_mcoc_math_label
	{
		var		cmp;
		macro	lnam;
		macro	lval;

		while (true)
		{
			fget_xml;
			macro	cxml=$(fget_xml);
			pindex	cmp=$(cxml),"^</block[ >]";
			if (cmp<=0)
			{
				pindex	cmp=$(cxml),"^<next[ >]";
			}
			if (cmp>0)
			{
				break;
			}

			pindex	cmp=$(cxml),"^<[^/]";
			if (cmp>0)
			{
				static : analyze_xml	$(cxml);
				macro	dxml=$(_xml_);
				nmacro	_xml_name;
				macro	dnam=$(_xml_name);
				do_$(dxml);
				strcmp	cmp=$(dxml),"field";
				if (cmp=0)
				{
					strcmp	cmp=$(dnam),"NAME";
					if (cmp=0)
					{
						mlet	lnam=$(do_$(dxml));
					}
					else
					{
						mlet	lval=$(do_$(dxml));
					}
				}
			}
		}
		strcmp	cmp=$(lnam),"";
		if (cmp)
		{
			strcmp	cmp=$(lval),"";
		}
		if (cmp=0)
		{
			// ERROR:
			errmsg	"mcoc_math_label: illegal parameter";
			leave	stop_error;
		}

		// assembler
		fprint	fout,"equ	"$(lnam)","$(lval)$,;
	}
	procedure	do_blk_mcoc_math_number
	{
		var		cmp;
		macro	nval;

		while (true)
		{
			fget_xml;
			macro	cxml=$(fget_xml);
			pindex	cmp=$(cxml),"^</block[ >]";
			if (cmp<=0)
			{
				pindex	cmp=$(cxml),"^<next[ >]";
			}
			if (cmp>0)
			{
				break;
			}

			pindex	cmp=$(cxml),"^<[^/]";
			if (cmp>0)
			{
				static : analyze_xml	$(cxml);
				macro	dxml=$(_xml_);
				strcmp	cmp=$(dxml),"field";
				if (cmp=0)
				{
					fget_xml;
					mlet	nval=$(fget_xml);
					continue;
				}
				do_$(dxml);
			}
		}
		gsub	"&lt;","<",nval;
		mlet	do_blk_mcoc_math_number=$(nval);

		// assembler
		fprint	fout,"// r0="$(nval)$,;
		if (opt_opr_typ=opt_int)
		{
			fprint	fout,"ld$(z)i	r0,"$(nval)$,;
		}
		else
		{
			fprint	fout,"fld$(z)i	r0,"$(nval)$,;
		}

		val_done=true;
	}
	procedure	do_blk_mcoc_math_bit_operation
	{
		var		cmp;
		macro	opr;
		macro	lval;
		macro	rval;
		macro	mne;

		while (true)
		{
			fget_xml;
			macro	cxml=$(fget_xml);
			pindex	cmp=$(cxml),"^</block[ >]";
			if (cmp>0)
			{
				break;
			}

			pindex	cmp=$(cxml),"^<[^/]";
			if (cmp>0)
			{
				static : analyze_xml	$(cxml);
				macro	dxml=$(_xml_);
				nmacro	_xml_name;
				macro	dnam=$(_xml_name);
				do_$(dxml);
				strcmp	cmp=$(dxml),"field";
				if (cmp=0)
				{
					mlet	opr=$(do_$(dxml));
				}
				strcmp	cmp=$(dxml),"value";
				if (cmp=0)
				{
					strcmp	cmp=$(dnam),"data";
					if (cmp)
					{
						strcmp	cmp=$(dnam),"A";
					}
					if (cmp=0)
					{
						mlet	lval=$(do_$(dxml));

						// assembler
						fprint	fout,"push$(z)	r0"$,;
					}
					else
					{
						mlet	rval=$(do_$(dxml));

						// assembler
						fprint	fout,"// r1=r0(="$(rval)"); r0(="$(lval)")"$,;
						fprint	fout,"mov	r1,r0"$,;
						fprint	fout,"pop$(z)	r0"$,;
					}
				}
			}
		}

		// operator
		gsub	"&lt;","<",opr;
		tolower		opr;
		mlet	mne="xxx";
		strcmp	cmp=$(opr),"&";
		if (cmp=0)
		{
			mlet	opr="&";
			mlet	mne=$(str_and);
		}
		strcmp	cmp=$(opr),"|";
		if (cmp=0)
		{
			mlet	mne=$(str_or);
		}
		strcmp	cmp=$(opr),"<<";
		if (cmp=0)
		{
			mlet	opr="<<";
			mlet	mne="asft";
		}
		strcmp	cmp=$(opr),">>";
		if (cmp=0)
		{
			mlet	opr=">>";
			mlet	mne="asft";
		}
		strcmp	cmp=$(opr),"[>>]";
		if (cmp=0)
		{
			mlet	opr="[>>]";
			mlet	mne="lsft";
		}
		strcmp	cmp=$(opr),"^";
		if (cmp=0)
		{
			mlet	mne="eor";
		}

		// error check
		strcmp	cmp=$(mne),"xxx";
		if (cmp=0)
		{
			// ERROR:
			errmsg	"mcoc_math_bit_operation: unsupported operator ("$(opr)")";
			leave	stop_error;
		}

		// assembler
		fprint	fout,"// r0(="$(lval)") "$(opr)" r1(="$(rval)")"$,;
		index	cmp=$(opr),">>";
		if (cmp>0)
		{
			fprint	fout,"neg	r1"$,;
		}
		fprint	fout,$(mne)"	r0,r1"$,;

		index	cmp=$(lval)," ";
		if (cmp>0)
		{
			mlet	lval="("$(lval)")";
		}
		index	cmp=$(rval)," ";
		if (cmp>0)
		{
			mlet	rval="("$(rval)")";
		}
		mlet	do_blk_mcoc_math_bit_operation=$(lval)" "$(opr)" "$(rval);
	}
	procedure	do_blk_mcoc_math_func
	{
		var		cmp;
		macro	func;
		macro	nval;

		while (true)
		{
			fget_xml;
			macro	cxml=$(fget_xml);
			pindex	cmp=$(cxml),"^</block[ >]";
			if (cmp>0)
			{
				break;
			}

			pindex	cmp=$(cxml),"^<[^/]";
			if (cmp>0)
			{
				static : analyze_xml	$(cxml);
				macro	dxml=$(_xml_);
				do_$(dxml);
				strcmp	cmp=$(dxml),"field";
				if (cmp=0)
				{
					mlet	func=$(do_$(dxml));
				}
				strcmp	cmp=$(dxml),"value";
				if (cmp=0)
				{
					mlet	nval=$(do_$(dxml));
				}
			}
		}
		tolower		func;

		// assembler
		fprint	fout,"// r0="$(func)" (r0(="$(nval)"))"$,;

		// function
		strcmp	cmp=$(func),"abs";
		if (cmp=0)
		{
			// assembler
			if (opt_opr_typ=opt_int)
			{
				fprint	fout,"cmpi	r0,0"$,;
				fprint	fout,"bge	pcnt+2"$,;
				fprint	fout,"neg	r0"$,;
			}
			else
			{
				fprint	fout,"ldbiu	r1,0"$,;
				fprint	fout,"fmvsg	r0,r1"$,;
			}
		}
		strcmp	cmp=$(func),"rand";
		if (cmp=0)
		{
			// assembler
			strcmp	cmp=$(nval),"";
			if (cmp)
			{
				fprint	fout,"mov	r3,r0"$,;
			}
			fprint	fout,"// r0=_rand"$,;
			fprint	fout,"jal$(z)r7	_rand"$,;
			if (cmp)
			{
				fprint	fout,"// r0=r0(=_rand) % r3(="$(nval)")"$,;
				fprint	fout,"cmpi	r3,0"$,;
				fprint	fout,"beq	pcnt+4"$,;
				fprint	fout,"divur	r0,r3"$,;
				fprint	fout,"mov	r0,r3"$,;

				opt_div_need=true;
			}
			opt_mul_need=true;
		}
		strcmp	cmp=$(func),"rseed";
		if (cmp=0)
		{
			// assembler
			asm_ld_var_adr	"r7","_rtlb_rand_seed";
			fprint	fout,"st$(z)	[r7],r0"$,;
		}
		strcmp	cmp=$(func),"floor";
		if (cmp=0)
		{
			// assembler
			fprint	fout,"fdown	r1,r0"$,;
			fprint	fout,"fcmp	r0,r1"$,;
			fprint	fout,"fld$(z)i	r0,1"$,;	// to suppress slabid
			fprint	fout,"bge	pcnt+2"$,;
			fprint	fout,"fsub	r1,r0"$,;
			fprint	fout,"mov	r0,r1"$,;
		}
		strcmp	cmp=$(func),"ceil";
		if (cmp=0)
		{
			// assembler
			fprint	fout,"fdown	r1,r0"$,;
			fprint	fout,"fcmp	r1,r0"$,;
			fprint	fout,"fld$(z)i	r0,1"$,;	// to suppress slabid
			fprint	fout,"bge	pcnt+2"$,;
			fprint	fout,"fadd	r1,r0"$,;
			fprint	fout,"mov	r0,r1"$,;
		}
		strcmp	cmp=$(func),"round";
		if (cmp=0)
		{
			// assembler
			fprint	fout,"mov	r2,r0"$,;
			fprint	fout,"fld$(z)i	r1,0.5"$,;
			fprint	fout,"fmvsg	r0,r1"$,;
			fprint	fout,"fadd	r0,r1"$,;
			fprint	fout,"fdown	r0,r0"$,;
			fprint	fout,"fmvsg	r0,r2"$,;
		}

		// other mathematical functions
		macro	mfnc=
				"sqrt    "
				"exp     "
				"log     "
				"log10   "
				"log2    "
				"sin     "
				"cos     "
				"tan     "
				"asin    "
				"acos    "
				"atan    ";
		index	cmp=$(mfnc),$(func)" ";
		if (cmp>0 & (cmp - 1)%8=0)
		{
			need_math=true;
			opt_fpu_need=true;
			
			// assembler
			fprint	fout,"jal$(z)r7	_math_"$(func)$,;
		}

		mlet	do_blk_mcoc_math_func=$(func)" ("$(nval)")";
	}
	procedure	do_blk_mcoc_math_func2
	{
		do_blk_mcoc_math_func;
		mlet	do_blk_mcoc_math_func2=$(do_blk_mcoc_math_func);
	}
	procedure	do_blk_mcoc_math_func3
	{
		do_blk_mcoc_math_func;
		mlet	do_blk_mcoc_math_func3=$(do_blk_mcoc_math_func);
	}
	procedure	do_blk_mcoc_math_binary
	{
		var		cmp;
		macro	opr;
		macro	lval;
		macro	rval;

		while (true)
		{
			fget_xml;
			macro	cxml=$(fget_xml);
			pindex	cmp=$(cxml),"^</block[ >]";
			if (cmp>0)
			{
				break;
			}

			pindex	cmp=$(cxml),"^<[^/]";
			if (cmp>0)
			{
				static : analyze_xml	$(cxml);
				macro	dxml=$(_xml_);
				nmacro	_xml_name;
				macro	dnam=$(_xml_name);
				do_$(dxml);
				strcmp	cmp=$(dxml),"field";
				if (cmp=0)
				{
					mlet	opr=$(do_$(dxml));
				}
				strcmp	cmp=$(dxml),"value";
				if (cmp=0)
				{
					strcmp	cmp=$(dnam),"data";
					if (cmp)
					{
						strcmp	cmp=$(dnam),"A";
					}
					if (cmp=0)
					{
						mlet	lval=$(do_$(dxml));

						// assembler
						fprint	fout,"push$(z)	r0"$,;
					}
					else
					{
						mlet	rval=$(do_$(dxml));

						// assembler
						fprint	fout,"// r1=r0(="$(rval)"); r0(="$(lval)")"$,;
						fprint	fout,"mov	r1,r0"$,;
						fprint	fout,"pop$(z)	r0"$,;
					}
				}
			}
		}
		need_math=true;
		tolower		opr;

		// assembler
		fprint	fout,"// r0=r0(="$(lval)") "$(opr)" r1(="$(rval)")"$,;
		strcmp	cmp=$(opr),"**";
		if (cmp=0)
		{
			if (opt_opr_typ!=opt_float)
			{
				// ERROR:
				errmsg	"mcoc_math_binary: "
						"power operator (**) must be @float@.";
				leave	stop_error;
			}

			// power operator
			fprint	fout,"jal$(z)r7	_math_pow"$,;
		}
		strcmp	cmp=$(opr),"max";
		if (cmp)
		{
			strcmp	cmp=$(opr),"min";
		}
		if (cmp=0)
		{
			// minimum / maximum operator
			macro	fi;
			if (opt_opr_typ=opt_float)
			{
				mlet	fi="f";
			}
			macro	mne="bge";
			strcmp	cmp=$(opr),"min";
			if (cmp=0)
			{
				mlet	mne="blt";
			}
			fprint	fout,$(fi)"cmp	r0,r1"$,;
			fprint	fout,$(mne)"	pcnt+2"$,;
			fprint	fout,"mov	r0,r1"$,;
		}

		index	cmp=$(lval)," ";
		if (cmp>0)
		{
			mlet	lval="("$(lval)")";
		}
		index	cmp=$(rval)," ";
		if (cmp>0)
		{
			mlet	rval="("$(rval)")";
		}
		mlet	do_blk_mcoc_math_binary=$(lval)" "$(opr)" "$(rval);
	}
	procedure	do_blk_mcoc_pack
	{
		var		cmp;
		var		stat;
		var		cnts;
		macro	enbl;

		while (true)
		{
			fget_xml;
			macro	cxml=$(fget_xml);
			if (stat=0)
			{
				pindex	cmp=$(cxml),"^<statement[ >]";
				if (cmp<=0)
				{
					pindex	cmp=$(cxml),"^<next[ >]";
				}
				if (cmp<=0)
				{
					pindex	cmp=$(cxml),"^</block[ >]";
				}
				if (cmp>0)
				{
					// continue
					pindex	cmp=$(cxml),"^<statement[ >]";
					if (cmp>0)
					{
						// pack
						strcmp	cmp=$(enbl),"true";
						if (cmp=0)
						{
							stat=1;
						}
						else
						{
							stat=3;
						}
						continue;
					}
					else
					{
						// empty block
						stat=2;
						mlet	enbl="false";
					}
				}
			}
			if (stat=1 | stat=3)
			{
				// pack block
				pindex	cmp=$(cxml),"^</statement[ >]";
				if (cmp>0)
				{
					// end of statement
					if (cnts>0)
					{
						cnts=cnts - 1;
						continue;
					}

					// end of pack
					stat=2;
					continue;
				}
				if (stat=3)
				{
					// disabled pack
					pindex	cmp=$(cxml),"^<statement[ >]";
					if (cmp>0)
					{
						cnts=cnts + 1;
						continue;
					}
					continue;
				}
			}
			if (stat=2)
			{
				pindex	cmp=$(cxml),"^<next[ >]";
				if (cmp<=0)
				{
					pindex	cmp=$(cxml),"^</block[ >]";
				}
				if (cmp>0)
				{
					// end of pack
					break;
				}
			}

			pindex	cmp=$(cxml),"^<[^/]";
			if (cmp>0)
			{
				static : analyze_xml	$(cxml);
				macro	dxml=$(_xml_);
				do_$(dxml);
				if (stat=0)
				{
					strcmp	cmp=$(dxml),"field";
					if (cmp=0)
					{
						mlet	enbl=$(do_$(dxml));
						tolower		enbl;
					}
				}
			}
		}
	}
	procedure	do_blk_mcoc_swap
	{
		var		cmp;
		macro	vnam1;
		macro	vnam2;

		while (true)
		{
			fget_xml;
			macro	cxml=$(fget_xml);
			pindex	cmp=$(cxml),"^</block[ >]";
			if (cmp<=0)
			{
				pindex	cmp=$(cxml),"^<next[ >]";
			}
			if (cmp>0)
			{
				break;
			}

			pindex	cmp=$(cxml),"^<[^/]";
			if (cmp>0)
			{
				static : analyze_xml	$(cxml);
				macro	dxml=$(_xml_);
				nmacro	_xml_name;
				macro	dnam=$(_xml_name);
				do_$(dxml);
				strcmp	cmp=$(dxml),"field";
				if (cmp=0)
				{
					strcmp	cmp=$(dnam),"A";
					if (cmp=0)
					{
						mlet	vnam1=$(do_$(dxml));
					}
					else
					{
						mlet	vnam2=$(do_$(dxml));
					}
				}
			}
		}

		// check
		is_cstr		$(vnam1);
		var		vnam1_cstr=is_cstr;
		is_cstr		$(vnam2);
		var		vnam2_cstr=is_cstr;
		if (@(vnam1_cstr ^ vnam2_cstr))
		{
			// ERROR:
			errmsg	"mcoc_swap: swap number and string variables"
					$,"	"$(vnam1)" and "$(vnam2);
			leave	stop_error;
		}

		// assembler
		fprint	fout,"// swap "$(vnam1)" and "$(vnam2)$,;
		asm_ld_var_adr	"r0",$(vnam1);
		asm_ld_var_adr	"r1",$(vnam2);
		fprint	fout,"ld$(z)	r2,[r0]"$,;
		fprint	fout,"ld$(z)	r3,[r1]"$,;
		fprint	fout,"st$(z)	[r0],r3"$,;
		fprint	fout,"st$(z)	[r1],r2"$,;
	}
	procedure	do_blk_mcoc_task
	{
		var		cmp;
		var		stat;
		macro	tskf;

		// assembler
		if (defp_1st)
		{
			defp_1st=false;
			fprint	fout,""$,;
			fprint	fout,"// halt"$,;
			fprint	fout,"jmpr7	_rtlb_prog_halt"$,;
		}

		while (true)
		{
			fget_xml;
			macro	cxml=$(fget_xml);
			if (stat=0)
			{
				pindex	cmp=$(cxml),"^<statement[ >]";
				if (cmp<=0)
				{
					pindex	cmp=$(cxml),"^<next[ >]";
				}
				if (cmp<=0)
				{
					pindex	cmp=$(cxml),"^</block[ >]";
				}
				if (cmp>0)
				{
					// continue
					pindex	cmp=$(cxml),"^<statement[ >]";
					if (cmp>0)
					{
						// task
						stat=1;

						// assembler
						fprint	fout,""$,;
						fprint	fout,"// task "$(tskf)$,;
						fprint	fout,"align	4"$,;
						fprint	fout,"_rtlb_task_"$(tskf)":"$,;

						continue;
					}
					else
					{
						// empty block
						stat=2;

						// ERROR:
						errmsg	"mcoc_task: inhibited empty block.";
						leave	stop_error;
					}
				}
			}
			if (stat=1)
			{
				// task block
				pindex	cmp=$(cxml),"^</statement[ >]";
				if (cmp>0)
				{
					// end of statement

					// assembler
					fprint	fout,"// end of task"$,;
					fprint	fout,"rtn$(z)"$,;

					// end of task
					stat=2;
					continue;
				}
			}
			if (stat=2)
			{
				pindex	cmp=$(cxml),"^<next[ >]";
				if (cmp<=0)
				{
					pindex	cmp=$(cxml),"^</block[ >]";
				}
				if (cmp>0)
				{
					// end of task
					break;
				}
			}

			pindex	cmp=$(cxml),"^<[^/]";
			if (cmp>0)
			{
				static : analyze_xml	$(cxml);
				macro	dxml=$(_xml_);
				do_$(dxml);
				if (stat=0)
				{
					strcmp	cmp=$(dxml),"field";
					if (cmp=0)
					{
						mlet	tskf=$(do_$(dxml));
						tolower		tskf;
						if (tsk_def_$(tskf))
						{
							// ERROR:
							errmsg	"mcoc_task: re-defined task "$(tskf);
							leave	stop_error;
						}
						tsk_def_$(tskf)=true;
					}
				}
			}
		}
	}
	procedure	do_blk_mcoc_text_itoa
	{
		var		cmp;
		macro	nval;

		if (!in_var_set)
		{
			register_vars	"_tmp_str";
			register_cstr	"_tmp_str";

			// assembler
			asm_ld_var	"r0","_tmp_str";
			fprint	fout,"push$(z) r0"$,;
		}

		while (true)
		{
			var		in_var_set=true;

			fget_xml;
			macro	cxml=$(fget_xml);
			pindex	cmp=$(cxml),"^</block[ >]";
			if (cmp>0)
			{
				break;
			}

			pindex	cmp=$(cxml),"^<[^/]";
			if (cmp>0)
			{
				static : analyze_xml	$(cxml);
				macro	dxml=$(_xml_);
				do_$(dxml);
				strcmp	cmp=$(dxml),"value";
				if (cmp=0)
				{
					mlet	nval=$(do_$(dxml));
				}
			}
		}
		mlet	do_blk_mcoc_text_itoa="'"$(nval)"'";

		// assembler
		fprint	fout,"// r1=r0(="$(nval)")"$,;
		fprint	fout,"mov	r1,r0"$,;
		fprint	fout,"// r0=strdec (r0,r1(="$(nval)"))"$,;
		fprint	fout,"pop$(z)	r0"$,;
		fprint	fout,"jal$(z)r7	_strdec_r0_r1"$,;
		fprint	fout,"push$(z)	r0"$,;
		if (!in_var_set)
		{
			asm_ld_var	"r1","_tmp_str";
			fprint	fout,"pop$(z) r0	// discard"$,;
		}
	}
	procedure	do_blk_mcoc_text_itox
	{
		var		cmp;
		macro	nval;
		macro	ndig;

		if (!in_var_set)
		{
			register_vars	"_tmp_str";
			register_cstr	"_tmp_str";

			// assembler
			asm_ld_var	"r0","_tmp_str";
			fprint	fout,"push$(z)	r0"$,;
		}

		while (true)
		{
			var		in_var_set=true;

			fget_xml;
			macro	cxml=$(fget_xml);
			pindex	cmp=$(cxml),"^</block[ >]";
			if (cmp>0)
			{
				break;
			}

			pindex	cmp=$(cxml),"^<[^/]";
			if (cmp>0)
			{
				static : analyze_xml	$(cxml);
				macro	dxml=$(_xml_);
				do_$(dxml);
				strcmp	cmp=$(dxml),"field";
				if (cmp=0)
				{
					mlet	ndig=$(do_$(dxml));

					// assembler
					fprint	fout,"// r2="$(ndig)$,;
					fprint	fout,"ld$(z)i	r2,"$(ndig)$,;
				}
				strcmp	cmp=$(dxml),"value";
				if (cmp=0)
				{
					mlet	nval=$(do_$(dxml));
				}
			}
		}
		mlet	do_blk_mcoc_text_itox="'"$(nval)"'";

		// assembler
		fprint	fout,"// r1=r0(="$(nval)")"$,;
		fprint	fout,"mov	r1,r0"$,;
		fprint	fout,"// r0=strhex (r0,r1(="$(nval)"),r2(="$(ndig)"))"$,;
		fprint	fout,"pop$(z)	r0"$,;
		fprint	fout,"jal$(z)r7	_strhex_r0_r1_r2"$,;
		fprint	fout,"push$(z)	r0"$,;
		if (!in_var_set)
		{
			asm_ld_var	"r1","_tmp_str";
			fprint	fout,"pop$(z) r0	// discard"$,;
		}
	}
	procedure	do_blk_mcoc_text_atoi
	{
		var		cmp;
		macro	cstr;

		while (true)
		{
			var		in_var_set=false;

			fget_xml;
			macro	cxml=$(fget_xml);
			pindex	cmp=$(cxml),"^</block[ >]";
			if (cmp>0)
			{
				break;
			}

			pindex	cmp=$(cxml),"^<[^/]";
			if (cmp>0)
			{
				static : analyze_xml	$(cxml);
				macro	dxml=$(_xml_);
				do_$(dxml);
				strcmp	cmp=$(dxml),"value";
				if (cmp=0)
				{
					mlet	cstr=$(do_$(dxml));
				}
			}
		}
		mlet	do_blk_mcoc_text_atoi="atoi ("$(cstr)")";

		// assembler
		fprint	fout,"// r0=atoi (r1(="$(cstr)"))"$,;
		fprint	fout,"jal$(z)r7	_atoi_r1"$,;
	}
	procedure	do_blk_mcoc_text_xtoi
	{
		var		cmp;
		macro	cstr;

		while (true)
		{
			var		in_var_set=false;

			fget_xml;
			macro	cxml=$(fget_xml);
			pindex	cmp=$(cxml),"^</block[ >]";
			if (cmp>0)
			{
				break;
			}

			pindex	cmp=$(cxml),"^<[^/]";
			if (cmp>0)
			{
				static : analyze_xml	$(cxml);
				macro	dxml=$(_xml_);
				do_$(dxml);
				strcmp	cmp=$(dxml),"value";
				if (cmp=0)
				{
					mlet	cstr=$(do_$(dxml));
				}
			}
		}
		mlet	do_blk_mcoc_text_xtoi="xtoi ("$(cstr)")";

		// assembler
		fprint	fout,"// r0=xtoi (r1(="$(cstr)"))"$,;
		fprint	fout,"jal$(z)r7	_xtoi_r1"$,;
	}
	procedure	do_blk_mcoc_string_compare_left
	{
		var		cmp;
		macro	vstr;
		macro	ofst;
		macro	cstr;

		while (true)
		{
			fget_xml;
			macro	cxml=$(fget_xml);
			pindex	cmp=$(cxml),"^</block[ >]";
			if (cmp>0)
			{
				break;
			}

			pindex	cmp=$(cxml),"^<[^/]";
			if (cmp>0)
			{
				static : analyze_xml	$(cxml);
				macro	dxml=$(_xml_);
				nmacro	_xml_name;
				macro	dnam=$(_xml_name);
				do_$(dxml);
				strcmp	cmp=$(dxml),"field";
				if (cmp=0)
				{
					mlet	vstr=$(do_$(dxml));
					is_cstr		$(vstr);
					if (!is_cstr)
					{
						// ERROR:
						errmsg	"mcoc_string_compare_left: "
								"not a string variable ("$(vstr)")";
						leave	stop_error;
					}
				}
				strcmp	cmp=$(dxml),"value";
				if (cmp=0)
				{
					strcmp	cmp=$(dnam),"OFST";
					if (cmp=0)
					{
						mlet	ofst=$(do_$(dxml));

						// assembler
						fprint	fout,"push$(z)	r0"$,;
					}
					else
					{
						mlet	cstr=$(do_$(dxml));
					}
				}
			}
		}
		mlet	do_blk_mcoc_string_compare_left="left ("$(vstr)" + "
				$(ofst)")="$(cstr);

		// assembler
		fprint	fout,"// r3=r1(="$(cstr)")"$,;
		fprint	fout,"mov	r3,r1"$,;
		asm_ld_var	"r1",$(vstr);
		fprint	fout,"// r1(="$(vstr)") += r0(="$(ofst)")"$,;
		fprint	fout,"pop$(z)	r0"$,;
		fprint	fout,"jal$(z)r7	_strofst_r1_r0"$,;
		fprint	fout,"// r2=r3(="$(cstr)")"$,;
		fprint	fout,"mov	r2,r3"$,;
		fprint	fout,"// compare left (r1(="$(vstr)" + "$(ofst)")) = r2(="
				$(cstr)")"$,;
		fprint	fout,"jal$(z)r7	_strfcmp_r1_r2"$,;
		fprint	fout,"cmpi	r0,0"$,;
		fprint	fout,"ldbiu	r0,true"$,;
		fprint	fout,"beq	pcnt+2"$,;
		fprint	fout,"ldbiu	r0,false"$,;
	}
	procedure	do_blk_mcoc_string_ctoa
	{
		var		cmp;
		macro	cchr;

		if (!in_var_set)
		{
			register_vars	"_tmp_str";
			register_cstr	"_tmp_str";

			// assembler
			asm_ld_var	"r0","_tmp_str";
			fprint	fout,"push$(z) r0"$,;
		}

		while (true)
		{
			var		in_var_set=true;

			fget_xml;
			macro	cxml=$(fget_xml);
			pindex	cmp=$(cxml),"^</block[ >]";
			if (cmp>0)
			{
				break;
			}

			pindex	cmp=$(cxml),"^<[^/]";
			if (cmp>0)
			{
				static : analyze_xml	$(cxml);
				macro	dxml=$(_xml_);
				do_$(dxml);
				strcmp	cmp=$(dxml),"value";
				if (cmp=0)
				{
					mlet	cchr=$(do_$(dxml));
				}
			}
		}
		mlet	do_blk_mcoc_string_ctoa="'"$(cchr)"'";

		// assembler
		fprint	fout,"// r1=r0(="$(cchr)")"$,;
		fprint	fout,"mov	r1,r0"$,;
		fprint	fout,"pop$(z)	r0"$,;
		fprint	fout,"// ctoa [r0++]=r1(="$(cchr)") ++ '\0'"$,;
		fprint	fout,"// 2 bytes code?"$,;
		fprint	fout,"mov	r2,r1"$,;
		fprint	fout,"lsri	r2,8"$,;
		fprint	fout,"beq	pcnt+4"$,;
		fprint	fout,"stb	[r0],r2"$,;
		fprint	fout,"addi	r0,1"$,;
		fprint	fout,"// 1 byte code"$,;
		fprint	fout,"stb	[r0],r1"$,;
		fprint	fout,"addi	r0,1"$,;
		fprint	fout,"ldbiu	r1,0"$,;
		fprint	fout,"stb	[r0],r1"$,;
		fprint	fout,"push$(z)	r0"$,;
		if (!in_var_set)
		{
			asm_ld_var	"r1","_tmp_str";
			fprint	fout,"pop$(z) r0	// discard"$,;
		}
	}
	procedure	do_blk_mcoc_string_find
	{
		var		cmp;
		macro	vstr;
		macro	ofst;
		macro	cchr;

		while (true)
		{
			fget_xml;
			macro	cxml=$(fget_xml);
			pindex	cmp=$(cxml),"^</block[ >]";
			if (cmp>0)
			{
				break;
			}

			pindex	cmp=$(cxml),"^<[^/]";
			if (cmp>0)
			{
				static : analyze_xml	$(cxml);
				macro	dxml=$(_xml_);
				nmacro	_xml_name;
				macro	dnam=$(_xml_name);
				do_$(dxml);
				strcmp	cmp=$(dxml),"field";
				if (cmp=0)
				{
					mlet	vstr=$(do_$(dxml));
					is_cstr		$(vstr);
					if (!is_cstr)
					{
						// ERROR:
						errmsg	"mcoc_string_find: "
								"not a string variable ("$(vstr)")";
						leave	stop_error;
					}
				}
				strcmp	cmp=$(dxml),"value";
				if (cmp=0)
				{
					strcmp	cmp=$(dnam),"OFST";
					if (cmp=0)
					{
						mlet	ofst=$(do_$(dxml));

						// assembler
						fprint	fout,"push$(z)	r0"$,;
					}
					else
					{
						mlet	cchr=$(do_$(dxml));
					}
				}
			}
		}
		mlet	do_blk_mcoc_string_find="strchr ("$(vstr)" + "$(ofst)","
				$(cchr)")";

		// assembler
		fprint	fout,"// r3=r0(="$(cchr)"), r0="$(ofst)$,;
		fprint	fout,"mov	r3,r0"$,;
		fprint	fout,"pop$(z)	r0"$,;
		asm_ld_var	"r1",$(vstr);
		fprint	fout,"// r4=r1(="$(vstr)")"$,;
		fprint	fout,"mov	r4,r1"$,;
		fprint	fout,"// r1(="$(vstr)") += r0(="$(ofst)")"$,;
		fprint	fout,"jal$(z)r7	_strofst_r1_r0"$,;
		fprint	fout,"// r0=r1(="$(vstr)" + "$(ofst)")"$,;
		fprint	fout,"mov	r0,r1"$,;
		fprint	fout,"// r4=r1(="$(vstr)" + "$(ofst)") - r4(="$(vstr)")"$,;
		fprint	fout,"sub	r1,r4"$,;
		fprint	fout,"mov	r4,r1"$,;
		fprint	fout,"// r1=r3(="$(cchr)")"$,;
		fprint	fout,"mov	r1,r3"$,;
		fprint	fout,"// find in r0(="$(vstr)" + "$(ofst)"), r1(="$(cchr)")"$,;
		fprint	fout,"jal$(z)r7	_strchr_r0_r1"$,;
		fprint	fout,"// r0 += r4(=offset from "$(vstr)")"$,;
		fprint	fout,"cmpi	r0,0"$,;
		fprint	fout,"blt	pcnt+2"$,;
		fprint	fout,"add	r0,r4"$,;
	}
	procedure	do_blk_mcoc_string_get_char
	{
		var		cmp;
		macro	vstr;
		macro	ofst;

		while (true)
		{
			fget_xml;
			macro	cxml=$(fget_xml);
			pindex	cmp=$(cxml),"^</block[ >]";
			if (cmp>0)
			{
				break;
			}

			pindex	cmp=$(cxml),"^<[^/]";
			if (cmp>0)
			{
				static : analyze_xml	$(cxml);
				macro	dxml=$(_xml_);
				do_$(dxml);
				strcmp	cmp=$(dxml),"field";
				if (cmp=0)
				{
					mlet	vstr=$(do_$(dxml));
					is_cstr		$(vstr);
					if (!is_cstr)
					{
						// ERROR:
						errmsg	"mcoc_string_get_char: "
								"not a string variable ("$(vstr)")";
						leave	stop_error;
					}
				}
				strcmp	cmp=$(dxml),"value";
				if (cmp=0)
				{
					mlet	ofst=$(do_$(dxml));
				}
			}
		}
		mlet	do_blk_mcoc_string_get_char="["$(vstr)" + "$(ofst)"]";

		// assembler
		asm_ld_var	"r1",$(vstr);
		fprint	fout,"// r1(="$(vstr)") += r0(="$(ofst)")"$,;
		fprint	fout,"jal$(z)r7	_strofst_r1_r0"$,;
		fprint	fout,"// get char r0=[r1(="$(vstr)" + "$(ofst)")]"$,;
		fprint	fout,"jal$(z)r7	_chrsjis_r1"$,;
	}
	procedure	do_blk_mcoc_string_label
	{
		var		cmp;
		macro	lnam;
		macro	ofst;

		while (true)
		{
			fget_xml;
			macro	cxml=$(fget_xml);
			pindex	cmp=$(cxml),"^</block[ >]";
			if (cmp>0)
			{
				break;
			}

			pindex	cmp=$(cxml),"^<[^/]";
			if (cmp>0)
			{
				static : analyze_xml	$(cxml);
				macro	dxml=$(_xml_);
				do_$(dxml);
				strcmp	cmp=$(dxml),"field";
				if (cmp=0)
				{
					mlet	lnam=$(do_$(dxml));
				}
				strcmp	cmp=$(dxml),"value";
				if (cmp=0)
				{
					mlet	ofst=$(do_$(dxml));
				}
			}
		}
		mlet	do_blk_mcoc_string_label=$"$(lnam)" + "$(ofst)$";

		// assembler
		fprint	fout,"// r1="$(lnam)$,;
		fprint	fout,"ldwi	r1,"$(lnam)$,;
		fprint	fout,"// r1(="$(lnam)") += r0(="$(ofst)")"$,;
		fprint	fout,"jal$(z)r7	_strofst_r1_r0"$,;
	}
	procedure	do_blk_mcoc_string_pointer
	{
		var		cmp;
		macro	vstr;
		macro	ofst;

		while (true)
		{
			fget_xml;
			macro	cxml=$(fget_xml);
			pindex	cmp=$(cxml),"^</block[ >]";
			if (cmp>0)
			{
				break;
			}

			pindex	cmp=$(cxml),"^<[^/]";
			if (cmp>0)
			{
				static : analyze_xml	$(cxml);
				macro	dxml=$(_xml_);
				do_$(dxml);
				strcmp	cmp=$(dxml),"field";
				if (cmp=0)
				{
					mlet	vstr=$(do_$(dxml));
					is_cstr		$(vstr);
					if (!is_cstr)
					{
						// ERROR:
						errmsg	"mcoc_string_pointer: "
								"not a string variable ("$(vstr)")";
						leave	stop_error;
					}
				}
				strcmp	cmp=$(dxml),"value";
				if (cmp=0)
				{
					mlet	ofst=$(do_$(dxml));
				}
			}
		}
		mlet	do_blk_mcoc_string_pointer=$"$(vstr)" + "$(ofst)$";

		// assembler
		asm_ld_var	"r1",$(vstr);
		fprint	fout,"// r1(="$(vstr)") += r0(="$(ofst)")"$,;
		fprint	fout,"jal$(z)r7	_strofst_r1_r0"$,;
	}
	procedure	do_blk_mcoc_string_set
	{
		var		cmp;
		macro	vstr;
		macro	ofst;
		macro	cstr;

		in_var_set=true;
		while (true)
		{
			fget_xml;
			macro	cxml=$(fget_xml);
			pindex	cmp=$(cxml),"^</block[ >]";
			if (cmp<=0)
			{
				pindex	cmp=$(cxml),"^<next[ >]";
			}
			if (cmp>0)
			{
				break;
			}

			pindex	cmp=$(cxml),"^<[^/]";
			if (cmp>0)
			{
				static : analyze_xml	$(cxml);
				macro	dxml=$(_xml_);
				nmacro	_xml_name;
				macro	dnam=$(_xml_name);
				do_$(dxml);
				strcmp	cmp=$(dxml),"field";
				if (cmp=0)
				{
					mlet	vstr=$(do_$(dxml));
					is_cstr		$(vstr);
					if (!is_cstr)
					{
						// ERROR:
						errmsg	"mcoc_string_set: "
								"not a string variable ("$(vstr)")";
						leave	stop_error;
					}
				}
				strcmp	cmp=$(dxml),"value";
				if (cmp=0)
				{
					strcmp	cmp=$(dnam),"VAL";
					if (cmp=0)
					{
						mlet	ofst=$(do_$(dxml));

						// assembler
						asm_ld_var	"r1",$(vstr);
						fprint	fout,"// r1(="$(vstr)") += r0(="$(ofst)")"$,;
						fprint	fout,"jal$(z)r7	_strofst_r1_r0"$,;
						fprint	fout,"// r0=r1(="$(vstr)" + "$(ofst)")"$,;
						fprint	fout,"mov	r0,r1"$,;
						fprint	fout,"push$(z)	r0"$,;
					}
					else
					{
						mlet	cstr=$(do_$(dxml));
					}
				}
			}
		}
		in_var_set=false;

		// assembler
		fprint	fout,"// end of "$(vstr)" + "$(ofst)"="$(cstr)$,;

		// string variable = <string>
		strcmp	cmp=$(cstr),"'", left;
		if (cmp=0)
		{
			// already processed (number ==> string)

			// assembler
			fprint	fout,"pop$(z)	r0	// discard"$,;
		}
		else
		{
			strcmp	cmp=$(cstr)," ++ ",left;
			if (cmp=0)
			{
				// joined
				psub	"^ \+\+ ","",cstr;

				// assembler
				fprint	fout,"pop$(z)	r0	// discard"$,;
			}
			else
			{
				// not joined
				pindex	cmp=$(cstr),"^"$""[^"$""]*"$""$";
				if (cmp<=0)
				{
					// not a string constant
					is_cstr		$(cstr);
					if (is_cstr)
					{
						// string variable
						cmp=1;
					}
				}
				if (cmp>0)
				{
					// string constant or string variable

					// assembler
					fprint	fout,"pop$(z)	r0"$,;
					fprint	fout,"jal$(z)r7	_strcpy_r0_r1"$,;
				}
				else
				{
					// number

					// assembler
					fprint	fout,"// r1=r0(="$(cstr)")"$,;
					fprint	fout,"mov	r1,r0"$,;
					fprint	fout,"// r0=strdec (r0,r1(="$(cstr)"))"$,;
					fprint	fout,"pop$(z)	r0"$,;
					fprint	fout,"jal$(z)r7	_strdec_r0_r1"$,;
				}
			}
		}
	}
	procedure	do_blk_mcoc_sytm_delay
	{
		do_blk_delay_custom;
	}
	procedure	do_blk_mcoc_sytm_delay_us
	{
		do_blk_delayMicroseconds_custom;
	}
	procedure	do_blk_mcoc_sytm_delay_cyc
	{
		var		cmp;
		macro	nval;

		while (true)
		{
			fget_xml;
			macro	cxml=$(fget_xml);
			pindex	cmp=$(cxml),"^</block[ >]";
			if (cmp<=0)
			{
				pindex	cmp=$(cxml),"^<next[ >]";
			}
			if (cmp>0)
			{
				break;
			}

			pindex	cmp=$(cxml),"^<[^/]";
			if (cmp>0)
			{
				static : analyze_xml	$(cxml);
				macro	dxml=$(_xml_);
				do_$(dxml);
				strcmp	cmp=$(dxml),"value";
				if (cmp=0)
				{
					mlet	nval=$(do_$(dxml));
				}
			}
		}

		// assembler
		fprint	fout,"// delayTicks (r0(="$(nval)"))"$,;
		fprint	fout,"_delay_cyc_r0"$,;
	}
	procedure	do_blk_mcoc_sytm_ticks
	{
		// assembler
		fprint	fout,"// r0=ticks"$,;
		fprint	fout,"ldwi	r7,_rtlb_sytmtck$(z)"$,;
		fprint	fout,"ld$(z)	r0,[r7]"$,;

		skip_one	"block";
		mlet	do_blk_mcoc_sytm_ticks="ticks";
	}
	procedure	do_blk_mcoc_sytm_micros
	{
		// assembler
		fprint	fout,"// r0=micros"$,;
		fprint	fout,"ldwi	r7,_rtlb_sytmmcr$(z)"$,;
		fprint	fout,"ld$(z)	r0,[r7]"$,;

		skip_one	"block";
		mlet	do_blk_mcoc_sytm_micros="micros";
	}
	procedure	do_blk_mcoc_sytm_millis
	{
		// assembler
		fprint	fout,"// r0=millis"$,;
		fprint	fout,"ldwi	r7,_rtlb_sytmmil$(z)"$,;
		fprint	fout,"ld$(z)	r0,[r7]"$,;

		skip_one	"block";
		mlet	do_blk_mcoc_sytm_millis="millis";
	}
	procedure	do_blk_mcoc_uart_print
	{
		do_blk_text_print;
	}
	procedure	do_blk_mcoc_uart_println
	{
		do_blk_text_print;

		// assembler
		fprint	fout,"jal$(z)r7	_print_crlf"$,;
	}
	procedure	do_blk_mcoc_uart_getline
	{
		var		cmp;

		if (!in_var_set)
		{
			register_vars	"_tmp_str";
			register_cstr	"_tmp_str";

			// assembler
			asm_ld_var	"r0","_tmp_str";
		}

		while (true)
		{
			var		in_var_set=true;

			fget_xml;
			macro	cxml=$(fget_xml);
			pindex	cmp=$(cxml),"^</block[ >]";
			if (cmp<=0)
			{
				pindex	cmp=$(cxml),"^<next[ >]";
			}
			if (cmp>0)
			{
				break;
			}

			pindex	cmp=$(cxml),"^<[^/]";
			if (cmp>0)
			{
				static : analyze_xml	$(cxml);
				macro	dxml=$(_xml_);
				do_$(dxml);
			}
		}
		mlet	do_blk_mcoc_uart_getline="'getline'";

		// assembler
		fprint	fout,"// r0,r1=getline (r0)"$,;
		fprint	fout,"jal$(z)r7	_getline_r0"$,;
	}
	procedure	do_blk_mcoc_uart_avail
	{
		var		cmp;

		while (true)
		{
			fget_xml;
			macro	cxml=$(fget_xml);
			pindex	cmp=$(cxml),"^</block[ >]";
			if (cmp<=0)
			{
				pindex	cmp=$(cxml),"^<next[ >]";
			}
			if (cmp>0)
			{
				break;
			}

			pindex	cmp=$(cxml),"^<[^/]";
			if (cmp>0)
			{
				static : analyze_xml	$(cxml);
				macro	dxml=$(_xml_);
				do_$(dxml);
			}
		}
		mlet	do_blk_mcoc_uart_avail="uart_avail";

		// assembler
		fprint	fout,"// r0=uart_avail"$,;
		fprint	fout,"ldwi	r7,uartctl"$,;
		fprint	fout,"ldw	r0,[r7]"$,;
		fprint	fout,"andi	r0,uart_ravl"$,;
		fprint	fout,"ldbiu	r0,true"$,;
		fprint	fout,"bne	pcnt+2"$,;
		fprint	fout,"ldbiu	r0,false"$,;
	}
	procedure	do_blk_mcoc_port_read
	{
		var		cmp;
		macro	npin;

		while (true)
		{
			fget_xml;
			macro	cxml=$(fget_xml);
			pindex	cmp=$(cxml),"^</block[ >]";
			if (cmp<=0)
			{
				pindex	cmp=$(cxml),"^<next[ >]";
			}
			if (cmp>0)
			{
				break;
			}

			pindex	cmp=$(cxml),"^<[^/]";
			if (cmp>0)
			{
				static : analyze_xml	$(cxml);
				macro	dxml=$(_xml_);
				do_$(dxml);
				strcmp	cmp=$(dxml),"value";
				if (cmp=0)
				{
					mlet	npin=$(do_$(dxml));
				}
			}
		}
		mlet	do_blk_mcoc_port_read="digitalRead ("$(npin)")";

		// assembler
		fprint	fout,"// r0=digitalRead (r0(="$(npin)"))"$,;
		fprint	fout,"jal$(z)r7	_digital_read_r0"$,;
	}
	procedure	do_blk_mcoc_port_write
	{
		var		cmp;
		macro	npin;
		macro	nval;

		while (true)
		{
			fget_xml;
			macro	cxml=$(fget_xml);
			pindex	cmp=$(cxml),"^</block[ >]";
			if (cmp<=0)
			{
				pindex	cmp=$(cxml),"^<next[ >]";
			}
			if (cmp>0)
			{
				break;
			}

			pindex	cmp=$(cxml),"^<[^/]";
			if (cmp>0)
			{
				static : analyze_xml	$(cxml);
				macro	dxml=$(_xml_);
				nmacro	_xml_name;
				macro	dnam=$(_xml_name);
				do_$(dxml);
				strcmp	cmp=$(dxml),"value";
				if (cmp=0)
				{
					strcmp	cmp=$(dnam),"PIN";
					if (cmp=0)
					{
						mlet	npin=$(do_$(dxml));

						// assembler
						fprint	fout,"push$(z)	r0"$,;
					}
					else
					{
						mlet	nval=$(do_$(dxml));

						// assembler
						fprint	fout,"// r1=r0(="$(nval)"); r0(="$(npin)")"$,;
						fprint	fout,"mov	r1,r0"$,;
						fprint	fout,"pop$(z)	r0"$,;
					}
				}
			}
		}

		// assembler
		fprint	fout,"// digitalWrite (r0(="$(npin)"),r1(="$(nval)"))"$,;
		fprint	fout,"jal$(z)r7	_digital_write_r0_r1"$,;
	}
	procedure	do_blk_mcoc_wire_init
	{
		var		cmp;
		macro	freq;

		while (true)
		{
			fget_xml;
			macro	cxml=$(fget_xml);
			pindex	cmp=$(cxml),"^</block[ >]";
			if (cmp<=0)
			{
				pindex	cmp=$(cxml),"^<next[ >]";
			}
			if (cmp>0)
			{
				break;
			}

			pindex	cmp=$(cxml),"^<[^/]";
			if (cmp>0)
			{
				static : analyze_xml	$(cxml);
				macro	dxml=$(_xml_);
				do_$(dxml);
				strcmp	cmp=$(dxml),"value";
				if (cmp=0)
				{
					mlet	freq=$(do_$(dxml));
				}
			}
		}
		need_wire=true;

		// assembler
		fprint	fout,"// Wire initialize: r0(="$(freq)")[kHz]"$,;
		fprint	fout,"jal$(z)r7	_wire_init_r0"$,;
	}
	procedure	do_blk_mcoc_wire_idend
	{
		var		cmp;
		macro	endn;
		macro	svid;

		while (true)
		{
			fget_xml;
			macro	cxml=$(fget_xml);
			pindex	cmp=$(cxml),"^</block[ >]";
			if (cmp<=0)
			{
				pindex	cmp=$(cxml),"^<next[ >]";
			}
			if (cmp>0)
			{
				break;
			}

			pindex	cmp=$(cxml),"^<[^/]";
			if (cmp>0)
			{
				static : analyze_xml	$(cxml);
				macro	dxml=$(_xml_);
				do_$(dxml);
				strcmp	cmp=$(dxml),"field";
				if (cmp=0)
				{
					mlet	endn=$(do_$(dxml));
				}
				strcmp	cmp=$(dxml),"value";
				if (cmp=0)
				{
					mlet	svid=$(do_$(dxml));
				}
			}
		}
		need_wire=true;
		tolower		endn;

		// assembler
		fprint	fout,"// Wire slave r0(="$(svid)") as "$(endn)" endian"$,;
		fprint	fout,"lsli	r0,1"$,;
		fprint	fout,"andi	r0,_wire_sidm"$,;
		asm_ld_var_adr	"r7","_wire_slv_id";
		fprint	fout,"st$(z)	[r7],r0"$,;
		strcmp	cmp=$(endn),"big";
		fprint	fout,"ldbiu	r0,"$(str_bool#(cmp=0))$,;
		asm_ld_var_adr	"r7","_wire_big_end";
		fprint	fout,"st$(z)	[r7],r0"$,;
	}
	procedure	do_blk_mcoc_wire_write
	{
		var		cmp;
		macro	siz;
		macro	cmnd;
		macro	wdat;

		while (true)
		{
			fget_xml;
			macro	cxml=$(fget_xml);
			pindex	cmp=$(cxml),"^</block[ >]";
			if (cmp<=0)
			{
				pindex	cmp=$(cxml),"^<next[ >]";
			}
			if (cmp>0)
			{
				break;
			}

			pindex	cmp=$(cxml),"^<[^/]";
			if (cmp>0)
			{
				static : analyze_xml	$(cxml);
				macro	dxml=$(_xml_);
				nmacro	_xml_name;
				macro	dnam=$(_xml_name);
				do_$(dxml);
				strcmp	cmp=$(dxml),"field";
				if (cmp=0)
				{
					mlet	siz=$(do_$(dxml));
				}
				strcmp	cmp=$(dxml),"value";
				if (cmp=0)
				{
					strcmp	cmp=$(dnam),"CMD";
					if (cmp=0)
					{
						mlet	cmnd=$(do_$(dxml));

						// assembler
						fprint	fout,"push$(z)	r0"$,;
					}
					else
					{
						mlet	wdat=$(do_$(dxml));
					}
				}
			}
		}
		need_wire=true;
		tolower		siz;

		// assembler
		fprint	fout,"// Wire write "$(siz)" [r1(="
				$(cmnd)")]=r2(=r0="$(wdat)")"$,;
		fprint	fout,"pop$(z)	r1"$,;
		fprint	fout,"mov	r2,r0"$,;
		fprint	fout,"jal$(z)r7	_wire_write_"$(siz)"_r1_r2"$,;
		asm_ld_var_adr	"r7","_wire_err_cod";
		fprint	fout,"st$(z)	[r7],r0"$,;
		asm_ld_var_adr	"r7","_wire_err_ptr";
		fprint	fout,"st$(z)	[r7],r1"$,;
	}
	procedure	do_blk_mcoc_wire_read
	{
		var		cmp;
		macro	siz;
		macro	cmnd;

		while (true)
		{
			fget_xml;
			macro	cxml=$(fget_xml);
			pindex	cmp=$(cxml),"^</block[ >]";
			if (cmp<=0)
			{
				pindex	cmp=$(cxml),"^<next[ >]";
			}
			if (cmp>0)
			{
				break;
			}

			pindex	cmp=$(cxml),"^<[^/]";
			if (cmp>0)
			{
				static : analyze_xml	$(cxml);
				macro	dxml=$(_xml_);
				do_$(dxml);
				strcmp	cmp=$(dxml),"field";
				if (cmp=0)
				{
					mlet	siz=$(do_$(dxml));
				}
				strcmp	cmp=$(dxml),"value";
				if (cmp=0)
				{
					mlet	cmnd=$(do_$(dxml));
				}
			}
		}
		need_wire=true;
		tolower		siz;
		mlet	do_blk_mcoc_wire_read="wire_read_"$(siz)" ("$(cmnd)")";

		// assembler
		fprint	fout,"// Wire read "$(siz)" [r1(=r0="$(cmnd)")]"$,;
		fprint	fout,"mov	r1,r0"$,;
		fprint	fout,"jal$(z)r7	_wire_read_"$(siz)"_r1"$,;
		asm_ld_var_adr	"r7","_wire_err_cod";
		fprint	fout,"st$(z)	[r7],r0"$,;
		asm_ld_var_adr	"r7","_wire_err_ptr";
		fprint	fout,"st$(z)	[r7],r1"$,;
		fprint	fout,"// r0=r2(="$(do_blk_mcoc_wire_read)")"$,;
		fprint	fout,"mov	r0,r2"$,;
	}
	procedure	do_blk_mcoc_wire_frame
	{
		var		cmp;
		macro	i2cf;

		while (true)
		{
			fget_xml;
			macro	cxml=$(fget_xml);
			pindex	cmp=$(cxml),"^</block[ >]";
			if (cmp<=0)
			{
				pindex	cmp=$(cxml),"^<next[ >]";
			}
			if (cmp>0)
			{
				break;
			}

			pindex	cmp=$(cxml),"^<[^/]";
			if (cmp>0)
			{
				static : analyze_xml	$(cxml);
				macro	dxml=$(_xml_);
				nmacro	_xml_name;
				macro	dnam=$(_xml_name);
				do_$(dxml);
				strcmp	cmp=$(dxml),"value";
				if (cmp=0)
				{
					mlet	i2cf=$(do_$(dxml));
				}
			}
		}
		need_wire=true;

		// assembler
		is_cstr		$(i2cf);
		if (!is_cstr)
		{
			fprint	fout,"// r1=r0(="$(i2cf)")"$,;
			fprint	fout,"mov	r1,r0"$,;
		}
		fprint	fout,"// Wire frame r1(="$(i2cf)")"$,;
		fprint	fout,"jal$(z)r7	_wire_frame_r1"$,;
		asm_ld_var_adr	"r7","_wire_err_cod";
		fprint	fout,"st$(z)	[r7],r0"$,;
		asm_ld_var_adr	"r7","_wire_err_ptr";
		fprint	fout,"st$(z)	[r7],r1"$,;
	}
	procedure	do_blk_mcoc_stft_init
	{
		var		cmp;
		macro	cmnd;

		while (true)
		{
			fget_xml;
			macro	cxml=$(fget_xml);
			pindex	cmp=$(cxml),"^</block[ >]";
			if (cmp<=0)
			{
				pindex	cmp=$(cxml),"^<next[ >]";
			}
			if (cmp>0)
			{
				break;
			}

			pindex	cmp=$(cxml),"^<[^/]";
			if (cmp>0)
			{
				static : analyze_xml	$(cxml);
				macro	dxml=$(_xml_);
				do_$(dxml);
				strcmp	cmp=$(dxml),"field";
				if (cmp=0)
				{
					mlet	cmnd=$(do_$(dxml));
				}
			}
		}
		need_stft=true;
		opt_mul_need=true;
		tolower		cmnd;

		// assembler
		fprint	fout,"// SPI-TFT initialize ("$(cmnd)")"$,;
		fprint	fout,"jal$(z)r7	_stft_"$(cmnd)$,;
	}
	procedure	do_blk_mcoc_stft_bright
	{
		var		cmp;
		macro	nval;

		while (true)
		{
			fget_xml;
			macro	cxml=$(fget_xml);
			pindex	cmp=$(cxml),"^</block[ >]";
			if (cmp<=0)
			{
				pindex	cmp=$(cxml),"^<next[ >]";
			}
			if (cmp>0)
			{
				break;
			}

			pindex	cmp=$(cxml),"^<[^/]";
			if (cmp>0)
			{
				static : analyze_xml	$(cxml);
				macro	dxml=$(_xml_);
				do_$(dxml);
				strcmp	cmp=$(dxml),"value";
				if (cmp=0)
				{
					mlet	nval=$(do_$(dxml));
				}
			}
		}
		need_stft=true;

		// assembler
		fprint	fout,"// SPI-TFT brightness"$,;
		fprint	fout,"cmpi	r0,0"$,;
		fprint	fout,"bge	pcnt+2"$,;
		fprint	fout,"ldbiu	r0,0"$,;
		fprint	fout,"cmpi	r0,255"$,;
		fprint	fout,"blt	pcnt+2"$,;
		fprint	fout,"ldbiu	r0,255"$,;
		fprint	fout,"ldwi	r7,stftduty"$,;
		fprint	fout,"stw	[r7],r0"$,;
	}
	procedure	do_blk_mcoc_stft_pixel
	{
		var		cmp;
		macro	nvalr;
		macro	nvalg;
		macro	nvalb;

		while (true)
		{
			fget_xml;
			macro	cxml=$(fget_xml);
			pindex	cmp=$(cxml),"^</block[ >]";
			if (cmp>0)
			{
				break;
			}

			pindex	cmp=$(cxml),"^<[^/]";
			if (cmp>0)
			{
				static : analyze_xml	$(cxml);
				macro	dxml=$(_xml_);
				nmacro	_xml_name;
				macro	dnam=$(_xml_name);
				do_$(dxml);
				strcmp	cmp=$(dxml),"value";
				if (cmp=0)
				{
					strcmp	cmp=$(dnam),"R8";
					if (cmp=0)
					{
						mlet	nvalr=$(do_$(dxml));

						// assembler
						fprint	fout,"push$(z)	r0"$,;
					}
					strcmp	cmp=$(dnam),"G8";
					if (cmp=0)
					{
						mlet	nvalg=$(do_$(dxml));

						// assembler
						fprint	fout,"push$(z)	r0"$,;
					}
					strcmp	cmp=$(dnam),"B8";
					if (cmp=0)
					{
						mlet	nvalb=$(do_$(dxml));
					}
				}
			}
		}
		need_stft=true;

		// assembler
		fprint	fout,"// r0=pixel (r2(="$(nvalr)"),r1(="$(nvalg)"),r0(="
					$(nvalb)"))"$,;
		fprint	fout,"pop$(z)	r1"$,;
		fprint	fout,"pop$(z)	r2"$,;
		fprint	fout,"jal$(z)r7	_stft_pixel_r2_r1_r0"$,;

		mlet	do_blk_mcoc_stft_pixel=
				"pixel ("$(nvalr)","$(nvalg)","$(nvalb)")";
	}
	procedure	do_blk_mcoc_stft_pixel_embed
	{
		var		cmp;
		macro	cpix;

		while (true)
		{
			fget_xml;
			macro	cxml=$(fget_xml);
			pindex	cmp=$(cxml),"^</block[ >]";
			if (cmp>0)
			{
				break;
			}

			pindex	cmp=$(cxml),"^<[^/]";
			if (cmp>0)
			{
				static : analyze_xml	$(cxml);
				macro	dxml=$(_xml_);
				do_$(dxml);
				strcmp	cmp=$(dxml),"field";
				if (cmp=0)
				{
					mlet	cpix=$(do_$(dxml));
				}
			}
		}
		need_stft=true;

		// assembler
		fprint	fout,"// r0="$(cpix)$,;
		fprint	fout,"ldwi	r0,"$(cpix)$,;

		mlet	do_blk_mcoc_stft_pixel_embed=$(cpix);
	}
	procedure	do_blk_mcoc_stft_draw_box
	{
		var		cmp;
		macro	opt;
		macro	px1;
		macro	py1;
		macro	px2;
		macro	py2;
		macro	pix;

		while (true)
		{
			fget_xml;
			macro	cxml=$(fget_xml);
			pindex	cmp=$(cxml),"^</block[ >]";
			if (cmp<=0)
			{
				pindex	cmp=$(cxml),"^<next[ >]";
			}
			if (cmp>0)
			{
				break;
			}

			pindex	cmp=$(cxml),"^<[^/]";
			if (cmp>0)
			{
				static : analyze_xml	$(cxml);
				macro	dxml=$(_xml_);
				nmacro	_xml_name;
				macro	dnam=$(_xml_name);
				do_$(dxml);
				strcmp	cmp=$(dxml),"field";
				if (cmp=0)
				{
					mlet	opt=$(do_$(dxml));
				}
				strcmp	cmp=$(dxml),"value";
				if (cmp=0)
				{
					strcmp	cmp=$(dnam),"PX1";
					if (cmp=0)
					{
						mlet	px1=$(do_$(dxml));

						// assembler
						fprint	fout,"push$(z)	r0"$,;
					}
					strcmp	cmp=$(dnam),"PY1";
					if (cmp=0)
					{
						mlet	py1=$(do_$(dxml));

						// assembler
						fprint	fout,"push$(z)	r0"$,;
					}
					strcmp	cmp=$(dnam),"PX2";
					if (cmp=0)
					{
						mlet	px2=$(do_$(dxml));

						// assembler
						fprint	fout,"push$(z)	r0"$,;
					}
					strcmp	cmp=$(dnam),"PY2";
					if (cmp=0)
					{
						mlet	py2=$(do_$(dxml));

						// assembler
						fprint	fout,"push$(z)	r0"$,;
					}
					strcmp	cmp=$(dnam),"PIX";
					if (cmp=0)
					{
						mlet	pix=$(do_$(dxml));

						// assembler
						fprint	fout,"push$(z)	r0"$,;
					}
				}
			}
		}
		need_stft=true;
		opt_mul_need=true;
		tolower		opt;

		// assembler
		fprint	fout,"// SPI-TFT draw box ("$(px1)","$(py1)")-("$(px2)","
				$(py2)"),"$(pix)","$(opt)$,;
		strcmp	cmp=$(opt),"fill";
		if (cmp=0)
		{
			fprint	fout,"jal$(z)r7	_stft_box_fill"$,;
		}
		else
		{
			fprint	fout,"jal$(z)r7	_stft_box_wire"$,;
		}
		fprint	fout,"movfc	r0,sp"$,;
		fprint	fout,"addi	r0,5*_rtlb_var_siz$(z)"$,;
		fprint	fout,"movtc	sp,r0"$,;
	}
	procedure	do_blk_mcoc_stft_affine
	{
		var		cmp;
		macro	affn;

		while (true)
		{
			fget_xml;
			macro	cxml=$(fget_xml);
			pindex	cmp=$(cxml),"^</block[ >]";
			if (cmp<=0)
			{
				pindex	cmp=$(cxml),"^<next[ >]";
			}
			if (cmp>0)
			{
				break;
			}

			pindex	cmp=$(cxml),"^<[^/]";
			if (cmp>0)
			{
				static : analyze_xml	$(cxml);
				macro	dxml=$(_xml_);
				nmacro	_xml_name;
				macro	dnam=$(_xml_name);
				do_$(dxml);
				strcmp	cmp=$(dxml),"field";
				if (cmp=0)
				{
					strcmp	cmp=$(do_$(dxml)),"TRUE";
					if (cmp=0)
					{
						mlet	affn=$(affn)"|"$(dnam);
					}
				}
			}
		}
		need_stft=true;
		tolower		affn;
		psub	"^|","",affn;

		// invert
		macro	scod;
		index	cmp=$(affn),"inv";
		if (cmp>0)
		{
			mlet	scod=$(scod)"|fnjp_inv";
		}
		// affine
		index	cmp=$(affn),"flph";
		if (cmp>0)
		{
			mlet	scod=$(scod)"|fnjp_flp_h";
		}
		index	cmp=$(affn),"flpv";
		if (cmp>0)
		{
			mlet	scod=$(scod)"|fnjp_flp_v";
		}
		var		nrot;
		index	cmp=$(affn),"rot1";
		if (cmp>0)
		{
			nrot=nrot + 1;
		}
		index	cmp=$(affn),"rot2";
		if (cmp>0)
		{
			nrot=nrot + 1;
		}
		index	cmp=$(affn),"rot3";
		if (cmp>0)
		{
			nrot=nrot + 1;
		}
		mlet	scod=$(scod)"|fnjp_rot_"#(nrot);
		psub	"^|","",scod;

		// assembler
		fprint	fout,"// SPI-TFT affine ("$(affn)")"$,;
		fprint	fout,"ldwi	r7,fnjpcod"$,;
		fprint	fout,"ldbiu	r0,"$(scod)$,;
		fprint	fout,"stw	[r7],r0"$,;
		asm_ld_var_adr	"r7","_stft_prn_2x2";
		index	cmp=$(affn),"dbl";
		if (cmp>0)
		{
			fprint	fout,"ldbiu	r0,true"$,;
		}
		else
		{
			fprint	fout,"ldbiu	r0,false"$,;
		}
		fprint	fout,"st$(z)	[r7],r0"$,;
	}
	procedure	do_blk_mcoc_stft_getpix
	{
		var		cmp;
		macro	px;
		macro	py;

		while (true)
		{
			fget_xml;
			macro	cxml=$(fget_xml);
			pindex	cmp=$(cxml),"^</block[ >]";
			if (cmp>0)
			{
				break;
			}

			pindex	cmp=$(cxml),"^<[^/]";
			if (cmp>0)
			{
				static : analyze_xml	$(cxml);
				macro	dxml=$(_xml_);
				nmacro	_xml_name;
				macro	dnam=$(_xml_name);
				do_$(dxml);
				strcmp	cmp=$(dxml),"value";
				if (cmp=0)
				{
					strcmp	cmp=$(dnam),"PX";
					if (cmp=0)
					{
						mlet	px=$(do_$(dxml));

						// assembler
						fprint	fout,"push$(z)	r0"$,;
					}
					else
					{
						mlet	py=$(do_$(dxml));
					}
				}
			}
		}
		need_stft=true;

		// assembler
		fprint	fout,"// r0=getpix (r1(="$(px)"),r0(="$(py)"))"$,;
		fprint	fout,"pop$(z)	r1"$,;
		fprint	fout,"jal$(z)r7	_stft_getpix_r1_r0"$,;

		mlet	do_blk_mcoc_stft_getpix="getpix ("$(px)","$(py)")";
	}
	procedure	do_blk_mcoc_stft_draw_dot
	{
		var		cmp;
		macro	px;
		macro	py;
		macro	pix;

		while (true)
		{
			fget_xml;
			macro	cxml=$(fget_xml);
			pindex	cmp=$(cxml),"^</block[ >]";
			if (cmp<=0)
			{
				pindex	cmp=$(cxml),"^<next[ >]";
			}
			if (cmp>0)
			{
				break;
			}

			pindex	cmp=$(cxml),"^<[^/]";
			if (cmp>0)
			{
				static : analyze_xml	$(cxml);
				macro	dxml=$(_xml_);
				nmacro	_xml_name;
				macro	dnam=$(_xml_name);
				do_$(dxml);
				strcmp	cmp=$(dxml),"value";
				if (cmp=0)
				{
					strcmp	cmp=$(dnam),"PX";
					if (cmp=0)
					{
						mlet	px=$(do_$(dxml));

						// assembler
						fprint	fout,"push$(z)	r0"$,;
					}
					strcmp	cmp=$(dnam),"PY";
					if (cmp=0)
					{
						mlet	py=$(do_$(dxml));

						// assembler
						fprint	fout,"push$(z)	r0"$,;
					}
					strcmp	cmp=$(dnam),"PIX";
					if (cmp=0)
					{
						mlet	pix=$(do_$(dxml));
					}
				}
			}
		}
		need_stft=true;
		opt_mul_need=true;

		// assembler
		fprint	fout,"// SPI-TFT draw dot (r2(="$(px)"),r1(="$(py)")),"$(pix)$,;
		fprint	fout,"pop$(z)	r1"$,;
		fprint	fout,"pop$(z)	r2"$,;
		fprint	fout,"jal$(z)r7	_stft_dot_r2_r1_r0"$,;
	}
	procedure	do_blk_mcoc_stft_locate
	{
		var		cmp;
		macro	cx;
		macro	cy;

		while (true)
		{
			fget_xml;
			macro	cxml=$(fget_xml);
			pindex	cmp=$(cxml),"^</block[ >]";
			if (cmp<=0)
			{
				pindex	cmp=$(cxml),"^<next[ >]";
			}
			if (cmp>0)
			{
				break;
			}

			pindex	cmp=$(cxml),"^<[^/]";
			if (cmp>0)
			{
				static : analyze_xml	$(cxml);
				macro	dxml=$(_xml_);
				nmacro	_xml_name;
				macro	dnam=$(_xml_name);
				do_$(dxml);
				strcmp	cmp=$(dxml),"value";
				if (cmp=0)
				{
					strcmp	cmp=$(dnam),"CX";
					if (cmp=0)
					{
						mlet	cx=$(do_$(dxml));

						// assembler
						fprint	fout,"push$(z)	r0"$,;
					}
					strcmp	cmp=$(dnam),"CY";
					if (cmp=0)
					{
						mlet	cy=$(do_$(dxml));
					}
				}
			}
		}
		need_stft=true;

		// assembler
		fprint	fout,"// SPI-TFT locate (r1(="$(cx)"),r0(="$(cy)"))"$,;
		fprint	fout,"pop$(z)	r1"$,;
		asm_ld_var_adr	"r7","_stft_prn_lx";
		fprint	fout,"st$(z)	[r7],r1"$,;
		asm_ld_var_adr	"r7","_stft_prn_ly";
		fprint	fout,"st$(z)	[r7],r0"$,;
	}
	procedure	do_blk_mcoc_stft_color
	{
		var		cmp;
		macro	pfg;
		macro	pbg;

		while (true)
		{
			fget_xml;
			macro	cxml=$(fget_xml);
			pindex	cmp=$(cxml),"^</block[ >]";
			if (cmp<=0)
			{
				pindex	cmp=$(cxml),"^<next[ >]";
			}
			if (cmp>0)
			{
				break;
			}

			pindex	cmp=$(cxml),"^<[^/]";
			if (cmp>0)
			{
				static : analyze_xml	$(cxml);
				macro	dxml=$(_xml_);
				nmacro	_xml_name;
				macro	dnam=$(_xml_name);
				do_$(dxml);
				strcmp	cmp=$(dxml),"value";
				if (cmp=0)
				{
					strcmp	cmp=$(dnam),"FG";
					if (cmp=0)
					{
						mlet	pfg=$(do_$(dxml));

						// assembler
						fprint	fout,"push$(z)	r0"$,;
					}
					else
					{
						mlet	pbg=$(do_$(dxml));
					}
				}
			}
		}
		need_stft=true;

		// assembler
		fprint	fout,"// SPI-TFT color (r1(="$(pfg)"),r0(="$(pbg)"))"$,;
		fprint	fout,"pop$(z)	r1"$,;
		asm_ld_var_adr	"r7","_stft_prn_fg";
		fprint	fout,"st$(z)	[r7],r1"$,;
		asm_ld_var_adr	"r7","_stft_prn_bg";
		fprint	fout,"st$(z)	[r7],r0"$,;
	}
	procedure	do_blk_mcoc_stft_print
	{
		var		cmp;
		macro	cstr;

		while (true)
		{
			fget_xml;
			macro	cxml=$(fget_xml);
			pindex	cmp=$(cxml),"^</block[ >]";
			if (cmp<=0)
			{
				pindex	cmp=$(cxml),"^<next[ >]";
			}
			if (cmp>0)
			{
				break;
			}

			pindex	cmp=$(cxml),"^<[^/]";
			if (cmp>0)
			{
				static : analyze_xml	$(cxml);
				macro	dxml=$(_xml_);
				do_$(dxml);
				strcmp	cmp=$(dxml),"value";
				if (cmp=0)
				{
					mlet	cstr=$(do_$(dxml));
				}
			}
		}
		need_stft=true;

		// assembler
		fprint	fout,"// SPI-TFT print r1(="$(cstr)")"$,;
		fprint	fout,"jal$(z)r7	_stft_print_r1"$,;
	}
	procedure	do_blk_mcoc_stft_transf
	{
		var		cmp;
		macro	trns;
		macro	nsiz;
		macro	nptr;

		while (true)
		{
			fget_xml;
			macro	cxml=$(fget_xml);
			pindex	cmp=$(cxml),"^</block[ >]";
			if (cmp>0)
			{
				break;
			}

			pindex	cmp=$(cxml),"^<[^/]";
			if (cmp>0)
			{
				static : analyze_xml	$(cxml);
				macro	dxml=$(_xml_);
				nmacro	_xml_name;
				macro	dnam=$(_xml_name);
				do_$(dxml);
				strcmp	cmp=$(dxml),"field";
				if (cmp=0)
				{
					mlet	trns=$(do_$(dxml));
				}
				strcmp	cmp=$(dxml),"value";
				if (cmp=0)
				{
					strcmp	cmp=$(dnam),"SIZ";
					if (cmp=0)
					{
						mlet	nsiz=$(do_$(dxml));

						// assembler
						fprint	fout,"push$(z)	r0"$,;
					}
					else
					{
						mlet	nptr=$(do_$(dxml));
					}
				}
			}
		}
		need_stft=true;
		tolower		trns;

		// assembler
		fprint	fout,"// SPI-TFT "$(trns)" (r1(="
				$(nsiz)"),r2(=r0="$(nptr)"))"$,;
		fprint	fout,"pop$(z)	r1"$,;
		fprint	fout,"mov	r2,r0"$,;
		fprint	fout,"jal$(z)r7	_stft_"$(trns)"_r1_r2"$,;
	}
	procedure	do_blk_serial_available
	{
		do_blk_mcoc_uart_avail;
		mlet	do_blk_serial_available=$(do_blk_mcoc_uart_avail);
	}
	procedure	do_blk_serial_read
	{
		var		cmp;

		while (true)
		{
			fget_xml;
			macro	cxml=$(fget_xml);
			pindex	cmp=$(cxml),"^</block[ >]";
			if (cmp<=0)
			{
				pindex	cmp=$(cxml),"^<next[ >]";
			}
			if (cmp>0)
			{
				break;
			}

			pindex	cmp=$(cxml),"^<[^/]";
			if (cmp>0)
			{
				static : analyze_xml	$(cxml);
				macro	dxml=$(_xml_);
				do_$(dxml);
			}
		}
		mlet	do_blk_serial_read="getbyte";

		// assembler
		labid=labid + 1;
		macro	slabid;
		num2str		slabid=labid,"%04x";
		fprint	fout,"// r0=getbyte"$,;
		fprint	fout,"ldwi	r7,uartctl"$,;
		fprint	fout,"ldw	r0,[r7]"$,;
		fprint	fout,"cmpi	r0,uart_ravl"$,;
		fprint	fout,"beq	_auto_"$(slabid)"_nodat"$,;
		fprint	fout,"// read byte"$,;
		fprint	fout,"ldwi	r7,uartrdat"$,;
		fprint	fout,"ldw	r0,[r7]"$,;
		fprint	fout,"bra	_auto_"$(slabid)"_endif"$,;
		fprint	fout,"_auto_"$(slabid)"_nodat:"$,;
		fprint	fout,"// no data available"$,;
		fprint	fout,"ld$(z)i	r0,-1"$,;
		fprint	fout,"_auto_"$(slabid)"_endif:"$,;
	}
	procedure	do_blk_serial_print
	{
		do_blk_text_print;
	}
	procedure	do_blk_serial_println
	{
		do_blk_mcoc_uart_println;
	}
	procedure	do_blk_inout_digital_read
	{
		var		cmp;
		macro	npin;

		while (true)
		{
			fget_xml;
			macro	cxml=$(fget_xml);
			pindex	cmp=$(cxml),"^</block[ >]";
			if (cmp>0)
			{
				break;
			}

			pindex	cmp=$(cxml),"^<[^/]";
			if (cmp>0)
			{
				static : analyze_xml	$(cxml);
				macro	dxml=$(_xml_);
				nmacro	_xml_name="";
				macro	dnam=$(_xml_name);
				do_$(dxml);
				strcmp	cmp=$(dxml),"field";
				if (cmp=0)
				{
					strcmp	cmp=$(dnam),"PIN";
					if (cmp=0)
					{
						mlet	npin=$(do_$(dxml));

						pindex	cmp=$(npin),"^[0-9.+-]";
						if (cmp>0)
						{
							// assembler
							fprint	fout,"// r0="$(npin)$,;
							fprint	fout,"ld$(z)i	r0,"$(npin)$,;
						}
					}
					strcmp	cmp=$(dnam),"INPUT_MODE";
					if (cmp=0)
					{
						// ignore
					}
				}
			}
		}
		mlet	do_blk_inout_digital_read="digitalRead ("$(npin)")";

		// assembler
		fprint	fout,"// digitalRead (r0(="$(npin)"))"$,;
		fprint	fout,"jal$(z)r7	_digital_read_r0"$,;
	}
	procedure	do_blk_inout_custom_digital_write
	{
		var		cmp;
		macro	npin;
		macro	nval;

		while (true)
		{
			fget_xml;
			macro	cxml=$(fget_xml);
			pindex	cmp=$(cxml),"^</block[ >]";
			if (cmp<=0)
			{
				pindex	cmp=$(cxml),"^<next[ >]";
			}
			if (cmp>0)
			{
				break;
			}

			pindex	cmp=$(cxml),"^<[^/]";
			if (cmp>0)
			{
				static : analyze_xml	$(cxml);
				macro	dxml=$(_xml_);
				nmacro	_xml_name="";
				macro	dnam=$(_xml_name);
				do_$(dxml);
				strcmp	cmp=$(dxml),"value";
				if (cmp=0)
				{
					strcmp	cmp=$(dnam),"PIN";
					if (cmp=0)
					{
						mlet	npin=$(do_$(dxml));

						// assembler
						fprint	fout,"push$(z)	r0"$,;
					}
					strcmp	cmp=$(dnam),"STAT";
					if (cmp=0)
					{
						mlet	nval=$(do_$(dxml));

						pindex	cmp=$(nval),"^[0-9.+-]";
						if (cmp>0)
						{
							// assembler
							fprint	fout,"// r0="$(nval)$,;
							fprint	fout,"ld$(z)i	r0,"$(nval)$,;
						}
					}
				}
			}
		}

		// assembler
		fprint	fout,"// r1=r0(="$(nval)"); r0(="$(npin)")"$,;
		fprint	fout,"mov	r1,r0"$,;
		fprint	fout,"pop$(z)	r0"$,;
		fprint	fout,"// digitalWrite (r0(="$(npin)"),r1(="$(nval)"))"$,;
		fprint	fout,"jal$(z)r7	_digital_write_r0_r1"$,;
	}
	procedure	do_blk_inout_digital_write
	{
		var		cmp;
		macro	npin;
		macro	nval;

		while (true)
		{
			fget_xml;
			macro	cxml=$(fget_xml);
			pindex	cmp=$(cxml),"^</block[ >]";
			if (cmp<=0)
			{
				pindex	cmp=$(cxml),"^<next[ >]";
			}
			if (cmp>0)
			{
				break;
			}

			pindex	cmp=$(cxml),"^<[^/]";
			if (cmp>0)
			{
				static : analyze_xml	$(cxml);
				macro	dxml=$(_xml_);
				nmacro	_xml_name="";
				macro	dnam=$(_xml_name);
				do_$(dxml);
				strcmp	cmp=$(dxml),"field";
				if (cmp=0)
				{
					strcmp	cmp=$(dnam),"PIN";
					if (cmp=0)
					{
						mlet	npin=$(do_$(dxml));

						pindex	cmp=$(npin),"^[0-9.+-]";
						if (cmp>0)
						{
							// assembler
							fprint	fout,"// r0="$(npin)$,;
							fprint	fout,"ld$(z)i	r0,"$(npin)$,;
						}

						// assembler
						fprint	fout,"push$(z)	r0"$,;
					}
					strcmp	cmp=$(dnam),"STAT";
					if (cmp=0)
					{
						var		nval;

						mlet	nval=$(do_$(dxml));

						// assembler
						strcmp	cmp=$(nval),"LOW";
						if (cmp=0)
						{
							nval=0;
						}
						else
						{
							nval=1;
						}
						fprint	fout,"// r0="$(nval)$,;
						fprint	fout,"ld$(z)i	r0,#"$,,nval;
					}
				}
			}
		}

		// assembler
		fprint	fout,"// r1=r0(="$(nval)"); r0(="$(npin)")"$,;
		fprint	fout,"mov	r1,r0"$,;
		fprint	fout,"pop$(z)	r0"$,;
		fprint	fout,"// digitalWrite (r0(="$(npin)"),r1(="$(nval)"))"$,;
		fprint	fout,"jal$(z)r7	_digital_write_r0_r1"$,;
	}
	procedure	do_blk_inout_digitalpin
	{
		var		cmp;
		macro	npin;

		while (true)
		{
			fget_xml;
			macro	cxml=$(fget_xml);
			pindex	cmp=$(cxml),"^</block[ >]";
			if (cmp<=0)
			{
				pindex	cmp=$(cxml),"^<next[ >]";
			}
			if (cmp>0)
			{
				break;
			}

			pindex	cmp=$(cxml),"^<[^/]";
			if (cmp>0)
			{
				static : analyze_xml	$(cxml);
				macro	dxml=$(_xml_);
				do_$(dxml);
				strcmp	cmp=$(dxml),"field";
				if (cmp=0)
				{
					mlet	npin=$(do_$(dxml));
				}
			}
		}
		mlet	do_blk_inout_digitalpin=$(npin);

		// assembler
		fprint	fout,"// r0="$(npin)$,;
		fprint	fout,"ld$(z)i	r0,"$(npin)$,;
	}
	procedure	do_blk_inout_highlow
	{
		var		cmp;
		macro	nval;

		while (true)
		{
			fget_xml;
			macro	cxml=$(fget_xml);
			pindex	cmp=$(cxml),"^</block[ >]";
			if (cmp<=0)
			{
				pindex	cmp=$(cxml),"^<next[ >]";
			}
			if (cmp>0)
			{
				break;
			}

			pindex	cmp=$(cxml),"^<[^/]";
			if (cmp>0)
			{
				static : analyze_xml	$(cxml);
				macro	dxml=$(_xml_);
				do_$(dxml);
				strcmp	cmp=$(dxml),"field";
				if (cmp=0)
				{
					mlet	nval=$(do_$(dxml));
				}
			}
		}
		mlet	do_blk_inout_highlow=$(nval);

		// assembler
		fprint	fout,"// r0="$(nval)$,;
		fprint	fout,"ld$(z)i	r0,"$(nval)$,;
	}
	procedure	do_blk_delay_custom
	{
		var		cmp;
		nvar	millis_times=1;			// uint16
		macro	nval;

		while (true)
		{
			fget_xml;
			macro	cxml=$(fget_xml);
			pindex	cmp=$(cxml),"^</block[ >]";
			if (cmp<=0)
			{
				pindex	cmp=$(cxml),"^<next[ >]";
			}
			if (cmp>0)
			{
				break;
			}

			pindex	cmp=$(cxml),"^<[^/]";
			if (cmp>0)
			{
				static : analyze_xml	$(cxml);
				macro	dxml=$(_xml_);
				do_$(dxml);
				strcmp	cmp=$(dxml),"value";
				if (cmp=0)
				{
					mlet	nval=$(do_$(dxml));
				}
			}
		}
		if (millis_times>1)
		{
			mlet	nval=$(nval)" * "#(millis_times);
		}

		// assembler
		fprint	fout,"// delay (r0(="$(nval)"))"$,;
		if (millis_times>1)
		{
			fprint	fout,"ldwi	r1,#"$,,millis_times;
			fprint	fout,"muls	r0,r1"$,;
			opt_mul_need=true;
		}
		fprint	fout,"jal$(z)r7	_delay_ms_r0"$,;
	}
	procedure	do_blk_delayMicroseconds_custom
	{
		var		cmp;
		macro	nval;

		while (true)
		{
			fget_xml;
			macro	cxml=$(fget_xml);
			pindex	cmp=$(cxml),"^</block[ >]";
			if (cmp<=0)
			{
				pindex	cmp=$(cxml),"^<next[ >]";
			}
			if (cmp>0)
			{
				break;
			}

			pindex	cmp=$(cxml),"^<[^/]";
			if (cmp>0)
			{
				static : analyze_xml	$(cxml);
				macro	dxml=$(_xml_);
				do_$(dxml);
				strcmp	cmp=$(dxml),"value";
				if (cmp=0)
				{
					mlet	nval=$(do_$(dxml));
				}
			}
		}

		// assembler
		fprint	fout,"// delayMicroseconds (r0(="$(nval)"))"$,;
		fprint	fout,"jal$(z)r7	_delay_us_r0"$,;
	}
	procedure	do_blk_millis
	{
		do_blk_mcoc_sytm_millis
		mlet	do_blk_millis=$(do_blk_mcoc_sytm_millis);
	}
	procedure	do_blk_micros
	{
		do_blk_mcoc_sytm_micros;
		mlet	do_blk_micros=$(do_blk_mcoc_sytm_micros);
	}
	procedure	do_blk_cast_number
	{
		var		cmp;
		nmacro	ctyp;
		macro	nval;

		while (true)
		{
			fget_xml;
			macro	cxml=$(fget_xml);
			pindex	cmp=$(cxml),"^</block[ >]";
			if (cmp>0)
			{
				break;
			}

			pindex	cmp=$(cxml),"^<[^/]";
			if (cmp>0)
			{
				static : analyze_xml	$(cxml);
				macro	dxml=$(_xml_);
				do_$(dxml);
				strcmp	cmp=$(dxml),"field";
				if (cmp=0)
				{
					mlet	ctyp=$(do_$(dxml));
					psub	"^\((.*)\)$","\1",ctyp;
				}
				strcmp	cmp=$(dxml),"value";
				if (cmp=0)
				{
					mlet	nval=$(do_$(dxml));
				}
			}
		}
		strcmp	cmp=$(ctyp),"int";
		if (cmp)
		{
			strcmp	cmp=$(ctyp),"float";
		}
		if (cmp)
		{
			// ERROR:
			errmsg	"cast_number: unsupported cast ("$(ctyp)")";
			leave	stop_error;
		}
		mlet	do_blk_cast_number=$(ctyp)" ("$(nval)")";

		// assembler
		strcmp	cmp=$(ctyp),"int";
		if (cmp=0)
		{
			fprint	fout,"// r0="$(ctyp)" (float r0(="$(nval)"))"$,;
			fprint	fout,"cmpi	r0,0"$,;
			fprint	fout,"ldbiu	r1,false	// 0 or positive"$,;
			fprint	fout,"bpl	pcnt+4"$,;
			fprint	fout,"ldbiu	r1,true	// negative"$,;
			fprint	fout,"fneg	r0,r0"$,;
			fprint	fout,"fuint	r0,r0"$,;
			fprint	fout,"cmpi	r1,false"$,;
			fprint	fout,"beq	pcnt+2"$,;
			fprint	fout,"neg	r0"$,;
			opt_fpu_need=true;
		}
		strcmp	cmp=$(ctyp),"float";
		if (cmp=0)
		{
			fprint	fout,"// r0="$(ctyp)" (int r0(="$(nval)"))"$,;
			fprint	fout,"cmpi	r0,0"$,;
			fprint	fout,"ldbiu	r1,false	// 0 or positive"$,;
			fprint	fout,"bpl	pcnt+4"$,;
			fprint	fout,"ldbiu	r1,true	// negative"$,;
			fprint	fout,"neg	r0"$,;
			fprint	fout,"fsngl	r0,r0"$,;
			fprint	fout,"cmpi	r1,false"$,;
			fprint	fout,"beq	pcnt+2"$,;
			fprint	fout,"fneg	r0,r0"$,;
			opt_fpu_need=true;
		}
	}
	procedure	do_blk_math_number
	{
		var		cmp;
		macro	nval;

		while (true)
		{
			fget_xml;
			macro	cxml=$(fget_xml);
			pindex	cmp=$(cxml),"^</block[ >]";
			if (cmp>0)
			{
				break;
			}

			pindex	cmp=$(cxml),"^<[^/]";
			if (cmp>0)
			{
				static : analyze_xml	$(cxml);
				macro	dxml=$(_xml_);
				do_$(dxml);
				mlet	nval=$(do_$(dxml));
			}
		}
		mlet	do_blk_math_number=$(nval);

		// assembler
		macro	fi;
		if (opt_opr_typ=opt_float)
		{
			mlet	fi="f";
		}
		fprint	fout,"// r0="$(nval)$,;
		fprint	fout,$(fi)"ld$(z)i	r0,"$(nval)$,;

		val_done=true;
	}
	procedure	do_blk_math_number_property
	{
		var		cmp;
		var		pdone;
		macro	prop;
		macro	nval;

		while (true)
		{
			fget_xml;
			macro	cxml=$(fget_xml);
			pindex	cmp=$(cxml),"^</block[ >]";
			if (cmp>0)
			{
				break;
			}

			pindex	cmp=$(cxml),"^<[^/]";
			if (cmp>0)
			{
				static : analyze_xml	$(cxml);
				macro	dxml=$(_xml_);
				do_$(dxml);
				strcmp	cmp=$(dxml),"field";
				if (cmp=0)
				{
					mlet	prop=$(do_$(dxml));
					tolower		prop;
				}
				strcmp	cmp=$(dxml),"value";
				if (cmp=0)
				{
					mlet	nval=$(do_$(dxml));
				}
			}
		}
		if (opt_opr_typ=opt_float)
		{
			// ERROR:
			errmsg	"math_number_property: does not support float type";
			leave	stop_error;
		}

		// assembler
		fprint	fout,"// "$(prop)" (r0(="$(nval)"))"$,;
		strcmp	cmp=$(prop),"even";
		if (cmp=0)
		{
			pdone=true;
			fprint	fout,"andi	r0,0x01"$,;
			fprint	fout,"eori	r0,0x01"$,;
		}
		strcmp	cmp=$(prop),"odd";
		if (cmp=0)
		{
			pdone=true;
			fprint	fout,"andi	r0,0x01"$,;
		}
		strcmp	cmp=$(prop),"positive";
		if (cmp=0)
		{
			pdone=true;
			fprint	fout,"cmpi	r0,1"$,;
			fprint	fout,"ldbiu	r0,false"$,;
			fprint	fout,"blt	pcnt+2"$,;
			fprint	fout,"ldbiu	r0,true"$,;
		}
		strcmp	cmp=$(prop),"negative";
		if (cmp=0)
		{
			pdone=true;
			fprint	fout,"cmpi	r0,0"$,;
			fprint	fout,"ldbiu	r0,true"$,;
			fprint	fout,"blt	pcnt+2"$,;
			fprint	fout,"ldbiu	r0,false"$,;
		}
		if (!pdone)
		{
			// ERROR:
			errmsg	"math_number_property: unsupported property ("$(prop)")";
			leave	stop_error;
		}
		mlet	do_blk_math_number_property=$(prop)" ("$(nval)")";
	}
	procedure	do_blk_math_constrain
	{
		var		cmp;
		macro	nval;
		macro	nlow;
		macro	nhgh;

		while (true)
		{
			fget_xml;
			macro	cxml=$(fget_xml);
			pindex	cmp=$(cxml),"^</block[ >]";
			if (cmp>0)
			{
				break;
			}

			pindex	cmp=$(cxml),"^<[^/]";
			if (cmp>0)
			{
				static : analyze_xml	$(cxml);
				macro	dxml=$(_xml_);
				nmacro	_xml_name;
				macro	dnam=$(_xml_name);
				do_$(dxml);
				strcmp	cmp=$(dxml),"value";
				if (cmp=0)
				{
					strcmp	cmp=$(dnam),"VALUE";
					if (cmp=0)
					{
						mlet	nval=$(do_$(dxml));

						// assembler
						fprint	fout,"push$(z)	r0"$,;
					}
					strcmp	cmp=$(dnam),"LOW";
					if (cmp=0)
					{
						mlet	nlow=$(do_$(dxml));

						// assembler
						fprint	fout,"push$(z)	r0"$,;
					}
					strcmp	cmp=$(dnam),"HIGH";
					if (cmp=0)
					{
						mlet	nhgh=$(do_$(dxml));
					}
				}
			}
		}
		mlet	do_blk_math_constrain="clip ("$(nval)","$(nlow)","$(nhgh)")";

		// assembler
		macro	fi;
		if (opt_opr_typ=opt_float)
		{
			mlet	fi="f";
		}
		fprint	fout,"// r0=clip (r0(="$(nval)"),r1(="$(nlow)"),r2(="
				$(nhgh)"))"$,;
		fprint	fout,"mov	r2,r0"$,;
		fprint	fout,"pop$(z)	r1"$,;
		fprint	fout,"pop$(z)	r0"$,;
		fprint	fout,$(fi)"cmp	r0,r1"$,;
		fprint	fout,"bge	pcnt+2"$,;
		fprint	fout,"mov	r0,r1"$,;
		fprint	fout,$(fi)"cmp	r2,r0"$,;
		fprint	fout,"bge	pcnt+2"$,;
		fprint	fout,"mov	r0,r2"$,;
	}
	procedure	do_blk_math_change
	{
		var		cmp;
		nvar	vdec;
		macro	vnam;
		macro	nval;
		macro	opr;
		macro	mne;

		while (true)
		{
			fget_xml;
			macro	cxml=$(fget_xml);
			pindex	cmp=$(cxml),"^</block[ >]";
			if (cmp<=0)
			{
				pindex	cmp=$(cxml),"^<next[ >]";
			}
			if (cmp>0)
			{
				break;
			}

			pindex	cmp=$(cxml),"^<[^/]";
			if (cmp>0)
			{
				static : analyze_xml	$(cxml);
				macro	dxml=$(_xml_);
				do_$(dxml);
				strcmp	cmp=$(dxml),"field";
				if (cmp=0)
				{
					mlet	vnam=$(do_$(dxml));
				}
				strcmp	cmp=$(dxml),"block";
				if (cmp)
				{
					strcmp	cmp=$(dxml),"value";
				}
				if (cmp=0)
				{
					mlet	nval=$(do_$(dxml));
				}
			}
		}

		// assembler
		if (vdec)
		{
			mlet	opr="-";
			mlet	mne="sub";
		}
		else
		{
			mlet	opr="+";
			mlet	mne="add";
		}
		if (opt_opr_typ=opt_float)
		{
			mlet	mne="f"$(mne);
		}
		asm_ld_var	"r1",$(vnam), "r7";
		fprint	fout,"// r1(="$(vnam)") "$(opr)"= r0(="$(nval)")"$,;
		fprint	fout,$(mne)"	r1,r0"$,;
		fprint	fout,"st$(z)	[r7],r1"$,;
	}
	procedure	do_blk_math_constant
	{
		var		cmp;
		macro	nval;

		while (true)
		{
			fget_xml;
			macro	cxml=$(fget_xml);
			pindex	cmp=$(cxml),"^</block[ >]";
			if (cmp>0)
			{
				break;
			}

			pindex	cmp=$(cxml),"^<[^/]";
			if (cmp>0)
			{
				static : analyze_xml	$(cxml);
				macro	dxml=$(_xml_);
				do_$(dxml);
				mlet	nval=$(do_$(dxml));
			}
		}
		mlet	do_blk_math_constant=$(nval);

		// assembler
		fprint	fout,"// r0="$(nval)$,;
		fprint	fout,"ld$(z)i	r0,"$(nval)$,;
	}
	procedure	do_blk_math_modulo
	{
		var		cmp;
		macro	lval;
		macro	rval;

		while (true)
		{
			fget_xml;
			macro	cxml=$(fget_xml);
			pindex	cmp=$(cxml),"^</block[ >]";
			if (cmp>0)
			{
				break;
			}

			pindex	cmp=$(cxml),"^<[^/]";
			if (cmp>0)
			{
				static : analyze_xml	$(cxml);
				macro	dxml=$(_xml_);
				nmacro	_xml_name;
				macro	dnam=$(_xml_name);
				do_$(dxml);
				strcmp	cmp=$(dxml),"value";
				if (cmp=0)
				{
					strcmp	cmp=$(dnam),"DIVIDEND";
					if (cmp=0)
					{
						mlet	lval=$(do_$(dxml));

						// assembler
						fprint	fout,"push$(z)	r0"$,;
					}
					else
					{
						mlet	rval=$(do_$(dxml));

						// assembler
						fprint	fout,"// r1=r0(="$(rval)"); r0(="$(lval)")"$,;
						fprint	fout,"mov	r1,r0"$,;
						fprint	fout,"pop$(z)	r0"$,;
					}
				}
			}
		}

		// assembler
		fprint	fout,"// r0(="$(lval)") % r1(="$(rval)")"$,;
		if (opt_opr_typ=opt_int)
		{
			fprint	fout,"divsr	r0,r1"$,;
			opt_div_need=true;
		}
		else
		{
			fprint	fout,"// A%B=A - fdown (A/B)*B"$,;
			fprint	fout,"push$(z)	r0"$,;
			fprint	fout,"fdiv	r0,r1"$,;
			fprint	fout,"fdown	r2,r0"$,;
			fprint	fout,"fmul	r2,r1"$,;
			fprint	fout,"pop$(z)	r1"$,;
			fprint	fout,"fsub	r1,r2"$,;
		}
		fprint	fout,"// r2=r0(=quotient), r0=r1(=remainder)"$,;
		fprint	fout,"mov	r2,r0"$,;
		fprint	fout,"mov	r0,r1"$,;

		index	cmp=$(lval)," ";
		if (cmp>0)
		{
			mlet	lval="("$(lval)")";
		}
		index	cmp=$(rval)," ";
		if (cmp>0)
		{
			mlet	rval="("$(rval)")";
		}
		mlet	do_blk_math_modulo=$(lval)" % "$(rval);
	}
	procedure	do_blk_math_arithmetic
	{
		var		cmp;
		macro	opr;
		macro	lval;
		macro	rval;
		macro	mne;

		while (true)
		{
			fget_xml;
			macro	cxml=$(fget_xml);
			pindex	cmp=$(cxml),"^</block[ >]";
			if (cmp>0)
			{
				break;
			}

			pindex	cmp=$(cxml),"^<[^/]";
			if (cmp>0)
			{
				static : analyze_xml	$(cxml);
				macro	dxml=$(_xml_);
				nmacro	_xml_name;
				macro	dnam=$(_xml_name);
				do_$(dxml);
				strcmp	cmp=$(dxml),"field";
				if (cmp=0)
				{
					mlet	opr=$(do_$(dxml));
					tolower		opr;
				}
				strcmp	cmp=$(dxml),"value";
				if (cmp=0)
				{
					strcmp	cmp=$(dnam),"A";
					if (cmp)
					{
						strcmp	cmp=$(dnam),"VAR1";
					}
					if (cmp=0)
					{
						mlet	lval=$(do_$(dxml));

						// assembler
						fprint	fout,"push$(z)	r0"$,;
					}
					else
					{
						mlet	rval=$(do_$(dxml));

						// assembler
						fprint	fout,"// r1=r0(="$(rval)"); r0(="$(lval)")"$,;
						fprint	fout,"mov	r1,r0"$,;
						fprint	fout,"pop$(z)	r0"$,;
					}
				}
			}
		}

		// operator
		mlet	mne="xxx";
		strcmp	cmp=$(opr),"add";
		if (cmp)
		{
			strcmp	cmp=$(opr),"+";
		}
		if (cmp=0)
		{
			mlet	opr="+";
			mlet	mne="add";
		}
		strcmp	cmp=$(opr),"minus";
		if (cmp)
		{
			strcmp	cmp=$(opr),"-";
		}
		if (cmp=0)
		{
			mlet	opr="-";
			mlet	mne="sub";
		}
		strcmp	cmp=$(opr),"multiply";
		if (cmp)
		{
			strcmp	cmp=$(opr),"*";
		}
		if (cmp=0)
		{
			mlet	opr="*";
			mlet	mne="muls";
			if (opt_opr_typ=opt_int)
			{
				opt_mul_need=true;
			}
		}
		strcmp	cmp=$(opr),"divide";
		if (cmp)
		{
			strcmp	cmp=$(opr),"/";
		}
		if (cmp=0)
		{
			mlet	opr="/";
			mlet	mne="divs";
			if (opt_opr_typ=opt_int)
			{
				opt_div_need=true;
			}
		}
		strcmp	cmp=$(opr),"remainder";
		if (cmp)
		{
			strcmp	cmp=$(opr),"modulo";
		}
		if (cmp)
		{
			strcmp	cmp=$(opr),"%";
		}
		if (cmp=0)
		{
			mlet	opr="%";
			mlet	mne="divsr";
			opt_div_need=true;
		}
		strcmp	cmp=$(opr),$(str_and);
		if (cmp=0)
		{
			mlet	opr="&";
			mlet	mne=$(str_and);
		}
		strcmp	cmp=$(opr),$(str_or);
		if (cmp=0)
		{
			mlet	opr="|";
			mlet	mne=$(str_or);
		}
		strcmp	cmp=$(opr),"xor";
		if (cmp=0)
		{
			mlet	opr="^";
			mlet	mne="eor";
		}

		// error check
		strcmp	cmp=$(mne),"xxx";
		if (cmp=0)
		{
			// ERROR:
			errmsg	"math_arithmetic: unsupported operator ("$(opr)")";
			leave	stop_error;
		}
		// floating point operation
		if (opt_opr_typ=opt_float)
		{
			mlet	mne="f"$(mne);
			sub		"fmuls","fmul",mne;
			sub		"fdivs","fdiv",mne;
			index	cmp="_fadd_fsub_fmul_fdiv_","_"$(mne)"_";
			if (cmp<=0)
			{
				// ERROR:
				errmsg	"math_arithmetic: unsupported operator ("
						$(opr)") for float";
				leave	stop_error;
			}
		}

		// assembler
		fprint	fout,"// r0(="$(lval)") "$(opr)" r1(="$(rval)")"$,;
		strcmp	cmp=$(opr),"max";
		if (cmp=0)
		{
			// r0 max r1=(r0>=r1)? r1: r0 (PICAXE BASIC operator)
			mlet	mne="mov";

			// assembler
			fprint	fout,"cmp	r0,r1"$,;
			fprint	fout,"bge	pcnt+2"$,;
			fprint	fout,"mov	r1,r0"$,;
		}
		strcmp	cmp=$(opr),"min";
		if (cmp=0)
		{
			// r0 min r1=(r0<=r1)? r1: r0 (PICAXE BASIC operator)
			mlet	mne="mov";

			// assembler
			fprint	fout,"cmp	r1,r0"$,;
			fprint	fout,"bge	pcnt+2"$,;
			fprint	fout,"mov	r1,r0"$,;
		}
		fprint	fout,$(mne)"	r0,r1"$,;
		strcmp	cmp=$(opr),"%";
		if (cmp=0)
		{
			fprint	fout,"// r2=r0(=quotient), r0=r1(=remainder)"$,;
			fprint	fout,"mov	r2,r0"$,;
			fprint	fout,"mov	r0,r1"$,;
		}

		index	cmp=$(lval)," ";
		if (cmp>0)
		{
			mlet	lval="("$(lval)")";
		}
		index	cmp=$(rval)," ";
		if (cmp>0)
		{
			mlet	rval="("$(rval)")";
		}
		mlet	do_blk_math_arithmetic=$(lval)" "$(opr)" "$(rval);
	}
	procedure	do_blk_logic_boolean
	{
		var		cmp;
		macro	bval;
		
		while (true)
		{
			fget_xml;
			macro	cxml=$(fget_xml);
			pindex	cmp=$(cxml),"^</block[ >]";
			if (cmp>0)
			{
				break;
			}

			pindex	cmp=$(cxml),"^<[^/]";
			if (cmp>0)
			{
				static : analyze_xml	$(cxml);
				macro	dxml=$(_xml_);
				do_$(dxml);
				strcmp	cmp=$(dxml),"field";
				if (cmp=0)
				{
					mlet	bval=$(do_$(dxml));
					tolower		bval;
				}
			}
		}
		mlet	do_blk_logic_boolean=$(bval);

		// assembler
		fprint	fout,"// r0="$(bval)$,;
		fprint	fout,"ldbiu	r0,"$(bval)$,;
	}
	procedure	do_blk_logic_negate
	{
		var		cmp;
		macro	bval;
		
		while (true)
		{
			fget_xml;
			macro	cxml=$(fget_xml);
			pindex	cmp=$(cxml),"^</block[ >]";
			if (cmp>0)
			{
				break;
			}

			pindex	cmp=$(cxml),"^<[^/]";
			if (cmp>0)
			{
				static : analyze_xml	$(cxml);
				macro	dxml=$(_xml_);
				do_$(dxml);
				strcmp	cmp=$(dxml),"value";
				if (cmp=0)
				{
					mlet	bval=$(do_$(dxml));
				}
			}
		}

		// assembler
		fprint	fout,"// !r0(="$(bval)")"$,;
		fprint	fout,"cmpi	r0,false"$,;
		fprint	fout,"beq	pcnt+2"$,;
		fprint	fout,"ldbiu	r0,true"$,;
		fprint	fout,"eori	r0,true"$,;

		index	cmp=$(bval)," ";
		if (cmp>0)
		{
			mlet	bval="("$(bval)")";
		}
		mlet	do_blk_logic_negate="! "$(bval);
	}
	procedure	do_blk_logic_ternary
	{
		var		cmp;
		var		iblk;
		macro	iexp;
		macro	vthn;
		macro	vels;

		// assembler
		labid=labid + 1;
		macro	slabid;
		num2str		slabid=labid,"%04x";
		fprint	fout,""$,;
		fprint	fout,"// if test"$,;

		while (true)
		{
			fget_xml;
			macro	cxml=$(fget_xml);
			pindex	cmp=$(cxml),"^</block[ >]";
			if (cmp>0)
			{
				break;
			}

			pindex	cmp=$(cxml),"^<[^/]";
			if (cmp>0)
			{
				static : analyze_xml	$(cxml);
				macro	dxml=$(_xml_);
				nmacro	_xml_name;
				macro	dnam=$(_xml_name);
				do_$(dxml);
				strcmp	cmp=$(dxml),"value";
				if (cmp=0)
				{
					strcmp	cmp=$(dnam),"IF";
					if (cmp=0)
					{
						iblk=@(iblk | 0x01);
						mlet	iexp=$(do_$(dxml));

						// assembler
						fprint	fout,"// test ("$(iexp)")"$,;
						fprint	fout,"cmpi	r0,false"$,;
						fprint	fout,"beq	_auto_"$(slabid)"_else"$,;
						fprint	fout,""$,;
						fprint	fout,"// then"$,;
					}
					strcmp	cmp=$(dnam),"THEN";
					if (cmp=0)
					{
						iblk=@(iblk | 0x02);
						mlet	vthn=$(do_$(dxml));

						// assembler
						fprint	fout,"// then ("$(vthn)")"$,;
						fprint	fout,"bra	_auto_"$(slabid)"_endif"$,;
						fprint	fout,""$,;
						fprint	fout,"// else"$,;
						fprint	fout,"_auto_"$(slabid)"_else:"$,;
					}
					strcmp	cmp=$(dnam),"ELSE";
					if (cmp=0)
					{
						iblk=@(iblk | 0x04);
						mlet	vels=$(do_$(dxml));

						// assembler
						fprint	fout,""$,;
						fprint	fout,"// else ("$(vels)")"$,;
						fprint	fout,"_auto_"$(slabid)"_endif:"$,;
					}
				}
			}
		}
		if (iblk!=0x07)
		{
			// ERROR:
			errmsg "logic_ternary: inhibited empty block.";
			leave	stop_error;
		}
		index	cmp=$(vthn)," ";
		if (cmp>0)
		{
			mlet	vthn="("$(vthn)")";
		}
		index	cmp=$(vels)," ";
		if (cmp>0)
		{
			mlet	vels="("$(vels)")";
		}
		mlet	do_blk_logic_ternary="("$(iexp)")? "$(vthn)": "$(vels);

		// assembler
		fprint	fout,""$,;
		fprint	fout,"// end of test ("$(iexp)")? "$(vthn)": "$(vels)$,;
	}
	procedure	do_blk_logic_compare
	{
		var		cmp;
		var		is_cstr_cmp;
		macro	opr;
		macro	lval;
		macro	rval;
		macro	mne;

		while (true)
		{
			fget_xml;
			macro	cxml=$(fget_xml);
			pindex	cmp=$(cxml),"^</block[ >]";
			if (cmp>0)
			{
				break;
			}

			pindex	cmp=$(cxml),"^<[^/]";
			if (cmp>0)
			{
				static : analyze_xml	$(cxml);
				macro	dxml=$(_xml_);
				nmacro	_xml_name;
				macro	dnam=$(_xml_name);
				do_$(dxml);
				strcmp	cmp=$(dxml),"field";
				if (cmp=0)
				{
					mlet	opr=$(do_$(dxml));
					tolower		opr;
				}
				strcmp	cmp=$(dxml),"value";
				if (cmp=0)
				{
					strcmp	cmp=$(dnam),"A";
					if (cmp=0)
					{
						mlet	lval=$(do_$(dxml));
						// text compare?
						is_cstr		$(lval);
						if (!is_cstr)
						{
							// lval!=cstr_var
							strcmp	cmp=$(lval),$",left;
							if (cmp=0)
							{
								// lval=cstr_txt
								is_cstr=true;
							}
						}
						is_cstr_cmp=is_cstr_cmp + ( is_cstr!=0 );

						// assembler
						if (is_cstr)
						{
							fprint	fout,"push$(z)	r1"$,;
						}
						else
						{
							fprint	fout,"push$(z)	r0"$,;
						}
					}
					else
					{
						mlet	rval=$(do_$(dxml));
						// text compare?
						is_cstr		$(rval);
						if (!is_cstr)
						{
							// rval!=cstr_var
							strcmp	cmp=$(rval),$",left;
							if (cmp=0)
							{
								// rval=cstr_txt
								is_cstr=true;
							}
						}
						is_cstr_cmp=is_cstr_cmp + ( is_cstr!=0 )*2;

						// assembler
						if (is_cstr)
						{
							fprint	fout,"pop$(z)	r0"$,;
						}
						else
						{
							fprint	fout,"// r1=r0(="$(rval)"); r0(="
									$(lval)")"$,;
							fprint	fout,"mov	r1,r0"$,;
							fprint	fout,"pop$(z)	r0"$,;
						}
					}
				}
			}
		}

		// operator
		mlet	mne="xxx";
		strcmp	cmp=$(opr),"eq";
		if (cmp=0)
		{
			mlet	opr="==";
			mlet	mne="eq";
		}
		strcmp	cmp=$(opr),"neq";
		if (cmp=0)
		{
			mlet	opr="!=";
			mlet	mne="ne";
		}
		strcmp	cmp=$(opr),"gte";
		if (cmp=0)
		{
			mlet	opr=">=";
			mlet	mne="ge";
		}
		strcmp	cmp=$(opr),"lte";
		if (cmp=0)
		{
			mlet	opr="<=";
			mlet	mne="le";
		}
		strcmp	cmp=$(opr),"gt";
		if (cmp=0)
		{
			mlet	opr=">";
			mlet	mne="gt";
		}
		strcmp	cmp=$(opr),"lt";
		if (cmp=0)
		{
			mlet	opr="<";
			mlet	mne="lt";
		}
		mlet	do_blk_logic_compare=$(opr);

		// error check
		strcmp	cmp=$(mne),"xxx";
		if (cmp=0)
		{
			// ERROR:
			errmsg	"logic_compare: unsupported operator ("$(opr)")";
			leave	stop_error;
		}
		// text compare?
		if (is_cstr_cmp=1 | is_cstr_cmp=2)
		{
			// ERROR:
			errmsg	"logic_compare: illegal text compare ("
					$(lval)" "$(opr)" "$(rval)")";
			leave	stop_error;
		}

		// assembler
		fprint	fout,"// r0(="$(lval)") "$(opr)" r1(="$(rval)")";
		strcmp	cmp=$(opr),"==";
		if (cmp)
		{
			strcmp	cmp=$(opr),"!=";
		}
		if (cmp)
		{
			strcmp	cmp=$(opr),">=";
		}
		if (cmp)
		{
			strcmp	cmp=$(opr),"<";
		}
		if (cmp=0)
		{
			fprint	fout,""$,;
			if (is_cstr_cmp)
			{
				fprint	fout,"mov	r2,r1"$,;
				fprint	fout,"mov	r1,r0"$,;
				fprint	fout,"jal$(z)r7	_strcmp_r1_r2"$,;
				fprint	fout,"cmpi	r0,0"$,;
			}
			else
			{
				if (opt_opr_typ=opt_int)
				{
					fprint	fout,"cmp	r0,r1"$,;
				}
				else
				{
					fprint	fout,"fcmp	r0,r1"$,;
				}
			}
		}
		strcmp	cmp=$(opr),">";
		if (cmp=0)
		{
			mlet	opr="<";
			mlet	mne="lt";
			fprint	fout," ==> r1(="$(rval)") "$(opr)" r0(="$(lval)")"$,;
			if (is_cstr_cmp)
			{
				fprint	fout,"mov	r2,r0"$,;
				fprint	fout,"jal$(z)r7	_strcmp_r1_r2"$,;
				fprint	fout,"cmpi	r0,0"$,;
			}
			else
			{
				if (opt_opr_typ=opt_int)
				{
					fprint	fout,"cmp	r1,r0"$,;
				}
				else
				{
					fprint	fout,"fcmp	r1,r0"$,;
				}
			}
		}
		strcmp	cmp=$(opr),"<=";
		if (cmp=0)
		{
			mlet	opr=">=";
			mlet	mne="ge";
			fprint	fout," ==> r1(="$(rval)") "$(opr)" r0(="$(lval)")"$,;
			if (is_cstr_cmp)
			{
				fprint	fout,"mov	r2,r0"$,;
				fprint	fout,"jal$(z)r7	_strcmp_r1_r2"$,;
				fprint	fout,"cmpi	r0,0"$,;
			}
			else
			{
				if (opt_opr_typ=opt_int)
				{
					fprint	fout,"cmp	r1,r0"$,;
				}
				else
				{
					fprint	fout,"fcmp	r1,r0"$,;
				}
			}
		}
		fprint	fout,"ldbiu	r0,true"$,;
		fprint	fout,"b"$(mne)"	pcnt+2"$,;
		fprint	fout,"ldbiu	r0,false"$,;

		index	cmp=$(lval)," ";
		if (cmp>0)
		{
			mlet	lval="("$(lval)")";
		}
		index	cmp=$(rval)," ";
		if (cmp>0)
		{
			mlet	rval="("$(rval)")";
		}
		mlet	do_blk_logic_compare=$(lval)" "
				$(do_blk_logic_compare)" "$(rval);
	}
	procedure	do_blk_logic_operation
	{
		var		cmp;
		macro	opr;
		macro	lval;
		macro	rval;
		macro	mne;

		while (true)
		{
			fget_xml;
			macro	cxml=$(fget_xml);
			pindex	cmp=$(cxml),"^</block[ >]";
			if (cmp>0)
			{
				break;
			}

			pindex	cmp=$(cxml),"^<[^/]";
			if (cmp>0)
			{
				static : analyze_xml	$(cxml);
				macro	dxml=$(_xml_);
				nmacro	_xml_name;
				macro	dnam=$(_xml_name);
				do_$(dxml);
				strcmp	cmp=$(dxml),"field";
				if (cmp=0)
				{
					mlet	opr=$(do_$(dxml));
					tolower		opr;
				}
				strcmp	cmp=$(dxml),"value";
				if (cmp=0)
				{
					strcmp	cmp=$(dnam),"A";
					if (cmp=0)
					{
						mlet	lval=$(do_$(dxml));

						// assembler
						fprint	fout,"push$(z)	r0"$,;
					}
					else
					{
						mlet	rval=$(do_$(dxml));

						// assembler
						fprint	fout,"// r1=r0(="$(rval)"); r0(="$(lval)")"$,;
						fprint	fout,"mov	r1,r0"$,;
						fprint	fout,"pop$(z)	r0"$,;
					}
				}
			}
		}

		// operator
		mlet	mne="xxx";
		strcmp	cmp=$(opr),$(str_and);
		if (cmp=0)
		{
			mlet	mne=$(opr);
			mlet	opr="&&";
		}
		strcmp	cmp=$(opr),$(str_or);
		if (cmp=0)
		{
			mlet	mne=$(opr);
			mlet	opr="||";
		}

		// error check
		strcmp	cmp=$(mne),"xxx";
		if (cmp=0)
		{
			// ERROR:
			errmsg	"logic_operation: unsupported operator ("$(opr)")";
			leave	stop_error;
		}

		// assembler
		fprint	fout,"// r0(="$(lval)") "$(opr)" r1(="$(rval)")"$,;
		fprint	fout,$(mne)"	r0,r1"$,;

		index	cmp=$(lval)," ";
		if (cmp>0)
		{
			mlet	lval="("$(lval)")";
		}
		index	cmp=$(rval)," ";
		if (cmp>0)
		{
			mlet	rval="("$(rval)")";
		}
		mlet	do_blk_logic_operation=$(lval)" "$(opr)" "$(rval);
	}
	procedure	do_blk_text
	{
		var		cmp;
		macro	cstr;

		while (true)
		{
			fget_xml;
			macro	cxml=$(fget_xml);
			pindex	cmp=$(cxml),"^</block[ >]";
			if (cmp>0)
			{
				break;
			}

			pindex	cmp=$(cxml),"^<[^/]";
			if (cmp>0)
			{
				static : analyze_xml	$(cxml);
				macro	dxml=$(_xml_);
				do_$(dxml);
				strcmp	cmp=$(dxml),"field";
				if (cmp=0)
				{
					mlet	cstr=$(do_$(dxml));
				}
			}
		}
		gsub	"#","##",cstr;
		mlet	do_blk_text=$(cstr);
		strcmp	cmp=$(do_blk_text),$",left;
		if (cmp)
		{
			mlet	do_blk_text=$"$(do_blk_text)$";
		}

		// string constants
		var		idx;
		var		str_labl;

		psub	"^"$""([^"$""]*)"$""$","\1",cstr;
		gsub	"&lt;","<",cstr;
		idx=0;
		while (idx<n_str_cnst)
		{
			strcmp	cmp=$(cstr),$(str_cnst#(idx));
			if (cmp=0)
			{
				break;
			}

			// continue
			idx=idx + 1;
		}
		if (idx<n_str_cnst)
		{
			// found
			str_labl=str_labl#(idx);
		}
		else
		{
			// not found
			labid=labid + 1;
			str_labl=labid;

			// register string constants
			static : var	str_labl#(n_str_cnst)=labid;
			static : macro	str_cnst#(n_str_cnst)=$(cstr);
			n_str_cnst=n_str_cnst + 1;
		}

		// assembler
		macro	slabid;
		num2str		slabid=str_labl,"%04x";
		fprint	fout,"// r1="$(do_blk_text)$,;
		fprint	fout,"ldwi	r1,lab__auto_"$(slabid)"_text"$,;

		val_done=true;
	}
	procedure	do_blk_text_length
	{
		var		cmp;
		macro	cstr;

		while (true)
		{
			fget_xml;
			macro	cxml=$(fget_xml);
			pindex	cmp=$(cxml),"^</block[ >]";
			if (cmp<=0)
			{
				pindex	cmp=$(cxml),"^<next[ >]";
			}
			if (cmp>0)
			{
				break;
			}

			pindex	cmp=$(cxml),"^<[^/]";
			if (cmp>0)
			{
				static : analyze_xml	$(cxml);
				macro	dxml=$(_xml_);
				do_$(dxml);
				mlet	cstr=$(do_$(dxml));
			}
		}
		mlet	do_blk_text_length="strlen ("$(cstr)")";

		// assembler
		fprint	fout,"// r0=strlen (r1(="$(cstr)"))"$,;
		fprint	fout,"jal$(z)r7	_strlen_r1"$,;
	}
	procedure	do_blk_text_isEmpty
	{
		var		cmp;
		macro	cstr;

		while (true)
		{
			fget_xml;
			macro	cxml=$(fget_xml);
			pindex	cmp=$(cxml),"^</block[ >]";
			if (cmp<=0)
			{
				pindex	cmp=$(cxml),"^<next[ >]";
			}
			if (cmp>0)
			{
				break;
			}

			pindex	cmp=$(cxml),"^<[^/]";
			if (cmp>0)
			{
				static : analyze_xml	$(cxml);
				macro	dxml=$(_xml_);
				do_$(dxml);
				mlet	cstr=$(do_$(dxml));
			}
		}
		mlet	do_blk_text_isEmpty="isempty ("$(cstr)")";

		// assembler
		fprint	fout,"// r0=isempty (r1(="$(cstr)"))"$,;
		fprint	fout,"ldb	r0,[r1]"$,;
		fprint	fout,"cmpi	r0,0"$,;
		fprint	fout,"ldbiu	r0,true"$,;
		fprint	fout,"beq	pcnt+2"$,;
		fprint	fout,"ldbiu	r0,false"$,;
	}
	procedure	do_blk_text_print
	{
		var		cmp;
		macro	cstr;

		while (true)
		{
			fget_xml;
			macro	cxml=$(fget_xml);
			pindex	cmp=$(cxml),"^</block[ >]";
			if (cmp<=0)
			{
				pindex	cmp=$(cxml),"^<next[ >]";
			}
			if (cmp>0)
			{
				break;
			}

			pindex	cmp=$(cxml),"^<[^/]";
			if (cmp>0)
			{
				static : analyze_xml	$(cxml);
				macro	dxml=$(_xml_);
				do_$(dxml);
				mlet	cstr=$(do_$(dxml));
			}
		}

		// string?
		strcmp	cmp=$(cstr),$",left;
		if (cmp)
		{
			is_cstr		$(cstr);
			if (is_cstr)
			{
				cmp=0;
			}
		}
		if (cmp=0)
		{
			// string or string variable

			// assembler
			fprint	fout,"// print r1(="$(cstr)")"$,;
			fprint	fout,"jal$(z)r7	_print_r1"$,;
		}
		else
		{
			// done?
			strcmp	cmp=$(cstr),"'",left;
			if (cmp=0)
			{
				// already done, just print

				// assembler
				fprint	fout,"// print r1(="$(cstr)")"$,;
				fprint	fout,"jal$(z)r7	_print_r1"$,;
			}
			else
			{
				// join?
				strcmp	cmp=$(cstr)," ++ ",left;
				if (cmp=0)
				{
					// join
					psub	"^ \+\+ ","",cstr;

					// assembler
					fprint	fout,"// print r1(="$(cstr)")"$,;
					fprint	fout,"jal$(z)r7	_print_r1"$,;
				}
				else
				{
					// number
					register_vars	"_tmp_str";
					register_cstr	"_tmp_str";

					// assembler
					fprint	fout,"// r1=r0(="$(cstr)")"$,;
					fprint	fout,"mov	r1,r0"$,;
					asm_ld_var	"r0","_tmp_str";
					fprint	fout,"// r0=strdec (r0,r1(="$(cstr)"))"$,;
					fprint	fout,"jal$(z)r7	_strdec_r0_r1"$,;
					asm_ld_var	"r1","_tmp_str";
					fprint	fout,"// print r1(='"$(cstr)"')"$,;
					fprint	fout,"jal$(z)r7	_print_r1"$,;

					mlet	cstr="'"$(cstr)"'";
				}
			}
		}
	}
	procedure	do_blk_text_join
	{
		var		cmp;
		macro	cstr;

		// nesting check
		nvar	in_text_join=false;
		if (in_text_join)
		{
			// ERROR:
			errmsg	"text_join: nesting";
			leave	stop_error;
		}
		in_text_join=true;

		// assembler
		fprint	fout,""$,;
		fprint	fout,"// join"$,;
		if (!in_var_set)
		{
			register_vars	"_tmp_str";
			register_cstr	"_tmp_str";

			// assembler
			asm_ld_var	"r0","_tmp_str";
		}
		fprint	fout,"push$(z)	r0"$,;

		while (true)
		{
			var		in_var_set=true;

			fget_xml;
			macro	cxml=$(fget_xml);
			pindex	cmp=$(cxml),"^</block[ >]";
			if (cmp<=0)
			{
				pindex	cmp=$(cxml),"^<next[ >]";
			}
			if (cmp>0)
			{
				break;
			}

			pindex	cmp=$(cxml),"^<[^/]";
			if (cmp>0)
			{
				static : analyze_xml	$(cxml);
				macro	dxml=$(_xml_);
				do_$(dxml);
				strcmp	cmp=$(dxml),"value";
				if (cmp=0)
				{
					mlet	cstr=$(do_$(dxml));

					// string?
					strcmp	cmp=$(cstr),$",left;
					if (cmp)
					{
						is_cstr		$(cstr);
						if (is_cstr)
						{
							cmp=0;
						}
					}
					if (cmp=0)
					{
						// string or string variable

						// assembler
						fprint	fout,"// join "$(cstr)$,;
						fprint	fout,"pop$(z)	r0"$,;
						fprint	fout,"jal$(z)r7	_strcpy_r0_r1"$,;
						fprint	fout,"push$(z)	r0"$,;
					}
					else
					{
						// done?
						strcmp	cmp=$(cstr),"'",left;
						if (cmp=0)
						{
							// already done
						}
						else
						{
							// number

							// assembler
							fprint	fout,"// r1=r0(="$(cstr)")"$,;
							fprint	fout,"mov	r1,r0"$,;
							fprint	fout,"// r0=strdec (r0,r1(="$(cstr)"))"$,;
							fprint	fout,"pop$(z)	r0"$,;
							fprint	fout,"jal$(z)r7	_strdec_r0_r1"$,;
							fprint	fout,"push$(z)	r0"$,;

							mlet	cstr="'"$(cstr)"'";
						}
					}
					mlet	do_blk_text_join=$(do_blk_text_join)" ++ "$(cstr);
				}
			}
		}

		// assembler
		mlet	cstr=$(do_blk_text_join);
		sub		" ++ ","",cstr;
		fprint	fout,"// end of join ("$(cstr)")"$,;
		fprint	fout,"pop$(z)	r0	// discard"$,;
		if (!in_var_set)
		{
			asm_ld_var	"r1","_tmp_str";
		}
	}
	procedure	do_blk_text_append
	{
		var		cmp;
		macro	vnam;
		macro	cstr;

		in_var_set=true;
		while (true)
		{
			fget_xml;
			macro	cxml=$(fget_xml);
			pindex	cmp=$(cxml),"^</block[ >]";
			if (cmp<=0)
			{
				pindex	cmp=$(cxml),"^<next[ >]";
			}
			if (cmp>0)
			{
				break;
			}

			pindex	cmp=$(cxml),"^<[^/]";
			if (cmp>0)
			{
				static : analyze_xml	$(cxml);
				macro	dxml=$(_xml_);
				do_$(dxml);
				strcmp	cmp=$(dxml),"field";
				if (cmp=0)
				{
					mlet	vnam=$(do_$(dxml));

					// assembler
					asm_ld_var	"r0",$(vnam);
					fprint	fout,"// r0=tail of string "$(vnam)$,;
					fprint	fout,"ldb	r7,[r0]"$,;
					fprint	fout,"addi	r0,1"$,;
					fprint	fout,"cmpi	r7,0"$,;
					fprint	fout,"bne	pcnt-8"$,;
					fprint	fout,"subi	r0,1"$,;
					fprint	fout,"push$(z)	r0"$,;
				}
				strcmp	cmp=$(dxml),"value";
				if (cmp=0)
				{
					mlet	cstr=$(do_$(dxml));
				}
			}
		}
		in_var_set=false;

		// string variable += <string>
		strcmp	cmp=$(cstr),"'", left;
		if (cmp=0)
		{
			// already processed (number ==> string)
			fprint	fout,"pop$(z)	r0	// discard"$,;
		}
		else
		{
			strcmp	cmp=$(cstr)," ++ ",left;
			if (cmp=0)
			{
				// joined
				psub	"^ \+\+ ","",cstr;

				// assembler
				fprint	fout,"// end of "$(vnam)"="$(cstr)$,;
				fprint	fout,"pop$(z)	r0	// discard"$,;
			}
			else
			{
				// not joined
				pindex	cmp=$(cstr),"^"$""[^"$""]*"$""$";
				if (cmp<=0)
				{
					// not a string constant
					is_cstr		$(cstr);
					if (is_cstr)
					{
						// string variable
						cmp=1;
					}
				}
				if (cmp>0)
				{
					// string constant or string variable

					// assembler
					fprint	fout,"// end of "$(vnam)"="$(cstr)$,;
					fprint	fout,"pop$(z)	r0"$,;
					fprint	fout,"jal$(z)r7	_strcpy_r0_r1"$,;
				}
				else
				{
					// number

					// assembler
					fprint	fout,"// r1=r0(="$(cstr)")"$,;
					fprint	fout,"mov	r1,r0"$,;
					fprint	fout,"// r0=strdec (r0,r1(="$(cstr)"))"$,;
					fprint	fout,"pop$(z)	r0"$,;
					fprint	fout,"jal$(z)r7	_strdec_r0_r1"$,;
				}
			}
		}
	}
	procedure	do_blk_procedures_ifreturn
	{
		var		cmp;
		macro	cexp;
		macro	vrtn;

		// assembler
		labid=labid + 1;
		macro	slabid;
		num2str		slabid=labid,"%04x";
		fprint	fout,""$,;
		fprint	fout,"// if return"$,;

		while (true)
		{
			fget_xml;
			macro	cxml=$(fget_xml);
			pindex	cmp=$(cxml),"^</block[ >]";
			if (cmp<=0)
			{
				pindex	cmp=$(cxml),"^<next[ >]";
			}
			if (cmp>0)
			{
				break;
			}

			pindex	cmp=$(cxml),"^<[^/]";
			if (cmp>0)
			{
				static : analyze_xml	$(cxml);
				macro	dxml=$(_xml_);
				nmacro	_xml_name;
				macro	dnam=$(_xml_name);
				do_$(dxml);
				strcmp	cmp=$(dxml),"value";
				if (cmp=0)
				{
					strcmp	cmp=$(dnam),"CONDITION";
					if (cmp=0)
					{
						mlet	cexp=$(do_$(dxml));

						// assembler
						fprint	fout,"// if ("$(cexp)")"$,;
						fprint	fout,"cmpi	r0,false"$,;
						fprint	fout,"beq	_auto_"$(slabid)"_endif"$,;
					}
					strcmp	cmp=$(dnam),"VALUE";
					if (cmp=0)
					{
						mlet	vrtn=$(do_$(dxml));
					}
				}
			}
		}

		// assembler
		strcmp	cmp=$(vrtn),"";
		if (cmp)
		{
			fprint	fout,"// return ("$(vrtn)")"$,;
		}
		else
		{
			fprint	fout,"// return"$,;
		}
		fprint	fout,"rtn$(z)"$,;
		fprint	fout,""$,;
		fprint	fout,"_auto_"$(slabid)"_endif:"$,;
	}
	procedure	do_blk_procedures_defreturn
	{
		var		cmp;
		var		stat;
		macro	fnam;
		macro	muta;
		macro	vrtn;

		while (true)
		{
			fget_xml;
			macro	cxml=$(fget_xml);
			if (stat=0)
			{
				pindex	cmp=$(cxml),"^<statement[ >]";
				if (cmp<=0)
				{
					pindex	cmp=$(cxml),"^<next[ >]";
				}
				if (cmp<=0)
				{
					pindex	cmp=$(cxml),"^</block[ >]";
				}
				if (cmp>0)
				{
					// continue
					pindex	cmp=$(cxml),"^<statement[ >]";
					if (cmp>0)
					{
						stat=1;
						continue;
					}
					else
					{
						// empty block
						stat=2;
					}
				}
			}
			if (stat=1)
			{
				// function block
				pindex	cmp=$(cxml),"^</statement[ >]";
				if (cmp>0)
				{
					// end of loop
					stat=2;
					continue;
				}
			}
			if (stat=2)
			{
				pindex	cmp=$(cxml),"^<next[ >]";
				if (cmp<=0)
				{
					pindex	cmp=$(cxml),"^</block[ >]";
				}
				if (cmp>0)
				{
					// end of function

					// assembler
					fprint	fout,""$,;
					fprint	fout,"// end of function: "$(fnam)$,;
					strcmp	cmp=$(vrtn),"";
					if (cmp)
					{
						fprint	fout,"// return ("$(vrtn)")"$,;
					}
					fprint	fout,"rtn$(z)"$,;

					break;
				}
			}

			pindex	cmp=$(cxml),"^<[^/]";
			if (cmp>0)
			{
				static : analyze_xml	$(cxml);
				macro	dxml=$(_xml_);
				do_$(dxml);
				if (stat=0)
				{
					strcmp	cmp=$(dxml),"mutation";
					if (cmp=0)
					{
						mlet	muta=$(do_$(dxml));
					}
					strcmp	cmp=$(dxml),"field";
					if (cmp=0)
					{
						mlet	fnam=$(do_$(dxml));
						
						// assembler
						if (defp_1st)
						{
							defp_1st=false;
							fprint	fout,""$,;
							fprint	fout,"// halt"$,;
							fprint	fout,"jmpr7	_rtlb_prog_halt"$,;
						}
						fprint	fout,""$,;
						fprint	fout,"// function: "$(fnam);
						strcmp	cmp=$(muta),"";
						if (cmp)
						{
							psub	" $","",muta;
							pgsub	" ",", ",muta;
							fprint	fout," ("$(muta)")";
						}
						fprint	fout,""$,;
						fprint	fout,"align	4"$,;
						fprint	fout,$(fnam)":"$,;
					}
				}
				if (true | stat=2)
				{
					strcmp	cmp=$(dxml),"value";
					if (cmp=0)
					{
						mlet	vrtn=$(do_$(dxml));
					}
				}
			}
		}
	}
	procedure	do_blk_procedures_defnoreturn
	{
		do_blk_procedures_defreturn;
	}
	procedure	do_blk_procedures_callreturn
	{
		var		cmp;
		macro	fnam;
		macro	muta;

		while (true)
		{
			fget_xml;
			macro	cxml=$(fget_xml);
			pindex	cmp=$(cxml),"^</block[ >]";
			if (cmp<=0)
			{
				pindex	cmp=$(cxml),"^<next[ >]";
			}
			if (cmp>0)
			{
				break;
			}

			pindex	cmp=$(cxml),"^<[^/]";
			if (cmp>0)
			{
				static : analyze_xml	$(cxml);
				macro	dxml=$(_xml_);
				nmacro	_xml_name;
				macro	dnam=$(_xml_name);
				do_$(dxml);
				strcmp	cmp=$(dxml),"mutation";
				if (cmp=0)
				{
					mlet	fnam=$(dnam);
					mlet	muta=$(do_$(dxml));
					psub	" $","",muta;
				}
				strcmp	cmp=$(dxml),"value";
				if (cmp=0)
				{
					var		num;
					var		narg;

					field	num=muta;
					psub	"[^0-9]*([0-9]+).*","\1",dnam;
					narg=$(dnam) + 1;

					// variable type check
					is_cstr		$(muta#(narg));
					if (is_cstr)
					{
						// ERROR:
						errmsg	"procedures_callreturn: "
								"inhibited string parameter ("$(muta#(narg))")";
						leave	stop_error;
					}

					// assembler
					fprint	fout,"// "$(muta#(narg))"=r0(="$(do_$(dxml))")"$,;
					asm_ld_var_adr	"r7",$(muta#(narg));
					fprint	fout,"st$(z)	[r7],r0"$,;
				}
			}
		}
		mlet	do_blk_procedures_callreturn=$(fnam);

		// assembler
		fprint	fout,"// function call: "$(fnam)$,;
		fprint	fout,"jal$(z)r7	"$(fnam)$,;
	}
	procedure	do_blk_procedures_callnoreturn
	{
		do_blk_procedures_callreturn;
	}
	procedure	do_blk_controls_repeat
	{
		do_blk_controls_repeat_ext;
	}
	procedure	do_blk_controls_repeat_ext
	{
		var		cmp;
		var		stat;
		var		ld_rpt;
		macro	rcnt;

		// register control variable
		register_vars	"_rpt_cnt";

		// assembler
		labid=labid + 1;
		macro	slabid;
		num2str		slabid=labid,"%04x";
		macro	slabid_loop=$(slabid);
		fprint	fout,""$,;
		fprint	fout,"// repeat loop"$,;

		while (true)
		{
			fget_xml;
			macro	cxml=$(fget_xml);
			if (stat=0)
			{
				pindex	cmp=$(cxml),"^<statement[ >]";
				if (cmp<=0)
				{
					pindex	cmp=$(cxml),"^<next[ >]";
				}
				if (cmp<=0)
				{
					pindex	cmp=$(cxml),"^</block[ >]";
				}
				if (cmp>0)
				{
					// loop condition

					// assembler
					fprint	fout,"// backup _rpt_cnt variable"$,;
					asm_ld_var	"r1","_rpt_cnt", "r7";
					fprint	fout,"push$(z)	r1"$,;
					if (ld_rpt)
					{
						fprint	fout,"// r0="$(rcnt)$,;
						fprint	fout,"ld$(z)i	r0,"$(rcnt)$,;
					}
					fprint	fout,"// _rpt_cnt=r0(="$(rcnt)")"$,;
					fprint	fout,"st$(z)	[r7],r0"$,;
					fprint	fout,"// r0(=_rpt_cnt)<1 ?"$,;
					fprint	fout,"cmpi	r0,1"$,;
					fprint	fout,"blt	_auto_"$(slabid)"_break"$,;
					fprint	fout,"// repeat ("$(rcnt)")"$,;
					fprint	fout,"_auto_"$(slabid)"_repeat:"$,;

					// continue
					pindex	cmp=$(cxml),"^<statement[ >]";
					if (cmp>0)
					{
						stat=1;
						continue;
					}
					else
					{
						// empty block
						stat=2;
					}
				}
			}
			if (stat=1)
			{
				// loop block
				pindex	cmp=$(cxml),"^</statement[ >]";
				if (cmp>0)
				{
					// end of loop
					stat=2;
					continue;
				}
			}
			if (stat=2)
			{
				pindex	cmp=$(cxml),"^<next[ >]";
				if (cmp<=0)
				{
					pindex	cmp=$(cxml),"^</block[ >]";
				}
				if (cmp>0)
				{
					// end of loop

					// assembler
					fprint	fout,""$,;
					fprint	fout,"// end of repeat loop"$,;
					fprint	fout,"_auto_"$(slabid)"_continue:"$,;
					asm_ld_var	"r0","_rpt_cnt", "r7";
					fprint	fout,"subi	r0,1"$,;
					fprint	fout,"st$(z)	[r7],r0"$,;
					fprint	fout,"bne	_auto_"$(slabid)"_repeat"$,;
					fprint	fout,""$,;
					fprint	fout,"_auto_"$(slabid)"_break:"$,;
					fprint	fout,"// restore _rpt_cnt variable"$,;
					asm_ld_var_adr	"r7","_rpt_cnt";
					fprint	fout,"pop$(z)	r0"$,;
					fprint	fout,"st$(z)	[r7],r0"$,;
					num2str		slabid_loop=0,"%04x";

					break;
				}
			}

			pindex	cmp=$(cxml),"^<[^/]";
			if (cmp>0)
			{
				static : analyze_xml	$(cxml);
				macro	dxml=$(_xml_);
				do_$(dxml);
				if (stat=0)
				{
					strcmp	cmp=$(dxml),"field";
					if (cmp)
					{
						strcmp	cmp=$(dxml),"value";
					}
					if (cmp=0)
					{
						mlet	rcnt=$(do_$(dxml));
						strcmp	cmp=$(dxml),"field";
						ld_rpt=( cmp=0 );
					}
				}
			}
		}
	}
	procedure	do_blk_controls_for
	{
		var		cmp;
		var		stat;
		macro	vnam;
		macro	vsta;
		macro	vend;
		macro	vstp;

		// assembler
		labid=labid + 1;
		macro	slabid;
		num2str		slabid=labid,"%04x";
		macro	slabid_loop=$(slabid);
		fprint	fout,""$,;
		fprint	fout,"// for loop"$,;

		while (true)
		{
			fget_xml;
			macro	cxml=$(fget_xml);
			if (stat=0)
			{
				pindex	cmp=$(cxml),"^<statement[ >]";
				if (cmp<=0)
				{
					pindex	cmp=$(cxml),"^<next[ >]";
				}
				if (cmp<=0)
				{
					pindex	cmp=$(cxml),"^</block[ >]";
				}
				if (cmp>0)
				{
					// loop condition
					strcmp	cmp=$(vstp),"";
					if (cmp=0)
					{
						mlet	vstp="1";

						// assembler
						fprint	fout,"// r0="$(vstp)$,;
						fprint	fout,"ld$(z)i	r0,"$(vstp)$,;
					}

					// assembler
					macro	fi;
					if (opt_opr_typ=opt_float)
					{
						mlet	fi="f";
					}
					fprint	fout,"// r2=r4=r0(="$(vstp)"); r1(="$(vend)")"$,;
					fprint	fout,"mov	r2,r0"$,;
					fprint	fout,"mov	r4,r0"$,;
					fprint	fout,"pop$(z)	r1"$,;
					fprint	fout,"// for ("$(vnam)"="$(vsta)"; "$(vend)"; "
							$(vstp)")"$,;
					fprint	fout,"// start mark?"$,;
					fprint	fout,"pop$(z)	r3"$,;
					fprint	fout,"cmpi	r3,false"$,;
					fprint	fout,"beq	pcnt+4"$,;
					fprint	fout,"ldbiu	r3,false"$,;
					fprint	fout,"ldbiu	r2,0"$,;
					fprint	fout,"push$(z)	r3"$,;
					asm_ld_var	"r0",$(vnam), "r7";
					fprint	fout,"// r0(="$(vnam)") += r2(="$(vstp)")"$,;
					fprint	fout,$(fi)"add	r0,r2"$,;
					fprint	fout,"st$(z)	[r7],r0"$,;
					fprint	fout,"// up or down count"$,;
					fprint	fout,"cmpi	r4,0"$,;
					fprint	fout,"blt	pcnt+4"$,;
					fprint	fout,$(fi)"cmp	r1,r0	// up count"$,;
					fprint	fout,"bra	pcnt+2"$,;
					fprint	fout,$(fi)"cmp	r0,r1	// down count"$,;
					fprint	fout,"blt	_auto_"$(slabid)"_break"$,;

					// continue
					pindex	cmp=$(cxml),"^<statement[ >]";
					if (cmp>0)
					{
						stat=1;
						continue;
					}
					else
					{
						// empty block
						stat=2;
					}
				}
			}
			if (stat=1)
			{
				// loop block
				pindex	cmp=$(cxml),"^</statement[ >]";
				if (cmp>0)
				{
					// end of loop
					stat=2;
					continue;
				}
			}
			if (stat=2)
			{
				pindex	cmp=$(cxml),"^<next[ >]";
				if (cmp<=0)
				{
					pindex	cmp=$(cxml),"^</block[ >]";
				}
				if (cmp>0)
				{
					// end of loop

					// assembler
					fprint	fout,""$,;
					fprint	fout,"// end of for loop"$,;
					fprint	fout,"bra	_auto_"$(slabid)"_for"$,;
					fprint	fout,""$,;
					fprint	fout,"_auto_"$(slabid)"_break:"$,;
					fprint	fout,"pop$(z)	r3	// discard"$,;
					num2str		slabid_loop=0,"%04x";

					break;
				}
			}

			pindex	cmp=$(cxml),"^<[^/]";
			if (cmp>0)
			{
				static : analyze_xml	$(cxml);
				macro	dxml=$(_xml_);
				nmacro	_xml_name;
				macro	dnam=$(_xml_name);
				do_$(dxml);
				if (stat=0)
				{
					strcmp	cmp=$(dxml),"field";
					if (cmp=0)
					{
						mlet	vnam=$(do_$(dxml));
					}
					strcmp	cmp=$(dxml),"value";
					if (cmp=0)
					{
						strcmp	cmp=$(dnam),"FROM";
						if (cmp=0)
						{
							mlet	vsta=$(do_$(dxml));

							// assembler
							fprint	fout,"// "$(vnam)"=r0(="$(vsta)")"$,;
							asm_ld_var_adr	"r7",$(vnam);
							fprint	fout,"st$(z)	[r7],r0"$,;
							fprint	fout,"// set start mark"$,;
							fprint	fout,"ldbiu	r3,true"$,;
							fprint	fout,"push$(z)	r3"$,;
							fprint	fout,"_auto_"$(slabid)"_for:"$,;
							fprint	fout,"_auto_"$(slabid)"_continue:"$,;
						}
						strcmp	cmp=$(dnam),"TO";
						if (cmp=0)
						{
							mlet	vend=$(do_$(dxml));

							// assembler
							fprint	fout,"push$(z)	r0"$,;
						}
						strcmp	cmp=$(dnam),"BY";
						if (cmp=0)
						{
							mlet	vstp=$(do_$(dxml));
						}
					}
				}
			}
		}
	}
	procedure	do_blk_controls_while
	{
		do_blk_controls_whileUntil;
	}
	procedure	do_blk_controls_whileUntil
	{
		var		cmp;
		var		stat;
		macro	wexp;
		macro	wmod=$(str_whl);

		// assembler
		labid=labid + 1;
		macro	slabid;
		num2str		slabid=labid,"%04x";
		macro	slabid_loop=$(slabid);
		fprint	fout,""$,;
		fprint	fout,"// while/until loop"$,;
		fprint	fout,"_auto_"$(slabid)"_while:"$,;
		fprint	fout,"_auto_"$(slabid)"_continue:"$,;

		while (true)
		{
			fget_xml;
			macro	cxml=$(fget_xml);
			if (stat=0)
			{
				pindex	cmp=$(cxml),"^<statement[ >]";
				if (cmp<=0)
				{
					pindex	cmp=$(cxml),"^<next[ >]";
				}
				if (cmp<=0)
				{
					pindex	cmp=$(cxml),"^</block[ >]";
				}
				if (cmp>0)
				{
					// loop condition

					// assembler
					fprint	fout,"// "$(wmod)" ("$(wexp)")"$,;
					fprint	fout,"cmpi	r0,false"$,;
					strcmp	cmp=$(wmod),"until";
					if (cmp)
					{
						// while
						fprint	fout,"beq	_auto_"$(slabid)"_break"$,;
					}
					else
					{
						// until
						fprint	fout,"bne	_auto_"$(slabid)"_break"$,;
					}

					// continue
					pindex	cmp=$(cxml),"^<statement[ >]";
					if (cmp>0)
					{
						stat=1;
						continue;
					}
					else
					{
						// empty block
						stat=2;
					}
				}
			}
			if (stat=1)
			{
				// loop block
				pindex	cmp=$(cxml),"^</statement[ >]";
				if (cmp>0)
				{
					// end of loop block
					stat=2;
					continue;
				}
			}
			if (stat=2)
			{
				pindex	cmp=$(cxml),"^<next[ >]";
				if (cmp<=0)
				{
					pindex	cmp=$(cxml),"^</block[ >]";
				}
				if (cmp>0)
				{
					// end of loop

					// assembler
					fprint	fout,""$,;
					fprint	fout,"// end of "$(wmod)" loop"$,;
					fprint	fout,"bra	_auto_"$(slabid)"_while"$,;
					fprint	fout,""$,;
					fprint	fout,"_auto_"$(slabid)"_break:"$,;
					num2str		slabid_loop=0,"%04x";

					break;
				}
			}

			pindex	cmp=$(cxml),"^<[^/]";
			if (cmp>0)
			{
				static : analyze_xml	$(cxml);
				macro	dxml=$(_xml_);
				do_$(dxml);
				if (stat=0)
				{
					strcmp	cmp=$(dxml),"field";
					if (cmp=0)
					{
						mlet	wmod=$(do_$(dxml));
						tolower		wmod;
					}
					strcmp	cmp=$(dxml),"value";
					if (cmp=0)
					{
						mlet	wexp=$(do_$(dxml));
					}
				}
			}
		}
	}
	procedure	do_blk_mcoc_controls_dorept
	{
		var		cmp;
		var		stat;
		macro	wexp;
		macro	wmod=$(str_whl);

		// assembler
		labid=labid + 1;
		macro	slabid;
		num2str		slabid=labid,"%04x";
		macro	slabid_loop=$(slabid);
		fprint	fout,""$,;
		fprint	fout,"// do while/until loop"$,;
		fprint	fout,"_auto_"$(slabid)"_dorep:"$,;

		while (true)
		{
			fget_xml;
			macro	cxml=$(fget_xml);
			if (stat=0)
			{
				pindex	cmp=$(cxml),"^<statement[ >]";
				if (cmp<=0)
				{
					pindex	cmp=$(cxml),"^<next[ >]";
				}
				if (cmp<=0)
				{
					pindex	cmp=$(cxml),"^</block[ >]";
				}
				if (cmp>0)
				{
					// continue
					pindex	cmp=$(cxml),"^<statement[ >]";
					if (cmp>0)
					{
						// assembler
						fprint	fout,"// do block"$,;

						stat=1;
						continue;
					}
					else
					{
						// empty block
						stat=2;
					}
				}
			}
			if (stat=1)
			{
				// loop block
				pindex	cmp=$(cxml),"^</statement[ >]";
				if (cmp>0)
				{
					// end of loop block
					stat=2;
					continue;
				}
			}
			if (stat=2)
			{
				pindex	cmp=$(cxml),"^<next[ >]";
				if (cmp<=0)
				{
					pindex	cmp=$(cxml),"^</block[ >]";
				}
				if (cmp>0)
				{
					// end of loop
					break;
				}
			}

			pindex	cmp=$(cxml),"^<[^/]";
			if (cmp>0)
			{
				static : analyze_xml	$(cxml);
				macro	dxml=$(_xml_);
				strcmp	cmp=$(dxml),"value";
				if (cmp=0)
				{
					// end of do repeat

					// assembler
					if (stat=0)
					{
						// empty block

						// assembler
						fprint	fout,"// do block"$,;
					}
					fprint	fout,""$,;
					fprint	fout,"// end of do "$(wmod)" loop"$,;
					fprint	fout,"_auto_"$(slabid)"_continue:"$,;
				}
				do_$(dxml);
				if (stat=0)
				{
					strcmp	cmp=$(dxml),"field";
					if (cmp=0)
					{
						mlet	wmod=$(do_$(dxml));
						tolower		wmod;
					}
				}
				strcmp	cmp=$(dxml),"value";
				if (cmp=0)
				{
					// loop condition
					mlet	wexp=$(do_$(dxml));

					// assembler
					fprint	fout,"// "$(wmod)" ("$(wexp)")"$,;
					fprint	fout,"cmpi	r0,false"$,;
					strcmp	cmp=$(wmod),"until";
					if (cmp)
					{
						// while
						fprint	fout,"bne	_auto_"$(slabid)"_dorep"$,;
					}
					else
					{
						// until
						fprint	fout,"beq	_auto_"$(slabid)"_dorep"$,;
					}
					fprint	fout,""$,;
					fprint	fout,"_auto_"$(slabid)"_break:"$,;
					num2str		slabid_loop=0,"%04x";
				}
			}
		}
		strcmp	cmp=$(wexp),"";
		if (cmp=0)
		{
			// ERROR:
			errmsg	"controls_dorept: empty condition";
			leave	stop_error;
		}
	}
	procedure	do_blk_mcoc_controls_loop
	{
		var		cmp;
		var		stat;
		macro	wexp;

		// assembler
		labid=labid + 1;
		macro	slabid;
		num2str		slabid=labid,"%04x";
		macro	slabid_loop=$(slabid);
		fprint	fout,""$,;
		fprint	fout,"// forever loop"$,;
		fprint	fout,"_auto_"$(slabid)"_loop:"$,;
		fprint	fout,"_auto_"$(slabid)"_continue:"$,;
		fprint	fout,"_auto_"$(slabid)"_break:"$,;

		while (true)
		{
			fget_xml;
			macro	cxml=$(fget_xml);
			if (stat=0)
			{
				pindex	cmp=$(cxml),"^<statement[ >]";
				if (cmp<=0)
				{
					pindex	cmp=$(cxml),"^<next[ >]";
				}
				if (cmp<=0)
				{
					pindex	cmp=$(cxml),"^</block[ >]";
				}
				if (cmp>0)
				{
					// loop condition

					// assembler
					fprint	fout,"// loop"$,;

					// continue
					pindex	cmp=$(cxml),"^<statement[ >]";
					if (cmp>0)
					{
						stat=1;
						continue;
					}
					else
					{
						// empty block
						stat=2;
					}
				}
			}
			if (stat=1)
			{
				// loop block
				pindex	cmp=$(cxml),"^</statement[ >]";
				if (cmp>0)
				{
					// end of loop block
					stat=2;
					continue;
				}
			}
			if (stat=2)
			{
				pindex	cmp=$(cxml),"^<next[ >]";
				if (cmp<=0)
				{
					pindex	cmp=$(cxml),"^</block[ >]";
				}
				if (cmp>0)
				{
					// end of loop

					// assembler
					fprint	fout,""$,;
					fprint	fout,"// end of forever loop"$,;
					fprint	fout,"bra	_auto_"$(slabid)"_loop"$,;
					num2str		slabid_loop=0,"%04x";

					break;
				}
			}

			pindex	cmp=$(cxml),"^<[^/]";
			if (cmp>0)
			{
				static : analyze_xml	$(cxml);
				macro	dxml=$(_xml_);
				do_$(dxml);
			}
		}
	}
	procedure	do_blk_controls_flow_statements
	{
		var		cmp;
		macro	flws;

		while (true)
		{
			fget_xml;
			macro	cxml=$(fget_xml);
			pindex	cmp=$(cxml),"^</block[ >]";
			if (cmp>0)
			{
				break;
			}

			pindex	cmp=$(cxml),"^<[^/]";
			if (cmp>0)
			{
				static : analyze_xml	$(cxml);
				macro	dxml=$(_xml_);
				do_$(dxml);
				strcmp	cmp=$(dxml),"field";
				if (cmp=0)
				{
					mlet	flws=$(do_$(dxml));
				}
			}
		}
		tolower		flws;

		// assembler
		fprint	fout,"// "$(flws)$,;
		fprint	fout,"bra	_auto_"$(slabid_loop)"_"$(flws)$,;
	}
	procedure	do_blk_controls_if
	{
		var		idx;
		var		cmp;
		var		stat;
		var		cnt_elif;
		var		cnt_else;
		macro	cexp;

		// assembler
		labid=labid + 1;
		macro	slabid;
		num2str		slabid=labid,"%04x";
		fprint	fout,""$,;
		fprint	fout,"// if statement"$,;

		// if
		while (true)
		{
			fget_xml;
			macro	cxml=$(fget_xml);
			if (stat=0)
			{
				pindex	cmp=$(cxml),"^<statement[ >]";
				if (cmp<=0)
				{
					pindex	cmp=$(cxml),"^<next[ >]";
				}
				if (cmp<=0)
				{
					pindex	cmp=$(cxml),"^</block[ >]";
				}
				if (cmp>0)
				{
					// if condition
					static : analyze_xml	$(cxml);
					nmacro	_xml_name;
					strcmp	cmp=$(_xml_name),"DO0";
					if (cmp)
					{
						// ERROR:
						errmsg	"controls_if: inhibited empty if block";
						leave	stop_error;
					}
					strcmp	cmp=$(cexp),"";
					if (cmp=0)
					{
						// ERROR:
						errmsg	"controls_if: if condition not found";
						leave	stop_error;
					}

					// assembler
					fprint	fout,"// if ("$(cexp)")"$,;
					fprint	fout,"cmpi	r0,false"$,;
					fprint	fout,"beq	_auto_"$(slabid)"_if0"$,;

					// continue
					pindex	cmp=$(cxml),"^<statement[ >]";
					if (cmp>0)
					{
						stat=1;
						continue;
					}
					else
					{
						// ERROR:
						errmsg	"controls_if: inhibited empty if block";
						leave	stop_error;
					}
				}
			}
			if (stat=1)
			{
				// if block
				pindex	cmp=$(cxml),"^</statement[ >]";
				if (cmp>0)
				{
					// end of if block

					// assembler
					fprint	fout,""$,;
					fprint	fout,"// end of if block"$,;
					fprint	fout,"bra	_auto_"$(slabid)"_endif"$,;
					fprint	fout,""$,;
					fprint	fout,"_auto_"$(slabid)"_if0:"$,;

					break;
				}
			}

			pindex	cmp=$(cxml),"^<[^/]";
			if (cmp>0)
			{
				static : analyze_xml	$(cxml);
				macro	dxml=$(_xml_);
				if (stat=0)
				{
					// mutation must be processed before calling do_$(dxml)
					strcmp	cmp=$(dxml),"mutation";
					if (cmp=0)
					{
						nmacro	_xml_elseif="0";
						nmacro	_xml_else="0";
						cnt_elif=$(_xml_elseif);
						cnt_else=$(_xml_else);
					}
				}
				do_$(dxml);
				if (stat=0)
				{
					strcmp	cmp=$(dxml),"value";
					if (cmp=0)
					{
						mlet	cexp=$(do_$(dxml));
					}
				}
			}
		}

		// elif
		idx=1;
		while (idx<=cnt_elif)
		{
			stat=0;
			mlet	cexp="";
			while (true)
			{
				fget_xml;
				macro	cxml=$(fget_xml);
				if (stat=0)
				{
					pindex	cmp=$(cxml),"^<statement[ >]";
					if (cmp<=0)
					{
						pindex	cmp=$(cxml),"^<next[ >]";
					}
					if (cmp<=0)
					{
						pindex	cmp=$(cxml),"^</block[ >]";
					}
					if (cmp>0)
					{
						// elif condition
						static : analyze_xml	$(cxml);
						strcmp	cmp=$(_xml_name),"DO"#(idx);
						if (cmp)
						{
							// ERROR:
							errmsg	"controls_if: inhibited empty elif# block",
									idx;
							leave	stop_error;
						}
						strcmp	cmp=$(cexp),"";
						if (cmp=0)
						{
							// ERROR:
							errmsg	"controls_if: elif# condition not found",
									idx;
							leave	stop_error;
						}

						// assembler
						fprint	fout,"// elif# ("$(cexp)")"$,,idx;
						fprint	fout,"cmpi	r0,false"$,;
						fprint	fout,"beq	_auto_"$(slabid)"_elif#"$,,idx;

						// continue
						pindex	cmp=$(cxml),"^<statement[ >]";
						if (cmp>0)
						{
							stat=1;
							continue;
						}
						else
						{
							// ERROR:
							errmsg	"controls_if: inhibited empty elif# block",
									idx;
							leave	stop_error;
						}
					}
				}
				if (stat=1)
				{
					// elif block
					pindex	cmp=$(cxml),"^</statement[ >]";
					if (cmp>0)
					{
						// end of elif block

						// assembler
						fprint	fout,""$,;
						fprint	fout,"// end of elif# block"$,,idx;
						fprint	fout,"bra	_auto_"$(slabid)"_endif"$,;
						fprint	fout,""$,;
						fprint	fout,"_auto_"$(slabid)"_elif#:"$,,idx;

						break;
					}
				}

				pindex	cmp=$(cxml),"^<[^/]";
				if (cmp>0)
				{
					static : analyze_xml	$(cxml);
					macro	dxml=$(_xml_);
					do_$(dxml);
					if (stat=0)
					{
						strcmp	cmp=$(dxml),"value";
						if (cmp=0)
						{
							mlet	cexp=$(do_$(dxml));
						}
					}
				}
			}

			// continue
			idx=idx + 1;
		}

		// else
		if (cnt_else>0)
		{
			stat=0;
			while (true)
			{
				fget_xml;
				macro	cxml=$(fget_xml);
				if (stat=0)
				{
					pindex	cmp=$(cxml),"^<statement[ >]";
					if (cmp<=0)
					{
						pindex	cmp=$(cxml),"^<next[ >]";
					}
					if (cmp<=0)
					{
						pindex	cmp=$(cxml),"^</block[ >]";
					}
					if (cmp>0)
					{
						// else
						static : analyze_xml	$(cxml);
						strcmp	cmp=$(_xml_name),"ELSE";
						if (cmp)
						{
							// ERROR:
							errmsg	"controls_if: inhibited empty else block";
							leave	stop_error;
						}

						// assembler
						fprint	fout,""$,;
						fprint	fout,"// else"$,;

						// continue
						pindex	cmp=$(cxml),"^<statement[ >]";
						if (cmp>0)
						{
							stat=1;
							continue;
						}
						else
						{
							// ERROR:
							errmsg	"controls_if: inhibited empty else block.";
							leave	stop_error;
						}
					}
				}
				if (stat=1)
				{
					// else block
					pindex	cmp=$(cxml),"^</statement[ >]";
					if (cmp>0)
					{
						// end of else block

						// assembler
						fprint	fout,""$,;
						fprint	fout,"// end of else block"$,;

						break;
					}
				}

				pindex	cmp=$(cxml),"^<[^/]";
				if (cmp>0)
				{
					static : analyze_xml	$(cxml);
					macro	dxml=$(_xml_);
					do_$(dxml);
				}
			}
		}
		skip_one	"block";

		// assembler
		fprint	fout,""$,;
		fprint	fout,"// endif"$,;
		fprint	fout,"_auto_"$(slabid)"_endif:"$,;
	}
	procedure	do_block
	{
		var		cmp;

		nmacro	_xml_disabled="";
		strcmp	cmp=$(_xml_disabled),"true";
		if (cmp=0)
		{
			fget_xml;
			pindex	cmp=$(fget_xml),"^<next[ >]";
			if (cmp>0)
			{
				return;
			}
			repeat
			{
				skip_one	"block";
				pindex	cmp=$(fget_xml),"^<next[ >]";
			} until (cmp<=0);
		}
		else
		{
			// block type
			macro	blktyp=$(_xml_type);
			do_blk_$(blktyp);
			mlet	do_block=$(do_blk_$(blktyp));
		}
	}
	procedure	do_xml
	{
		var		cmp;

		fget_xml;
		while (fget_xml>=0)
		{
			static : analyze_xml	$(fget_xml);
			if (!analyze_xml)
			{
				// continue
				fget_xml;
				continue;
			}
			strcmp	cmp=$(_xml_),"";
			if (cmp)
			{
				strcmp	cmp=$(_xml_),"/",left;
			}
			if (cmp)
			{
				strcmp	cmp=$(_xml_),"next";
			}
			if (cmp=0)
			{
				// continue
				fget_xml;
				continue;
			}

			pindex	cmp=$(fget_xml),"^<";
			if (true & cmp>0)
			{
				do_$(_xml_);
			}

			// continue
			fget_xml;
		}
	}


	// open files
	var		fin;
	var		fout;
	fopen	fin,$(fnam_in),"r";
	fopen	fout,$(fnam_out),"w";

	// input file size
	var		fpos;
	var		fsiz;
	fseek	fin,-1;
	ftell	fin,fsiz;
	fseek	fin,0;
	if (fsiz=0)
	{
		// ERROR:
		errmsg	"Empty XML file";
		leave	stop_error;
	}

	// assembler
	fprint	fout,"// "$(prog_name)" ver."$(prog_vers)$,;
	fprint	fout,"//	Blockly.XML file: "$(fnam)"."$(ext)$,;
	fprint	fout,"## assembler"$,;
	fprint	fout,"asm	"$""mcoc_irom.mem"$"$,;
	fprint	fout,"##asm	"$""mcoc_irom.dat2"$"",bit16,list"$,;
	fprint	fout,"##@rom_siz@"$,;
	fprint	fout,"incl	"$""mcoc115.incl"$"$,;
	fprint	fout,"## constants"$,;
	fprint	fout,"equ	_rtlb_mul_need,@mul_need@"$,;
	fprint	fout,"equ	_rtlb_div_need,@div_need@"$,;
	fprint	fout,"equ	_rtlb_fpu_need,@fpu_need@"$,;
	fprint	fout,"equ	_rtlb_iram_need,@iram_need@"$,;
	fprint	fout,"equ	_rtlb_iram_stack,@iram_stack@"$,;
	fprint	fout,"equ	_rtlb_cstr_siz,@cstr_siz@"$,;
	fprint	fout,"equ	_rtlb_isr_bank,@isr_bank@"$,;
	fprint	fout,"equ	_rtlb_uart_baud,@uart_baud@"$,;
	fprint	fout,"## string macros"$,;
	fprint	fout,"def	s,"$""@sim_mod@"$""	// simulation="
			$"$"" / real fpga="$""##"$"$,;
	fprint	fout,"def	z,"$""@cpu_mod@"$""	// access size l(long) / w(word)"$,;
	fprint	fout,"##@vars_def@"$,;
	fprint	fout,""$,;
	fprint	fout,"## include run time library"$,;
	fprint	fout,"incl	"$"$(mynam)".incl"$"$,;
	fprint	fout,"##@incl_lib@"$,;
	fprint	fout,""$,;
	fprint	fout,"// ================================"$,;
	fprint	fout,"// _rtlb_main: start user program code"$,;
	fprint	fout,"// ================================"$,;
	fprint	fout,"align	4"$,;
	fprint	fout,"_rtlb_main:"$,;
	fprint	fout,""$,;

	do_xml;
	progress	"",-1;

	// assembler
	if (defp_1st)
	{
		defp_1st=false;
		fprint	fout,""$,;
		fprint	fout,"// halt"$,;
		fprint	fout,"jmpr7	_rtlb_prog_halt"$,;
	}
	define_cstr;
	fprint	fout,""$,;
	fprint	fout,"// task entry point"$,;
	fprint	fout,"_rtlb_cpu2:"$,;
	if (tsk_def_cpu2)
	{
		fprint	fout,"datw	lab__rtlb_task_cpu2"$,;
	}
	else
	{
		fprint	fout,"datw	_rtlb_null"$,;
	}
	fprint	fout,"_rtlb_poly:"$,;
	if (tsk_def_poly)
	{
		fprint	fout,"datw	lab__rtlb_task_poly"$,;
	}
	else
	{
		fprint	fout,"datw	_rtlb_null"$,;
	}
	fprint	fout,"_rtlb_irq:"$,;
	if (tsk_def_irq)
	{
		fprint	fout,"datw	lab__rtlb_task_irq"$,;
	}
	else
	{
		fprint	fout,"datw	_rtlb_null"$,;
	}
	fprint	fout,"_rtlb_irq2:"$,;
	if (tsk_def_irq2)
	{
		fprint	fout,"datw	lab__rtlb_task_irq2"$,;
	}
	else
	{
		fprint	fout,"datw	_rtlb_null"$,;
	}
	fprint	fout,"_rtlb_irqp:"$,;
	if (tsk_def_irqp)
	{
		fprint	fout,"datw	lab__rtlb_task_irqp"$,;
	}
	else
	{
		fprint	fout,"datw	_rtlb_null"$,;
	}

	// define string constants
	if (n_str_cnst>0)
	{
		var		idx;

		// assembler
		fprint	fout,""$,;
		fprint	fout,"// string constants"$,;

		idx=0;
		while (idx<n_str_cnst)
		{
			// assembler
			macro	slabid;
			num2str		slabid=str_labl#(idx),"%04x";
			fprint	fout,"_auto_"$(slabid)"_text:"$,;
			fprint	fout,"dats	"$"$(str_cnst#(idx))"\0"$"$,;

			// continue
			idx=idx + 1;
		}
	}

	// close files
	fclose	fin;
	fclose	fout;


	// translator options
	opt_cstr_siz=@(opt_cstr_siz);
	clip	opt_cstr_siz=16,32767;
	opt_isr_bank=@(opt_isr_bank);
	clip	opt_isr_bank=0,3;
	opt_uart_baud=@(opt_uart_baud);
	clip	opt_uart_baud=600,2_000_000;
	macro	str_uart_baud;
	num2str		str_uart_baud=opt_uart_baud,"%d";

	// run time library variables
	register_vars	"_rtlb_rand_seed";
	register_vars	"_rtlb_rand_lfsr";

	// Wire variables
	if (need_wire)
	{
		register_vars	"_wire_slv_id";
		register_vars	"_wire_big_end";
		register_vars	"_wire_err_cod";
		register_vars	"_wire_err_ptr";
	}

	// SPI-TFT variables
	if (need_stft)
	{
		register_vars	"_stft_prn_lx";
		register_vars	"_stft_prn_ly";
		register_vars	"_stft_prn_fg";
		register_vars	"_stft_prn_bg";
		register_vars	"_stft_prn_2x2";
		register_vars	"_stft_pix_ptr";
	}

	// embed variable definitions
	fopen	fin,$(fnam_out),"r";
	fopen	fout,$(fnam_tmp),"w";

	fgets	fin,lbuf;
	while (status=0)
	{
		var		cmp;

		pindex	cmp=$(lbuf),"^#@vars_def@$";
		if (cmp>0)
		{
			var		idx;
			var		num;

			// assembler
			fprint	fout,""$,;
			fprint	fout,"## define variables"$,;
			fprint	fout,"equ	_rtlb_var_sizw,2"$,;
			fprint	fout,"equ	_rtlb_var_sizl,4"$,;
			fprint	fout,"equ	_va,0"$,;
			fprint	fout,"equ	_rtlb_var_top,_va"$,;

			psub	"^@","",vlst_vars;
			field	num=vlst_vars,"@";
			idx=1;
			while (idx<num)
			{
				// assembler
				fprint	fout,"equ	"$(vlst_vars#(idx))",_va"$,;
				fprint	fout,"equ	_va,_va+_rtlb_var_siz$(z)"$,;

				// continue
				idx=idx + 1;
			}

			// assembler
			fprint	fout,"## end of define variables"$,;
			fprint	fout,"equ	_rtlb_var_static,_va"$,;
			fprint	fout,""$,;
			fprint	fout,"## define string buffers"$,;

			psub	"^@","",vlst_cstr;
			field	num=vlst_cstr,"@";
			idx=1;
			while (idx<num)
			{
				// assembler
				fprint	fout,"equ	_cstr_"$(vlst_cstr#(idx))",_va"$,;
				fprint	fout,"equ	_va,_va+_rtlb_cstr_siz"$,;

				// continue
				idx=idx + 1;
			}

			// assembler
			fprint	fout,"## end of define string buffers"$,;
			if (need_stft)
			{
				fprint	fout,""$,;
				fprint	fout,"## define SPI-TFT buffers"$,;
				fprint	fout,"equ	_stft_spi_max,8"$,;
				fprint	fout,"equ	_stft_pix_max,128"$,;
				fprint	fout,"equ	_stft_spi_buf,_va"$,;
				fprint	fout,"equ	_va,_va+_stft_spi_max"$,;
				fprint	fout,"equ	_stft_pix_buf,_va"$,;
				fprint	fout,"equ	_va,_va+_stft_pix_max"$,;
				fprint	fout,"## end of define SPI-TFT buffers"$,;
			}
			fprint	fout,"equ	_rtlb_var_array,_va"$,;

			// continue
			fgets	fin,lbuf;
			continue;
		}
		pindex	cmp=$(lbuf),"^#@rom_siz@$";
		if (cmp>0)
		{
			fprint	fout,"romsiz	#"$,,opt_rom_siz;

			// continue
			fgets	fin,lbuf;
			continue;
		}
		pindex	cmp=$(lbuf),"^#@incl_lib@$";
		if (cmp>0)
		{
			if (need_math)
			{
				fprint	fout,"incl	"$""blky2mcvm_libmath$(z).incl"$"$,;
			}
			if (need_wire)
			{
				fprint	fout,"incl	"$""blky2mcvm_libwire.incl"$"$,;
			}
			if (need_stft)
			{
				fprint	fout,"incl	"$""blky2mcvm_libstft.incl"$"$,;
			}

			// continue
			fgets	fin,lbuf;
			continue;
		}

		sub		"@mul_need@",$(str_bool#(opt_mul_need)),lbuf;
		sub		"@div_need@",$(str_bool#(opt_div_need)),lbuf;
		sub		"@fpu_need@",$(str_bool#(opt_fpu_need)),lbuf;
		sub		"@iram_need@",$(str_bool#(opt_iram_need)),lbuf;
		sub		"@iram_stack@",$(str_bool#(opt_iram_stack)),lbuf;
		if (opt_cpu_mod=opt_nh)
		{
			sub		"@cpu_mod@","l",lbuf;
		}
		else
		{
			sub		"@cpu_mod@","w",lbuf;
		}
		if (opt_sim_mod)
		{
			sub		"@sim_mod@","",lbuf;
		}
		else
		{
			sub		"@sim_mod@","#",lbuf;
		}
		if (true)
		{
			sub		"@cstr_siz@",#(opt_cstr_siz),lbuf;
			sub		"@isr_bank@",#(opt_isr_bank),lbuf;
			sub		"@uart_baud@",$(str_uart_baud),lbuf;
		}
		fputl	fout,$(lbuf);

		// continue
		fgets	fin,lbuf;
	}

	// close files
	fclose	fin;
	fclose	fout;

	// replace output file
	fmove	$(fnam_tmp),$(fnam_out), force;


	leave	stop_error;
}

